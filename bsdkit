#!/usr/local/bin/zsh

setopt errreturn nounset pipefail

setopt pushdsilent

: ${BSDKIT_DESTDIR:="/mnt"}
: ${BSDKIT_JAIL_NAME:="bsdkit"}

# Default partition sizes
: ${BSDKIT_PART_SIZE_BOOT:="512K"}
: ${BSDKIT_PART_SIZE_EFI:="8M"}
: ${BSDKIT_PART_SIZE_ROOT:="2G"}
: ${BSDKIT_PART_SIZE_SWAP:="0"}
: ${BSDKIT_PART_SIZE_TMP:="64M"}
: ${BSDKIT_PART_SIZE_VAR:="4G"}

# Default partition labels
: ${BSDKIT_LABEL_BOOT:="boot"}
: ${BSDKIT_LABEL_EFI:="efiboot"}
: ${BSDKIT_LABEL_ROOT:="root"}
: ${BSDKIT_LABEL_SWAP:="swap"}
: ${BSDKIT_LABEL_TMP:="tmp"}
: ${BSDKIT_LABEL_VAR:="var"}
: ${BSDKIT_LABEL_USR:="usr"}

# Default install flags
: ${BSDKIT_INSTALL_KERNEL:="YES"}
: ${BSDKIT_INSTALL_SRC:="YES"}
: ${BSDKIT_INSTALL_DEBUG:="NO"}
: ${BSDKIT_INSTALL_TESTS:="NO"}

# Other defaults
: ${BSDKIT_PROCFS_ENABLE:="YES"}
: ${BSDKIT_FDESCFS_ENABLE:="YES"}
: ${BSDKIT_ZFS_POOL:="rpool"}
: ${BSDKIT_IMG_DATA_LABEL:="2e158b17-5e10-11e5-ac21-080027af0e2a"}
: ${BSDKIT_PKG_LOCKFILE:="/tmp/pkg.lock"}
: ${BSDKIT_PKG_LOCKTIME:="120"}
: ${BSDKIT_FREEBSD_DISTDIR:="/usr/freebsd-dist"}
: ${BSDKIT_SSH_PUBLIC_KEY:=""}
: ${BSDKIT_JAIL_PROXY:=""}
: ${BSDKIT_SWAP_DEVICE_SIZE:="8"}

# Ansible
: ${ANSIBLE_DISPLAY_OK_HOSTS:="true"}
: ${ANSIBLE_DISPLAY_SKIPPED_HOSTS:="true"}

# Default release and package URLs
: ${BSDKIT_ROOT_URL:="https://hub.olgeni.com/FreeBSD"}
: ${BSDKIT_VERSION:="14.3"}
: ${BSDKIT_ARCH:="amd64"}
: ${BSDKIT_TREE:="default"}
: ${BSDKIT_PKGSET:="nox11"}

# Default FreeBSD release and package URLs templates
: ${FREEBSD_REL_URL_TEMPLATE:='%%ROOT_URL%%/release-%%VERSION%%-%%ARCH%%'}
: ${FREEBSD_PKG_URL_TEMPLATE:='%%ROOT_URL%%/packages-${ABI}-%%TREE%%-%%PKGSET%%'}

# Default FreeBSD release and package URLs
: ${FREEBSD_REL_URL:=''} # initialized by __parse-options
: ${FREEBSD_PKG_URL:=''} # initialized by __parse-options

# Default ZFS options
DEFAULT_ASHIFT=12

ZPOOL_CREATE_CMD=(zpool create -o ashift=${DEFAULT_ASHIFT})
ZFS_CREATE_CMD=(zfs create)
ZFS_SNAPSHOT_CMD=(zfs snapshot)
ZFS_CMD=(zfs)
ZFS_COMPRESSION_ALGORITHM=zstd

BSDKIT_CONFIG=/usr/local/etc/bsdkit.yml
BSDKIT_SRCDIR=$(dirname "$(realpath "$0")")
BSDKIT_SCRIPT=$(realpath $0)
ANSIBLE_PYTHON_INTERPRETER=/usr/local/bin/python3

RUBY_LIBDIR_LIST=(
    "/usr/local/lib/ruby"
    "/usr/local/lib/ruby/gems"
    "/usr/local/lib/ruby/site_ruby"
    "/usr/local/lib/ruby/vendor_ruby"
)

PERL_LIBDIR_LIST=(
    "/usr/local/lib/perl5"
)

SERVICE_RESTART_BLACKLIST=(
    "bastille"
    "dev_aws_disk"
    "ec2_configinit"
    "ec2_fetchkey"
    "ec2_loghostkey"
    "immortaldir"
    "iocage"
    "runsvdir"
    "vm"
    "xdm"
)

SCRIPT_PATH="$(dirname $(realpath $0))"
SCRIPT_NAME="$(basename $0)"

source ${SCRIPT_PATH}/lib/system.inc.sh
source ${SCRIPT_PATH}/lib/colors.inc.sh
source ${SCRIPT_PATH}/lib/hr-to-bytes.inc.sh
source ${SCRIPT_PATH}/lib/is-yes.inc.sh
source ${SCRIPT_PATH}/lib/yaml.inc.sh
source ${SCRIPT_PATH}/lib/rc.inc.sh

if command -v pv > /dev/null 2>&1; then
    CAT_CMD=(pv -c -w 75)
else
    CAT_CMD=/bin/cat
fi

if [ -z ${BSDKIT_PART_SIZE_SWAP} ]; then
    BSDKIT_PART_SIZE_SWAP=0
fi

if [ -z ${BSDKIT_SSH_PUBLIC_KEY} ] && [ -e ~/.ssh/id_rsa.pub ]; then
    BSDKIT_SSH_PUBLIC_KEY="$(cat ~/.ssh/id_rsa.pub)"
fi

usage() {
    # Print a usage message to stderr and exit with a non-zero status.
    echo "usage: $*" >&2
    exit 1
}

reformat-fstab() {
    if [ $# -ne 1 ]; then
        usage "reformat-fstab <fstab>"
    fi

    local _fstab=$1

    if [ ! -e ${_fstab} ]; then
        error "fstab file not found: ${_fstab}"
    fi

    column -t < ${_fstab} | sort > ${_fstab}.0
    install -m 0644 -o root -g wheel ${_fstab}.0 ${_fstab}
    rm ${_fstab}.0
}

reformat-rc-conf() {
    if [ $# -ne 1 ]; then
        usage "reformat-rc-conf <rc.conf>"
    fi

    local _rc_conf=$1

    if [ ! -e ${_rc_conf} ]; then
        error "rc.conf file not found: ${_rc_conf}"
    fi

    sysrc -a -e > ${_rc_conf}.0
    install -m 0644 -o root -g wheel ${_rc_conf}.0 ${_rc_conf}
    rm ${_rc_conf}.0
}

reformat-loader-conf() {
    if [ $# -ne 1 ]; then
        usage "reformat-loader-conf <loader.conf>"
    fi

    local _loader_conf=$1

    if [ ! -e ${_loader_conf} ]; then
        error "loader.conf file not found: ${_loader_conf}"
    fi

    sed -e '/^$/d' -e '/^[[:space:]]*#/d' ${_loader_conf} | sort > ${_loader_conf}.0
    install -m 0644 -o root -g wheel ${_loader_conf}.0 ${_loader_conf}
    rm ${_loader_conf}.0
}

reformat-sysctl-conf() {
    if [ $# -ne 1 ]; then
        usage "reformat-sysctl-conf <sysctl.conf>"
    fi

    local _sysctl_conf=$1

    if [ ! -e ${_sysctl_conf} ]; then
        error "sysctl.conf file not found: ${_sysctl_conf}"
    fi

    sed -e '/^$/d' -e '/^[[:space:]]*#/d' ${_sysctl_conf} | sort > ${_sysctl_conf}.0
    install -m 0644 -o root -g wheel ${_sysctl_conf}.0 ${_sysctl_conf}
    rm ${_sysctl_conf}.0
}

__check-python3() {
    if ! command -v python3 > /dev/null 2>&1; then
        pkg install -y lang/python3
    fi
}

__check-ansible() {
    if ! command -v ansible-playbook > /dev/null 2>&1; then
        pkg install -y sysutils/ansible
    fi
}

__check-go-yq() {
    if ! command -v pkg > /dev/null 2>&1; then
        return 0
    fi

    if ! command -v yq > /dev/null 2>&1; then
        pkg install -y textproc/go-yq
    else
        if pkg info textproc/yq > /dev/null 2>&1; then
            pkg install -y textproc/go-yq
        fi
    fi
}

__check-iocage() {
    if ! command -v iocage > /dev/null 2>&1; then
        pkg install -y sysutils/iocage
    fi
}

__check-py-pyaml() {
    if ! command -v pkg > /dev/null 2>&1; then
        return 0
    fi

    if ! pkg info -q textproc/py-pyaml > /dev/null 2>&1; then
        pkg install -y textproc/py-pyaml
    fi
}

__check-requirements() {
    __check-python3
    __check-ansible
}

__environment() {
    echo \
        BSDKIT_DESTDIR=\"${BSDKIT_DESTDIR}\" \
        BSDKIT_JAIL_NAME=\"${BSDKIT_JAIL_NAME}\" \
        BSDKIT_PART_SIZE_BOOT=\"${BSDKIT_PART_SIZE_BOOT}\" \
        BSDKIT_PART_SIZE_EFI=\"${BSDKIT_PART_SIZE_EFI}\" \
        BSDKIT_PART_SIZE_ROOT=\"${BSDKIT_PART_SIZE_ROOT}\" \
        BSDKIT_PART_SIZE_SWAP=\"${BSDKIT_PART_SIZE_SWAP}\" \
        BSDKIT_PART_SIZE_TMP=\"${BSDKIT_PART_SIZE_TMP}\" \
        BSDKIT_PART_SIZE_VAR=\"${BSDKIT_PART_SIZE_VAR}\" \
        BSDKIT_LABEL_BOOT=\"${BSDKIT_LABEL_BOOT}\" \
        BSDKIT_LABEL_EFI=\"${BSDKIT_LABEL_EFI}\" \
        BSDKIT_LABEL_ROOT=\"${BSDKIT_LABEL_ROOT}\" \
        BSDKIT_LABEL_SWAP=\"${BSDKIT_LABEL_SWAP}\" \
        BSDKIT_LABEL_TMP=\"${BSDKIT_LABEL_TMP}\" \
        BSDKIT_LABEL_USR=\"${BSDKIT_LABEL_USR}\" \
        BSDKIT_LABEL_VAR=\"${BSDKIT_LABEL_VAR}\" \
        BSDKIT_INSTALL_KERNEL=\"${BSDKIT_INSTALL_KERNEL}\" \
        BSDKIT_INSTALL_SRC=\"${BSDKIT_INSTALL_SRC}\" \
        BSDKIT_INSTALL_DEBUG=\"${BSDKIT_INSTALL_DEBUG}\" \
        BSDKIT_INSTALL_TESTS=\"${BSDKIT_INSTALL_TESTS}\" \
        BSDKIT_PROCFS_ENABLE=\"${BSDKIT_PROCFS_ENABLE}\" \
        BSDKIT_FDESCFS_ENABLE=\"${BSDKIT_FDESCFS_ENABLE}\" \
        BSDKIT_ZFS_POOL=\"${BSDKIT_ZFS_POOL}\" \
        BSDKIT_IMG_DATA_LABEL=\"${BSDKIT_IMG_DATA_LABEL}\" \
        BSDKIT_PKG_LOCKFILE=\"${BSDKIT_PKG_LOCKFILE}\" \
        BSDKIT_PKG_LOCKTIME=\"${BSDKIT_PKG_LOCKTIME}\" \
        BSDKIT_FREEBSD_DISTDIR=\"${BSDKIT_FREEBSD_DISTDIR}\" \
        BSDKIT_ROOT_URL=\"${BSDKIT_ROOT_URL}\" \
        BSDKIT_JAIL_PROXY=\"${BSDKIT_JAIL_PROXY}\" \
        BSDKIT_SWAP_DEVICE_SIZE=\"${BSDKIT_SWAP_DEVICE_SIZE}\" \
        BSDKIT_VERSION=\"${BSDKIT_VERSION}\" \
        BSDKIT_ARCH=\"${BSDKIT_ARCH}\" \
        BSDKIT_TREE=\"${BSDKIT_TREE}\" \
        BSDKIT_PKGSET=\"${BSDKIT_PKGSET}\" \
        BSDKIT_SSH_PUBLIC_KEY=\"${BSDKIT_SSH_PUBLIC_KEY}\" \
        ANSIBLE_DISPLAY_OK_HOSTS=\"${ANSIBLE_DISPLAY_OK_HOSTS}\" \
        ANSIBLE_DISPLAY_SKIPPED_HOSTS=\"${ANSIBLE_DISPLAY_SKIPPED_HOSTS}\"
}

__parse-url() {
    local _url=$1

    echo ${_url} | sed \
        -e "s|%%ROOT_URL%%|${BSDKIT_ROOT_URL}|g" \
        -e "s|%%VERSION%%|${BSDKIT_VERSION}|g" \
        -e "s|%%ARCH%%|${BSDKIT_ARCH}|g" \
        -e "s|%%TREE%%|${BSDKIT_TREE}|g" \
        -e "s|%%PKGSET%%|${BSDKIT_PKGSET}|g"
}

__local-options() {
    cat << EOF
local BSDKIT_ROOT_URL='${BSDKIT_ROOT_URL}';
local BSDKIT_VERSION='${BSDKIT_VERSION}';
local BSDKIT_ARCH='${BSDKIT_ARCH}';
local BSDKIT_TREE='${BSDKIT_TREE}';
local BSDKIT_PKGSET='${BSDKIT_PKGSET}';
local FREEBSD_REL_URL='${FREEBSD_REL_URL}';
local FREEBSD_PKG_URL='${FREEBSD_PKG_URL}';
EOF
}

__parse-options() {
    local _opts _opts_args

    # -F: Halts at first undefined spec, emitting an error message; doesn't
    #     perform option removal or extraction.
    #
    # -D: Removes all matched options from the input parameters, including
    #     initial '-' or '--'.
    #
    # zparseopts flags:
    # -D: Remove recognized options from positional parameters
    # -E: Stop at first unrecognized option (don't error on unknown options)
    # -K: Keep existing array values if option not present (vs clearing array)
    # -a: Store options in array _opts
    # -A: Store options with arguments in associative array _opts_args
    zparseopts -D -E -K -a _opts -A _opts_args r: v: a: p: z:

    local _option

    for _option in ${(@k)_opts_args}; do
        case ${_option} in
            -r)
                BSDKIT_ROOT_URL=${_opts_args[-r]}
                ;;
            -v)
                BSDKIT_VERSION=${_opts_args[-v]}
                ;;
            -a)
                BSDKIT_ARCH=${_opts_args[-a]}
                ;;
            -p)
                BSDKIT_TREE=${_opts_args[-p]}
                ;;
            -z)
                BSDKIT_PKGSET=${_opts_args[-z]}
                ;;
            *)
                ;;
        esac
    done

    FREEBSD_REL_URL=$(__parse-url ${FREEBSD_REL_URL_TEMPLATE})
    FREEBSD_PKG_URL=$(__parse-url ${FREEBSD_PKG_URL_TEMPLATE})

    cat << EOF
BSDKIT_ROOT_URL='${BSDKIT_ROOT_URL}';
BSDKIT_VERSION='${BSDKIT_VERSION}';
BSDKIT_ARCH='${BSDKIT_ARCH}';
BSDKIT_TREE='${BSDKIT_TREE}';
BSDKIT_PKGSET='${BSDKIT_PKGSET}';
FREEBSD_REL_URL='${FREEBSD_REL_URL}';
FREEBSD_PKG_URL='${FREEBSD_PKG_URL}';
set -- $*;
EOF
}

__valid-url() {
    local _url=$1

    case ${_url} in
        http://*)
            return 0
            ;;
        https://*)
            return 0
            ;;
        ftp://*)
            return 0
            ;;
        ftps://*)
            return 0
            ;;
        file://*)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

__valid-relpath() {
    local _relpath=$1

    __valid-url ${_relpath} && return 0

    [ -d ${_relpath} ]
    [ -f ${_relpath}/base.txz ]

    return 0
}

__valid-pkgpath() {
    local _pkgpath=$1

    __valid-url ${_pkgpath} && return 0

    [ -d ${_pkgpath} ]
    [ -f ${_pkgpath}/packagesite.txz ]
}

__valid-staging() {
    local _staging=$1

    [ -f ${_staging}/base.ufs.uzip ]
    [ -d ${_staging}/boot ]
    [ -f ${_staging}/memroot.ufs.gz ]
}

__valid-destdir() {
    local _destdir=$1

    [ -d ${_destdir} ] && [ ${_destdir} != "/" ] && [ -f ${_destdir}/bin/sh ]
}

__valid-freebsd-distdir() {
    local _freebsd_distdir=$1

    [ -n "${_freebsd_distdir}" ] && [ -d "${_freebsd_distdir}" ] && [ "${_freebsd_distdir}" != "/" ]
}

__valid-bsdkit() {
    local _bsdkit=$1

    [ -d ${_bsdkit} ] && [ -f ${_bsdkit}/bsdkit ]
}

__valid-class() {
    local _class=$1

    case ${_class} in
        single)
            return 0
            ;;
        multi)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

__gmirror-configure() {
    local _mirror=$1

    shift

    [ -n ${_mirror} ]

    local _device=$1

    shift

    [ -n ${_device} ]

    gmirror label -v ${_mirror} ${_device}

    for _device in "$@"; do
        gmirror insert ${_mirror} ${_device}
    done

    return 0
}

__install-efi-loader() {
    local _device=$1

    # FreeBSD < 13.0: gpart bootcode -p /boot/boot1.efifat -i ${_p} ${_device}

    newfs_msdos -L efi -F 16 -c 2 ${_device}

    local _efi_tmp_dir=$(mktemp -d)

    mount -t msdos ${_device} ${_efi_tmp_dir}
    mkdir -p ${_efi_tmp_dir}/efi/boot
    install /boot/loader.efi ${_efi_tmp_dir}/efi/boot/bootx64.efi

    echo "BOOTx64.efi" > ${_efi_tmp_dir}/efi/boot/startup.nsh

    umount ${_efi_tmp_dir}
    rmdir ${_efi_tmp_dir}
}

__gpt-ufs-partition-multi() {
    local _destdir=$1
    local _device=$2

    [ -d ${_destdir} ]
    [ -n ${_device} ]
    [ -e /dev/${_device} ]

    gpart destroy -F ${_device} 2> /dev/null || :
    gpart create -s gpt ${_device}

    gpart bootcode -b /boot/pmbr ${_device}

    local _p=1

    gpart add -a 4k -i ${_p} -s ${BSDKIT_PART_SIZE_BOOT} -t freebsd-boot -l ${BSDKIT_LABEL_BOOT} ${_device}
    gpart bootcode -p /boot/gptboot -i ${_p} ${_device}
    _p=$((_p + 1))

    gpart add -a 4k -i ${_p} -s ${BSDKIT_PART_SIZE_EFI} -t efi -l ${BSDKIT_LABEL_EFI} ${_device}
    __install-efi-loader /dev/${_device}p${_p}
    _p=$((_p + 1))

    if __has-swap; then
        gpart add -a 4k -i ${_p} -s ${BSDKIT_PART_SIZE_SWAP} -t freebsd-swap -l ${BSDKIT_LABEL_SWAP} ${_device}
        _p=$((_p + 1))
        swapon /dev/gpt/${BSDKIT_LABEL_SWAP}
    fi

    gpart add -a 4k -i ${_p} -s ${BSDKIT_PART_SIZE_ROOT} -t freebsd-ufs -l ${BSDKIT_LABEL_ROOT} ${_device}
    _p=$((_p + 1))
    gpart add -a 4k -i ${_p} -s ${BSDKIT_PART_SIZE_TMP} -t freebsd-ufs -l ${BSDKIT_LABEL_TMP} ${_device}
    _p=$((_p + 1))
    gpart add -a 4k -i ${_p} -s ${BSDKIT_PART_SIZE_VAR} -t freebsd-ufs -l ${BSDKIT_LABEL_VAR} ${_device}
    _p=$((_p + 1))
    gpart add -a 4k -i ${_p} -t freebsd-ufs -l ${BSDKIT_LABEL_USR} ${_device}
    _p=$((_p + 1))

    # FIXME: use -j

    newfs -L ${BSDKIT_LABEL_ROOT} /dev/gpt/${BSDKIT_LABEL_ROOT}
    newfs -U -L ${BSDKIT_LABEL_TMP} -n /dev/gpt/${BSDKIT_LABEL_TMP}
    newfs -U -L ${BSDKIT_LABEL_VAR} /dev/gpt/${BSDKIT_LABEL_VAR}
    newfs -U -L ${BSDKIT_LABEL_USR} /dev/gpt/${BSDKIT_LABEL_USR}

    mount -o async,noatime /dev/gpt/${BSDKIT_LABEL_ROOT} ${_destdir}

    mkdir -p ${_destdir}/cdrom
    mkdir -p ${_destdir}/etc
    mkdir -p ${_destdir}/tmp
    mkdir -p ${_destdir}/usr
    mkdir -p ${_destdir}/var

    if [ -d /cdrom ]; then
        mount -t nullfs /cdrom ${_destdir}/cdrom
    fi

    mount -o async,noatime /dev/gpt/${BSDKIT_LABEL_VAR} ${_destdir}/var
    mount -o async,noatime /dev/gpt/${BSDKIT_LABEL_TMP} ${_destdir}/tmp
    mount -o async,noatime /dev/gpt/${BSDKIT_LABEL_USR} ${_destdir}/usr

    touch ${_destdir}/etc/fstab

    {
        echo "/dev/ufs/${BSDKIT_LABEL_ROOT} /    ufs rw 1 1"
        echo "/dev/ufs/${BSDKIT_LABEL_VAR}  /var ufs rw 2 2"
        echo "/dev/ufs/${BSDKIT_LABEL_TMP}  /tmp ufs rw 2 2"
        echo "/dev/ufs/${BSDKIT_LABEL_USR}  /usr ufs rw 2 2"
    } >> ${_destdir}/etc/fstab

    __link-home ${_destdir}

    return 0
}

__gpt-ufs-partition-single() {
    local _destdir=$1
    local _device=$2

    [ -d ${_destdir} ]
    [ -n ${_device} ]
    [ -e /dev/${_device} ]

    gpart destroy -F ${_device} 2> /dev/null || :
    gpart create -s gpt ${_device}

    gpart bootcode -b /boot/pmbr ${_device}

    local _p=1

    gpart add -a 4k -i ${_p} -s ${BSDKIT_PART_SIZE_BOOT} -t freebsd-boot -l ${BSDKIT_LABEL_BOOT} ${_device}
    gpart bootcode -p /boot/gptboot -i ${_p} ${_device}
    _p=$((_p + 1))

    gpart add -a 4k -i ${_p} -s ${BSDKIT_PART_SIZE_EFI} -t efi -l ${BSDKIT_LABEL_EFI} ${_device}
    __install-efi-loader /dev/${_device}p${_p}
    _p=$((_p + 1))

    gpart add -a 4k -i ${_p} -t freebsd-ufs -l ${BSDKIT_LABEL_ROOT} ${_device}
    _p=$((_p + 1))

    # FIXME: use -j

    newfs -U -L ${BSDKIT_LABEL_ROOT} -n /dev/gpt/${BSDKIT_LABEL_ROOT}

    mount -o async,noatime /dev/gpt/${BSDKIT_LABEL_ROOT} ${_destdir}

    mkdir -p ${_destdir}/cdrom
    mkdir -p ${_destdir}/etc

    if [ -d /cdrom ]; then
        mount -t nullfs /cdrom ${_destdir}/cdrom
    fi

    touch ${_destdir}/etc/fstab

    echo "/dev/ufs/${BSDKIT_LABEL_ROOT} / ufs rw 1 1" >> ${_destdir}/etc/fstab

    __link-home ${_destdir}

    return 0
}

__mbr-ufs-partition-multi() {
    local _destdir=$1
    local _device=$2

    [ -d ${_destdir} ]
    [ -n ${_device} ]
    [ -e /dev/${_device} ]

    # FIXME: refactor

    gpart destroy -F ${_device} 2> /dev/null || :
    gpart create -s mbr ${_device}
    gpart add -a 4k -i 1 -t freebsd ${_device}
    gpart set -a active -i 1 ${_device}

    gpart destroy -F ${_device}s1 2> /dev/null || :
    gpart create -s BSD ${_device}s1

    gpart bootcode -b /boot/mbr ${_device}
    gpart bootcode -b /boot/boot ${_device}s1

    # FIXME: refactor (end)

    gpart add -a 4k -i 1 -s ${BSDKIT_PART_SIZE_ROOT} -t freebsd-ufs ${_device}s1 # a

    if __has-swap; then
        gpart add -a 4k -i 2 -s ${BSDKIT_PART_SIZE_SWAP} -t freebsd-swap ${_device}s1 # b
        swapon /dev/${_device}s1b
    fi

    # reserved partition c
    gpart add -a 4k -i 4 -s ${BSDKIT_PART_SIZE_TMP} -t freebsd-ufs ${_device}s1 # d
    gpart add -a 4k -i 5 -s ${BSDKIT_PART_SIZE_VAR} -t freebsd-ufs ${_device}s1 # e
    gpart add -a 4k -i 6 -t freebsd-ufs ${_device}s1                            # f

    # FIXME: use -j

    newfs -L ${BSDKIT_LABEL_ROOT} -n /dev/${_device}s1a
    newfs -U -L ${BSDKIT_LABEL_TMP} -n /dev/${_device}s1d
    newfs -U -L ${BSDKIT_LABEL_VAR} /dev/${_device}s1e
    newfs -U -L ${BSDKIT_LABEL_USR} /dev/${_device}s1f

    glabel label -v swap /dev/${_device}s1b

    mount -o async,noatime /dev/ufs/${BSDKIT_LABEL_ROOT} ${_destdir}

    mkdir -p ${_destdir}/cdrom
    mkdir -p ${_destdir}/etc
    mkdir -p ${_destdir}/tmp
    mkdir -p ${_destdir}/usr
    mkdir -p ${_destdir}/var

    if [ -d /cdrom ]; then
        mount -t nullfs /cdrom ${_destdir}/cdrom
    fi

    mount -o async,noatime /dev/ufs/${BSDKIT_LABEL_VAR} ${_destdir}/var
    mount -o async,noatime /dev/ufs/${BSDKIT_LABEL_TMP} ${_destdir}/tmp
    mount -o async,noatime /dev/ufs/${BSDKIT_LABEL_USR} ${_destdir}/usr

    touch ${_destdir}/etc/fstab

    {
        echo "/dev/ufs/${BSDKIT_LABEL_ROOT} /    ufs rw 1 1"
        echo "/dev/ufs/${BSDKIT_LABEL_VAR}  /var ufs rw 2 2"
        echo "/dev/ufs/${BSDKIT_LABEL_TMP}  /tmp ufs rw 2 2"
        echo "/dev/ufs/${BSDKIT_LABEL_USR}  /usr ufs rw 2 2"
    } >> ${_destdir}/etc/fstab

    __link-home ${_destdir}

    return 0
}

__mbr-ufs-partition-single() {
    local _destdir=$1
    local _device=$2

    [ -d ${_destdir} ]
    [ -n ${_device} ]
    [ -e /dev/${_device} ]

    # FIXME: refactor

    gpart destroy -F ${_device} 2> /dev/null || :
    gpart create -s mbr ${_device}
    gpart add -a 4k -i 1 -t freebsd ${_device}
    gpart set -a active -i 1 ${_device}

    gpart destroy -F ${_device}s1 2> /dev/null || :
    gpart create -s BSD ${_device}s1

    gpart bootcode -b /boot/mbr ${_device}
    gpart bootcode -b /boot/boot ${_device}s1

    # FIXME: refactor (end)

    gpart add -a 4k -i 1 -t freebsd-ufs ${_device}s1 # a

    # FIXME: use -j

    newfs -U -L ${BSDKIT_LABEL_ROOT} /dev/${_device}s1a

    mount -o async,noatime /dev/ufs/${BSDKIT_LABEL_ROOT} ${_destdir}

    mkdir -p ${_destdir}/cdrom
    mkdir -p ${_destdir}/etc

    if [ -d /cdrom ]; then
        mount -t nullfs /cdrom ${_destdir}/cdrom
    fi

    touch ${_destdir}/etc/fstab

    {
        echo "/dev/ufs/${BSDKIT_LABEL_ROOT} / ufs rw 1 1"
    } >> ${_destdir}/etc/fstab

    __link-home ${_destdir}

    return 0
}

__zfs-create-pool() {
    local _destdir=$1

    shift 1

    local _device
    local _devices

    _devices=($*)

    [ -d ${_destdir} ]

    sysctl -q kern.geom.debugflags=0x10

    for _device in ${_devices}; do
        gpart destroy -F ${_device} 2> /dev/null || :

        dd if=/boot/zfsboot of=/dev/${_device} count=1
        dd if=/boot/zfsboot of=/dev/${_device} iseek=1 oseek=1024
    done

    sysctl -q kern.geom.debugflags=0x00

    local _options=(-m none -o altroot=${_destdir})
    local _device

    for _device in ${_devices}; do
        zpool labelclear -f ${_device} 2> /dev/null || :
    done

    case ${#_devices} in
        1)
            ${ZPOOL_CREATE_CMD} \
                ${_options} ${BSDKIT_ZFS_POOL} \
                ${_devices[1]}
            ;;
        2)
            ${ZPOOL_CREATE_CMD} \
                ${_options} ${BSDKIT_ZFS_POOL} \
                mirror ${_devices[1]} ${_devices[2]}
            ;;
        3)
            ${ZPOOL_CREATE_CMD} \
                ${_options} ${BSDKIT_ZFS_POOL} \
                raidz1 ${_devices[1]} ${_devices[2]} ${_devices[3]}
            ;;
        *)
            error "unsupported number of devices in pool (__zfs-create-pool)."
            ;;
    esac

    if [ $(uname -K) -ge 1300000 ]; then
        ${ZFS_CMD} set xattr=sa ${BSDKIT_ZFS_POOL}
    fi

    if __has-swap; then
        ${ZFS_CREATE_CMD} \
            -o checksum=off \
            -o compression=off \
            -o dedup=off \
            -o sync=disabled \
            -o primarycache=none \
            -o org.freebsd:swap=on \
            -V ${BSDKIT_PART_SIZE_SWAP} \
            ${BSDKIT_ZFS_POOL}/swap
    fi

    return 0
}

__zfs-create-gpt-pool() {
    local _destdir=$1

    shift 1

    local _devices

    _devices=($*)

    [ -d ${_destdir} ]

    local _device_index=0

    local _pool_partition=0

    for _device in ${_devices}; do
        gpart destroy -F ${_device} 2> /dev/null || :
        gpart create -s gpt ${_device}

        local _p=1

        gpart add -a 4k -i ${_p} -s ${BSDKIT_PART_SIZE_BOOT} -t freebsd-boot -l ${BSDKIT_LABEL_BOOT}${_device_index} ${_device}
        gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i ${_p} ${_device}
        _p=$((_p + 1))

        gpart add -a 4k -i ${_p} -s ${BSDKIT_PART_SIZE_EFI} -t efi -l ${BSDKIT_LABEL_EFI}${_device_index} ${_device}
        __install-efi-loader /dev/${_device}p${_p}
        _p=$((_p + 1))

        if __has-swap; then
            gpart add -a 4k -i ${_p} -s ${BSDKIT_PART_SIZE_SWAP} -t freebsd-swap -l ${BSDKIT_LABEL_SWAP}${_device_index} ${_device}
            _p=$((_p + 1))
            swapon /dev/gpt/${BSDKIT_LABEL_SWAP}${_device_index}
        fi

        gpart add -a 4k -i ${_p} -t freebsd-zfs -l pool${_device_index} ${_device}
        gpart set -a bootme -i ${_p} ${_device}
        _pool_partition=${_p}
        _p=$((_p + 1))

        _device_index=$((_device_index + 1))
    done

    local _options=(-f -m none -o altroot=${_destdir})

    local _suffix="p${_pool_partition}"

    local _device

    for _device in ${_devices}; do
        zpool labelclear -f ${_device}${_suffix} 2> /dev/null || :
    done

    case ${#_devices} in
        1)
            ${ZPOOL_CREATE_CMD} \
                ${_options} ${BSDKIT_ZFS_POOL} \
                ${_devices[1]}${_suffix}
            ;;
        2)
            ${ZPOOL_CREATE_CMD} \
                ${_options} ${BSDKIT_ZFS_POOL} \
                mirror ${_devices[1]}${_suffix} ${_devices[2]}${_suffix}
            ;;
        3)
            ${ZPOOL_CREATE_CMD} \
                ${_options} ${BSDKIT_ZFS_POOL} \
                raidz1 ${_devices[1]}${_suffix} ${_devices[2]}${_suffix} ${_devices[3]}${_suffix}
            ;;
        *)
            error "unsupported number of devices in pool (__zfs-create-gpt-pool)."
            ;;
    esac

    if [ $(uname -K) -ge 1300000 ]; then
        ${ZFS_CMD} set xattr=sa ${BSDKIT_ZFS_POOL}
    fi

    return 0
}

__zfs-create-mbr-pool() {
    local _destdir=$1

    shift 1

    local _devices

    _devices=($*)

    [ -d ${_destdir} ]

    local _device

    for _device in ${_devices}; do
        # FIXME: refactor

        gpart destroy -F ${_device} 2> /dev/null || :
        gpart create -s mbr ${_device}
        gpart add -a 4k -i 1 -t freebsd ${_device}
        gpart set -a active -i 1 ${_device}
        gpart destroy -F ${_device}s1 2> /dev/null || :
        gpart create -s BSD ${_device}s1
        gpart bootcode -b /boot/mbr ${_device}

        local _autorootsize="$(($(diskinfo ${_device} | cut -f 3) / 1024 / 1024 - ${BSDKIT_PART_SIZE_SWAP%G} * 1024))"

        # do not align partitions here
        gpart add -a 4k -i 1 -s ${_autorootsize}M -t freebsd-zfs ${_device}s1 # a

        if __has-swap; then
            gpart add -a 4k -i 2 -t freebsd-swap ${_device}s1 # b
            swapon /dev/${_device}s1b
        fi

        dd if=/boot/zfsboot of=/dev/${_device}s1a count=1
        dd if=/boot/zfsboot of=/dev/${_device}s1a iseek=1 oseek=1024
    done

    local _options=(-f -m none -o altroot=${_destdir})

    local _suffix="s1a"

    local _device

    for _device in ${_device}; do
        zpool labelclear -f ${_device}${_suffix} 2> /dev/null || :
    done

    case ${#_devices} in
        1)
            ${ZPOOL_CREATE_CMD} \
                ${_options} ${BSDKIT_ZFS_POOL} \
                ${_devices[1]}${_suffix}
            ;;
        2)
            ${ZPOOL_CREATE_CMD} \
                ${_options} ${BSDKIT_ZFS_POOL} \
                mirror ${_devices[1]}${_suffix} ${_devices[2]}${_suffix}
            ;;
        3)
            ${ZPOOL_CREATE_CMD} \
                ${_options} ${BSDKIT_ZFS_POOL} \
                raidz1 ${_devices[1]}${_suffix} ${_devices[2]}${_suffix} ${_devices[3]}${_suffix}
            ;;
        *)
            error "unsupported number of devices in pool (__zfs-create-mbr-pool)."
            ;;
    esac

    if [ $(uname -K) -ge 1300000 ]; then
        ${ZFS_CMD} set xattr=sa ${BSDKIT_ZFS_POOL}
    fi

    return 0
}

__zfs-create-zpool-cache() {
    local _destdir=$1

    [ -d ${_destdir} ]

    zpool set cachefile=${_destdir}/etc/zfs/zpool.cache ${BSDKIT_ZFS_POOL}
}

__zfs-compression() {
    # OS version check is "[ $(uname -K) -ge 1400000 ]"
    echo ${ZFS_COMPRESSION_ALGORITHM}
}

__zfs-create-fs() {
    local _destdir=$1

    [ -d ${_destdir} ]

    zfs set atime=off ${BSDKIT_ZFS_POOL}

    ${ZFS_CREATE_CMD} -o mountpoint=none -o canmount=noauto ${BSDKIT_ZFS_POOL}/ROOT
    ${ZFS_CREATE_CMD} -o mountpoint=/ -o canmount=noauto ${BSDKIT_ZFS_POOL}/ROOT/default

    zfs mount ${BSDKIT_ZFS_POOL}/ROOT/default

    ${ZFS_CREATE_CMD} -o mountpoint=/tmp -o setuid=off ${BSDKIT_ZFS_POOL}/tmp
    ${ZFS_CREATE_CMD} -o mountpoint=/jails ${BSDKIT_ZFS_POOL}/jails
    ${ZFS_CREATE_CMD} -o mountpoint=/usr -o canmount=off ${BSDKIT_ZFS_POOL}/usr
    ${ZFS_CREATE_CMD} -o mountpoint=/var -o canmount=off ${BSDKIT_ZFS_POOL}/var

    ${ZFS_CREATE_CMD} -o canmount=off ${BSDKIT_ZFS_POOL}/usr/local
    ${ZFS_CREATE_CMD} -o canmount=off ${BSDKIT_ZFS_POOL}/var/db

    ${ZFS_CREATE_CMD} -o compression=$(__zfs-compression) ${BSDKIT_ZFS_POOL}/usr/src
    ${ZFS_CREATE_CMD} -o compression=$(__zfs-compression) ${BSDKIT_ZFS_POOL}/usr/obj
    ${ZFS_CREATE_CMD} -o compression=$(__zfs-compression) ${BSDKIT_ZFS_POOL}/usr/ports

    ${ZFS_CREATE_CMD} -o exec=off -o compression=$(__zfs-compression) ${BSDKIT_ZFS_POOL}/var/audit
    ${ZFS_CREATE_CMD} -o exec=off -o compression=$(__zfs-compression) ${BSDKIT_ZFS_POOL}/var/crash
    ${ZFS_CREATE_CMD} -o exec=off -o compression=$(__zfs-compression) ${BSDKIT_ZFS_POOL}/var/log
    ${ZFS_CREATE_CMD} -o exec=off -o compression=$(__zfs-compression) -o atime=on ${BSDKIT_ZFS_POOL}/var/mail

    ${ZFS_CREATE_CMD} -o setuid=off ${BSDKIT_ZFS_POOL}/var/tmp
    ${ZFS_CREATE_CMD} -o setuid=off ${BSDKIT_ZFS_POOL}/usr/home

    # These cannot be created from within the chroot (wrong mountpoint). Properties will be set by Ansible.
    ${ZFS_CREATE_CMD} ${BSDKIT_ZFS_POOL}/var/db/postgres
    ${ZFS_CREATE_CMD} ${BSDKIT_ZFS_POOL}/var/db/mysql
    ${ZFS_CREATE_CMD} ${BSDKIT_ZFS_POOL}/var/db/containers
    ${ZFS_SNAPSHOT_CMD} ${BSDKIT_ZFS_POOL}/var/db/containers@empty

    mkdir -p ${_destdir}/altroot
    mkdir -p ${_destdir}/boot
    mkdir -p ${_destdir}/cdrom
    mkdir -p ${_destdir}/etc

    if [ -d /cdrom ]; then
        mount -t nullfs /cdrom ${_destdir}/cdrom
    fi

    touch ${_destdir}/etc/fstab

    __link-home ${_destdir}

    zpool set bootfs=${BSDKIT_ZFS_POOL}/ROOT/default ${BSDKIT_ZFS_POOL}

    return 0
}

__link-home() {
    local _destdir=$1

    mkdir -p ${_destdir}/usr/home
    ln -s -f usr/home ${_destdir}/home
}

__swap-setup() {
    local _destdir=$1

    __valid-destdir ${_destdir}

    local _swap

    for _swap in $(find /dev | grep -E "(gpt|label)/swap" | rs 1 0); do
        echo "${_swap} none swap sw 0 0" >> ${_destdir}/etc/fstab
    done

    return 0
}

__procfs-setup() {
    if ! is-yes ${BSDKIT_PROCFS_ENABLE}; then
        return 0
    fi

    local _destdir=$1

    [ -d ${_destdir} ]

    echo "proc /proc procfs rw 0 0" >> ${_destdir}/etc/fstab

    return 0
}

__fdescfs-setup() {
    if ! is-yes ${BSDKIT_FDESCFS_ENABLE}; then
        return 0
    fi

    local _destdir=$1

    [ -d ${_destdir} ]

    echo "fdescfs /dev/fd fdescfs rw 0 0" >> ${_destdir}/etc/fstab

    return 0
}

__has-swap() {
    [ ${BSDKIT_PART_SIZE_SWAP} = 0 ] && return 1

    return 0
}

__finalize-fstab() {
    local _destdir=$1

    __valid-destdir ${_destdir}

    local _fstab=${_destdir}/etc/fstab

    echo "#linprocfs /compat/linux/proc linprocfs rw 0 0" >> ${_destdir}/etc/fstab
    echo "#tmpfs /compat/linux/dev/shm tmpfs rw,mode=1777 0 0" >> ${_destdir}/etc/fstab
    echo "#md0 none swap sw,late,file=/var/swap 0 0" >> ${_destdir}/etc/fstab

    reformat-fstab ${_fstab}
}

__fetch-release() {
    local _relpath=$1
    local _local_relpath=$2

    fetch -q -o ${_local_relpath}/MANIFEST ${_relpath}/MANIFEST

    cat ${_local_relpath}/MANIFEST | while read _filename _sha256 _size _package _desc _enable; do
        local _fetch="NO"

        case ${_package} in
            kernel_dbg)
                if is-yes ${BSDKIT_INSTALL_KERNEL} && is-yes ${BSDKIT_INSTALL_DEBUG}; then
                    _fetch="YES"
                fi
                ;;

            base_dbg)
                if is-yes ${BSDKIT_INSTALL_DEBUG}; then
                    _fetch="YES"
                fi
                ;;

            lib32_dbg)
                if is-yes ${BSDKIT_INSTALL_DEBUG}; then
                    _fetch="YES"
                fi
                ;;

            kernel)
                if is-yes ${BSDKIT_INSTALL_KERNEL}; then
                    _fetch="YES"
                fi
                ;;

            base)
                _fetch="YES"
                ;;

            lib32)
                _fetch="YES"
                ;;

            src)
                if is-yes ${BSDKIT_INSTALL_SRC}; then
                    _fetch="YES"
                fi
                ;;

            tests)
                if is-yes ${BSDKIT_INSTALL_TESTS}; then
                    _fetch="YES"
                fi
                ;;

            ports) ;;

            *) ;;
        esac

        if is-yes ${_fetch}; then
            local _sha256_local=""

            if [ -f ${_local_relpath}/${_filename} ]; then
                message "Checking: ${_filename}"
                _sha256_local=$(${CAT_CMD} ${_local_relpath}/${_filename} | sha256 -q)
            else
                _sha256_local="0"
            fi

            while [ ${_sha256} != ${_sha256_local} ]; do
                fetch -o ${_local_relpath}/${_filename} ${_relpath}/${_filename}
                message "Checking: ${_filename}"
                _sha256_local=$(${CAT_CMD} ${_local_relpath}/${_filename} | sha256 -q)
            done
        fi
    done
}

__install-release() {
    local _opts _opts_args

    # zparseopts flags:
    # -F: Fail if unrecognized options are found
    # -D: Remove recognized options from positional parameters
    # -E: Stop at first unrecognized option (don't error on unknown options)
    # -K: Keep existing array values if option not present (vs clearing array)
    # -a: Store options in array _opts
    # -A: Store options with arguments in associative array _opts_args
    zparseopts -F -D -E -K -a _opts -A _opts_args -thin

    # In Zsh, `[(I)...]` option search in the `_opts` associative array for
    # the index of a particular value, here `--thin`.

    # If `--thin` is found within the `_opts` array, `[(Ie)--thin]` returns
    # the index that matches the `--thin` value, or 0 if it's not found in
    # `_opts`.

    local _thin
    _thin=$(yes-if ${_opts[(Ie)--thin]})

    local _relpath=$1
    local _destdir=$2

    __valid-relpath ${_relpath}

    [ -d ${_destdir} ]
    [ ${_destdir} != "/" ]

    local _delete="NO"

    if __valid-url ${_relpath}; then
        local _local_relpath_root
        local _local_relpath

        local _release_tag=${BSDKIT_VERSION}-${BSDKIT_ARCH}

        _local_relpath_root=${BSDKIT_FREEBSD_DISTDIR}
        _local_relpath=${_local_relpath_root%/}/${_release_tag}

        if ! mkdir -p ${_local_relpath}; then
            _delete="YES"

            _local_relpath_root=${_destdir%/}/${BSDKIT_FREEBSD_DISTDIR}
            _local_relpath=${_local_relpath_root%/}/${_release_tag}

            message "Using ${_local_relpath_root}"

            mkdir -p ${_local_relpath}
        fi

        __fetch-release ${_relpath} ${_local_relpath}

        _relpath=${_local_relpath}
    fi

    cat ${_relpath}/MANIFEST | while read _filename _sha256 _size _package _desc _enable; do
        local _extract="NO"
        local _options=()

        local excluded_files=()

        local thin_exclude_list=(
            "bin"
            "boot"
            "lib"
            "libexec"
            "rescue"
            "sbin"
            "usr/bin"
            "usr/include"
            "usr/lib"
            "usr/lib32"
            "usr/libdata"
            "usr/libexec"
            "usr/sbin"
            "usr/share"
        )

        if is-yes ${_thin}; then
            for item in ${thin_exclude_list[@]}; do
                excluded_files+=${item}
            done
        fi

        for item in ${excluded_files[@]}; do
            _options+="--exclude ./${item} "
        done

        case ${_package} in
            kernel)
                _extract=$(yes-if ${BSDKIT_INSTALL_KERNEL})
                ;;

            kernel_dbg)
                _extract=$(yes-if ${BSDKIT_INSTALL_KERNEL} ${BSDKIT_INSTALL_DEBUG})
                ;;

            base)
                _extract="YES"
                ;;

            base_dbg)
                _extract=$(yes-if ${BSDKIT_INSTALL_DEBUG})
                ;;

            lib32)
                _options+="--exclude ./etc"
                _extract="YES"
                ;;

            lib32_dbg)
                _extract=$(yes-if ${BSDKIT_INSTALL_DEBUG})
                ;;

            src)
                _extract=$(yes-if ${BSDKIT_INSTALL_SRC})
                ;;

            tests)
                _extract=$(yes-if ${BSDKIT_INSTALL_TESTS})
                ;;

            ports)
                ;;

            *)
                ;;
        esac

        if ! is-yes ${BSDKIT_INSTALL_SRC}; then
            _options+="--exclude ./usr/src"
        fi

        if ! is-yes ${BSDKIT_INSTALL_TESTS}; then
            _options+="--exclude ./usr/tests"
        fi

        if is-yes ${_extract}; then
            message "Extracting: ${_filename}"
            ${CAT_CMD} ${_relpath}/${_filename} | tar -x -p -U -C ${_destdir} -f - ${=_options[*]}
        fi

        sync
    done

    if is-yes ${_thin}; then
        mkdir ${_destdir}/.base

        ln -s -f .base/bin ${_destdir}/bin
        ln -s -f .base/boot ${_destdir}/boot
        ln -s -f .base/lib ${_destdir}/lib
        ln -s -f .base/libexec ${_destdir}/libexec
        ln -s -f .base/rescue ${_destdir}/rescue
        ln -s -f .base/sbin ${_destdir}/sbin

        ln -s -f ../.base/usr/bin ${_destdir}/usr/bin
        ln -s -f ../.base/usr/include ${_destdir}/usr/include
        ln -s -f ../.base/usr/lib ${_destdir}/usr/lib
        ln -s -f ../.base/usr/lib32 ${_destdir}/usr/lib32
        ln -s -f ../.base/usr/libdata ${_destdir}/usr/libdata
        ln -s -f ../.base/usr/libexec ${_destdir}/usr/libexec
        ln -s -f ../.base/usr/sbin ${_destdir}/usr/sbin
        ln -s -f ../.base/usr/share ${_destdir}/usr/share

        if is-yes ${BSDKIT_INSTALL_SRC}; then
            ln -s -f ../.base/usr/src ${_destdir}/usr/src
        fi

        if is-yes ${BSDKIT_INSTALL_TESTS}; then
            ln -s -f ../.base/usr/tests ${_destdir}/usr/tests
        fi
    else
        __run-mtree ${_destdir}

        {
            mount -t devfs devfs ${_destdir}/dev
            chroot ${_destdir} /etc/rc.d/ldconfig start
        } always {
            umount -f ${_destdir}/dev
        }
    fi

    if is-yes ${_delete}; then
        rm -f ${_local_relpath}/*
        rmdir ${_local_relpath}
        rmdir ${_local_relpath_root}
    fi

    return 0
}

__run-mtree() {
    local _destdir=$1

    [ -d ${_destdir} ]
    [ ${_destdir} != "/" ]

    mtree -ideU -N ${_destdir}/etc -f ${_destdir}/etc/mtree/BSD.root.dist -p ${_destdir}/
    mtree -ideU -N ${_destdir}/etc -f ${_destdir}/etc/mtree/BSD.var.dist -p ${_destdir}/var
    mtree -ideU -N ${_destdir}/etc -f ${_destdir}/etc/mtree/BSD.usr.dist -p ${_destdir}/usr

    if [ -f ${_destdir}/etc/mtree/BSD.include.dist ]; then
        mtree -ideU -N ${_destdir}/etc -f ${_destdir}/etc/mtree/BSD.include.dist -p ${_destdir}/usr/include
    fi

    if [ -f ${_destdir}/etc/mtree/BSD.sendmail.dist ]; then
        mtree -ideU -N ${_destdir}/etc -f ${_destdir}/etc/mtree/BSD.sendmail.dist -p ${_destdir}/
    fi

    if [ -f ${_destdir}/etc/mtree/BSD.tests.dist -a -d ${_destdir}/usr/tests ]; then
        mtree -ideU -N ${_destdir}/etc -f ${_destdir}/etc/mtree/BSD.tests.dist -p ${_destdir}/usr/tests
    fi
}

__install-resolv-conf() {
    local _destdir=$1

    [ -d ${_destdir} ]
    [ ${_destdir} != "/" ]

    if [ -f /etc/resolv.conf ] && [ ! -f ${_destdir}/etc/resolv.conf ]; then
        install -m 0644 -o root -g wheel /etc/resolv.conf ${_destdir}/etc/resolv.conf
    fi
}

__install-ca-root-nss() {
    local _destdir=$1

    [ -d ${_destdir} ]
    [ ${_destdir} != "/" ]

    if [ -f /usr/local/share/certs/ca-root-nss.crt ] && [ ! -e ${_destdir}/usr/local/etc/ssl/cert.pem ]; then
        mkdir -p ${_destdir}/usr/local/etc/ssl
        install -m 0644 -o root -g wheel -lr /usr/local/share/certs/ca-root-nss.crt ${_destdir}/usr/local/etc/ssl/cert.pem
    fi
}

__customize-base() {
    local _destdir=$1

    __valid-destdir ${_destdir}

    # openssl passwd -1 -stdin
    chroot ${_destdir} chpass -p '$1$t/ql/hHd$NBbpjIdMc8Zg6.omS2XmB/' root

    touch ${_destdir}/firstboot

    mkdir -p ${_destdir}/root/.ssh

    echo-bsdkit-authorized-keys > ${_destdir}/root/.ssh/authorized_keys

    chown -R root:wheel ${_destdir}/root

    # ===

    sed -i '' -e '/^PermitRootLogin/d' ${_destdir}/etc/ssh/sshd_config
    sed -i '' -e '/^UseDNS/d' ${_destdir}/etc/ssh/sshd_config

    cat >> ${_destdir}/etc/ssh/sshd_config << EOF
UseDNS no
PermitRootLogin yes
EOF

    mkdir -p ${_destdir}/etc/rc.conf.d

    __install-resolv-conf ${_destdir}
    __install-ca-root-nss ${_destdir}

    mkdir -p ${_destdir}/usr/local/etc/pkg/repos

    cat > ${_destdir}/usr/local/etc/pkg/repos/FreeBSD.conf << EOF
FreeBSD: {
    enabled: no
}
EOF

    cat > ${_destdir}/usr/local/etc/pkg/repos/bsdkit.conf << EOF
bsdkit: {
    url: "${FREEBSD_PKG_URL}"
}
EOF

    return 0
}

__setup-jail() {
    local _opts _opts_args

    # zparseopts flags:
    # -F: Fail if unrecognized options are found
    # -D: Remove recognized options from positional parameters
    # -E: Stop at first unrecognized option (don't error on unknown options)
    # -K: Keep existing array values if option not present (vs clearing array)
    # -a: Store options in array _opts
    # -A: Store options with arguments in associative array _opts_args
    zparseopts -F -D -E -K -a _opts -A _opts_args -plain

    local _plain
    _plain=$(yes-if ${_opts[(Ie)--plain]})

    local _destdir=$1

    __link-home ${_destdir}

    mkdir -p ${_destdir}/usr/ports

    __customize-base ${_destdir}

    if [ -f /etc/hosts ] && [ ! -f ${_destdir}/etc/hosts ]; then
        install -m 0644 -o root -g wheel /etc/hosts ${_destdir}/etc/hosts
    fi

    if ! is-yes ${_plain}; then
        start-jail ${_destdir}

        {
            ansible-jail-playbook ${BSDKIT_JAIL_NAME}
        } always {
            stop-jail ${_destdir}
        }
    fi

    return 0
}

__make-read-only() {
    local _destdir=$1

    __valid-destdir ${_destdir}

    local _file

    for _file in /entropy /boot/entropy; do
        [ -e ${_file} ] && install -m 0600 -o root -g wheel ${_file} ${_destdir}${_file}
    done

    sed -i '' -e '/^root:/ c\
root:$1$PkLp4/DM$/3D/umXPR0XIb0HsPHByU/:0:0::0:0:System Administrator:/root:/bin/csh' \
        ${_destdir}/etc/master.passwd

    pwd_mkdb -d ${_destdir}/etc ${_destdir}/etc/master.passwd

    touch ${_destdir}/etc/fstab

    # newsyslog -v -C -f ${_destdir}/etc/newsyslog.conf -d ${_destdir}

    uuidgen > ${_destdir}/etc/hostid

    cat > ${_destdir}/etc/ttys << EOF
ttyv0 "/usr/libexec/getty al.Pc" xterm onifexists  secure
ttyv1 "/usr/libexec/getty al.Pc" xterm onifexists  secure
ttyv2 "/usr/libexec/getty al.Pc" xterm onifexists  secure
ttyv3 "/usr/libexec/getty al.Pc" xterm onifexists  secure
ttyu0 "/usr/libexec/getty al.Pc" vt100 onifconsole secure
EOF

    cat > ${_destdir}/etc/rc.conf.local << EOF
background_dhclient="YES"
background_fsck="NO"
cleanvar_enable="NO"
crashinfo_enable="NO"
cron_enable="NO"
defaultroute_delay="10"
entropy_boot_file="NO"
entropy_file="NO"
hostid_enable="NO"
hostname="bsdkit"
ifconfig_DEFAULT="DHCP"
ip6addrctl_enable="NO"
keyrate="fast"
mixer_enable="NO"
moused_nondefault_enable="NO"
newsyslog_enable="YES"
ntpd_enable="YES"
ntpd_sync_on_start="YES"
root_rw_mount="NO"
sendmail_enable="NONE"
sendmail_msp_queue_enable="NO"
sendmail_outbound_enable="NO"
sendmail_submit_enable="NO"
sshd_enable="YES"
syslogd_enable="YES"
tmpmfs="YES"
varmfs="YES"
virecover_enable="NO"
EOF

    sed -i '' -e '/^PermitRootLogin/d' ${_destdir}/etc/ssh/sshd_config
    sed -i '' -e '/^UseDNS/d' ${_destdir}/etc/ssh/sshd_config
    sed -i '' -e '/^GatewayPorts/d' ${_destdir}/etc/ssh/sshd_config
    sed -i '' -e '/^MaxAuthTries/d' ${_destdir}/etc/ssh/sshd_config
    sed -i '' -e '/^leapfile/d' ${_destdir}/etc/ntp.conf

    cat >> ${_destdir}/etc/ssh/sshd_config << EOF
UseDNS no
PermitRootLogin yes
GatewayPorts yes
MaxAuthTries 32
EOF

    cat > ${_destdir}/etc/host.conf << EOF
# Auto-generated from nsswitch.conf
hosts
dns
EOF

    return 0
}

__install-setup-runtime() {
    local _destdir=$1
    local _bsdkit=$2
    local _pkgpath=$3

    __valid-destdir ${_destdir}
    __valid-bsdkit ${_bsdkit}
    __valid-pkgpath ${_pkgpath}

    # Synchronize with 33c82d0f-f01e-4032-b489-3ecdad22ca16
    local _runtime=(
        # required
        devel/git
        security/ca_root_nss
        shells/zsh
        sysutils/pv
        textproc/fzf
        textproc/go-yq
        textproc/jq
        textproc/py-pyaml

        # optional
        archivers/zip
        devel/bsddialog
        devel/gum
        devel/uclcmd
        editors/bvi
        editors/nano
        editors/vim
        ftp/curl
        ftp/lftp
        misc/delay
        misc/gnu-watch
        misc/mbuffer
        misc/mc
        misc/retry
        net/croc
        net/rsync
        net/socat
        sysutils/clone
        sysutils/cpdup
        sysutils/filemon
        sysutils/htop
        sysutils/lsblk
        sysutils/ncdu
        sysutils/renameutils
        sysutils/smenu
        sysutils/spiped
        sysutils/tmux
        sysutils/ts
        textproc/jo

        # uncategorized
        comms/kermit
        lang/python
        net/py-netaddr
        net/rclone
        net/zerotier
        ports-mgmt/pkg
        security/openvpn
        sysutils/ansible
        sysutils/ddrescue
        sysutils/flashrom
	filesystems/exfat
	filesystems/ext2
	filesystems/ntfs
        sysutils/hextools
        sysutils/hfsutils
        sysutils/ipmitool
        sysutils/memtester
        sysutils/smartmontools
        www/go-www
        www/tinyproxy
        # disabled
        # genisoimage
    )

    local _allpkg=${_pkgpath}/All

    local _pkgdir=/usr/ports/packages

    mkdir -p ${_destdir}/${_pkgdir}
    mkdir -p ${_destdir}/dev

    {
        mount -t devfs devfs ${_destdir}/dev
        mount -t nullfs ${_pkgpath} ${_destdir}/${_pkgdir}

        mkdir -p ${_destdir}/usr/local/etc/pkg/repos

        cat > ${_destdir}/usr/local/etc/pkg/repos/FreeBSD.conf << EOF
FreeBSD: {
    enabled: no
}
EOF

        cat > ${_destdir}/usr/local/etc/pkg/repos/bsdkit.conf << EOF
bsdkit: {
    url: "file://${_pkgdir}"
}
EOF

        lockf -k -t ${BSDKIT_PKG_LOCKTIME} ${BSDKIT_PKG_LOCKFILE} pkg -c ${_destdir} install -y ${_runtime}

        if [ -d ${_destdir}/var/cache/pkg ]; then
            lockf -k -t ${BSDKIT_PKG_LOCKTIME} ${BSDKIT_PKG_LOCKFILE} pkg -c ${_destdir} clean -y -a
        fi

        rm -f ${_destdir}/usr/local/etc/pkg/repos/bsdkit.conf
    } always {
        umount -f ${_destdir}/${_pkgdir}
        umount -f ${_destdir}/dev
    }

    rmdir ${_destdir}/${_pkgdir}

    local _master_passwd
    _master_passwd=$(mktemp ${_destdir}/tmp/master.passwd.XXXXXX)

    install -m 0600 ${_destdir}/etc/master.passwd ${_master_passwd}

    sed -i '' -e '/^root/s@/bin/csh@/usr/local/bin/zsh@' ${_master_passwd}

    pwd_mkdb -d ${_destdir}/etc ${_master_passwd}

    rm -f ${_master_passwd}

    install -m 0644 -o root -g wheel ${_bsdkit}/ansible/dotfiles/dot.zshrc ${_destdir}/root/.zshrc

    cat >> ${_destdir}/root/.zshrc << EOF
echo -n "Available disks: "
sysctl -n kern.disks | rs 0 1 | sort | grep -v -E "^cd|^acd" | rs 1 0 | sed -E -e "s/ +/ /g"
echo
EOF

    return 0
}

__install-facts() {
    __check-go-yq

    local _destdir=$1

    if [ ! -d ${_destdir} ]; then
        return 1
    fi

    if [ ! -f ${_destdir}/usr/local/etc/ansible/facts.d/bsdkit.fact ]; then
        install -d -o root -g wheel -m 755 ${_destdir}/usr/local/etc/ansible/facts.d
        /usr/local/bin/yq -o=json ${BSDKIT_SRCDIR}/playbook/bsdkit-defaults.yml > ${_destdir}/usr/local/etc/ansible/facts.d/bsdkit.fact
    fi
}

__echo-runtime-jail-conf() {
    local _destdir=$1

    __valid-destdir ${_destdir}

    cat > ${_jail_conf} << EOF
exec.clean;

mount.devfs;
persist;

sysvsem = new;
sysvshm = new;
sysvmsg = new;

${BSDKIT_JAIL_NAME} {
        allow.raw_sockets;
        allow.sysvipc;

        osrelease = "$(get-osrelease ${_destdir})";
        osreldate = "$(get-osreldate ${_destdir})";

        path = "${_destdir%/}";
        host.hostname = "${BSDKIT_JAIL_NAME}";
        host.domainname = "local";
        ip4.addr = "$(get-inet-address)";
}
EOF
}

start-jail() {
    if [ $# -ne 1 ]; then
        usage "start-jail <destdir>"
    fi

    local _destdir=$1
    __valid-destdir ${_destdir}

    local _jail_conf
    _jail_conf=$(mktemp /tmp/jail.conf.XXXXXX)

    __echo-runtime-jail-conf ${_destdir} > ${_jail_conf}
    jail -f ${_jail_conf} -c ${BSDKIT_JAIL_NAME}
    rm ${_jail_conf}
}

stop-jail() {
    if [ $# -ne 1 ]; then
        usage "stop-jail <destdir>"
    fi

    local _destdir=$1
    __valid-destdir ${_destdir}

    local _jail_conf
    _jail_conf=$(mktemp /tmp/jail.conf.XXXXXX)

    __echo-runtime-jail-conf ${_destdir} > ${_jail_conf}
    jail -f ${_jail_conf} -r ${BSDKIT_JAIL_NAME}
    rm ${_jail_conf}
}

reset-state() {
    jail -R '*'

    mount -p |
        cut -w -f 2 |
        grep /baseroot${BSDKIT_DESTDIR} |
        sort -r |
        xargs umount -f

    swapctl -l | grep "^/" | cut -f 1 -d' ' | xargs swapoff

    # This is dangerous, and we do not do it here:
    #   zpool destroy ${BSDKIT_ZFS_POOL} || :
}

install-mbr-ufs() {
    eval $(__local-options)
    eval $(__parse-options $@)

    local _class=$1
    local _device=$2

    [ -n ${_class} ]
    [ -n ${_device} ]

    __valid-class ${_class}

    mkdir -p ${BSDKIT_DESTDIR}

    __mbr_ufs_partition_${_class} ${BSDKIT_DESTDIR} ${_device}
    __install-release ${FREEBSD_REL_URL} ${BSDKIT_DESTDIR}
    __swap-setup ${BSDKIT_DESTDIR}
    __procfs-setup ${BSDKIT_DESTDIR}
    __fdescfs-setup ${BSDKIT_DESTDIR}
    __finalize-fstab ${BSDKIT_DESTDIR}
    __customize-base ${BSDKIT_DESTDIR}

    return 0
}

install-mbr-ufs-gmirror() {
    eval $(__local-options)
    eval $(__parse-options $@)

    local _class=$1
    local _mirror=$2

    shift 2

    local _devices

    _devices=($*)

    [ -n ${_class} ]
    [ -n ${_mirror} ]
    [ ${#_devices} -gt 0 ]

    __valid-class ${_class}

    kldload -n geom_mirror

    mkdir -p ${BSDKIT_DESTDIR}

    __gmirror-configure ${_mirror} ${_devices}
    __mbr_ufs_partition_${_class} ${BSDKIT_DESTDIR} mirror/${_mirror}
    __install-release ${FREEBSD_REL_URL} ${BSDKIT_DESTDIR}
    __swap-setup ${BSDKIT_DESTDIR}
    __procfs-setup ${BSDKIT_DESTDIR}
    __fdescfs-setup ${BSDKIT_DESTDIR}
    __finalize-fstab ${BSDKIT_DESTDIR}
    __customize-base ${BSDKIT_DESTDIR}

    return 0
}

install-gpt-ufs() {
    eval $(__local-options)
    eval $(__parse-options $@)

    local _class=$1
    local _device=$2

    [ -n ${_class} ]
    [ -n ${_device} ]

    __valid-class ${_class}

    mkdir -p ${BSDKIT_DESTDIR}

    __gpt_ufs_partition_${_class} ${BSDKIT_DESTDIR} ${_device}
    __install-release ${FREEBSD_REL_URL} ${BSDKIT_DESTDIR}
    __swap-setup ${BSDKIT_DESTDIR}
    __procfs-setup ${BSDKIT_DESTDIR}
    __fdescfs-setup ${BSDKIT_DESTDIR}
    __finalize-fstab ${BSDKIT_DESTDIR}
    __customize-base ${BSDKIT_DESTDIR}

    return 0
}

install-zfs() {
    eval $(__local-options)
    eval $(__parse-options $@)

    local _devices

    _devices=($*)

    [ ${#_devices} -gt 0 ]

    kldload -n zfs

    mkdir -p ${BSDKIT_DESTDIR}

    __zfs-create-pool ${BSDKIT_DESTDIR} ${_devices}
    __zfs-create-fs ${BSDKIT_DESTDIR}
    __install-release ${FREEBSD_REL_URL} ${BSDKIT_DESTDIR}
    __zfs-create-zpool-cache ${BSDKIT_DESTDIR}
    __swap-setup ${BSDKIT_DESTDIR}
    __procfs-setup ${BSDKIT_DESTDIR}
    __fdescfs-setup ${BSDKIT_DESTDIR}
    __finalize-fstab ${BSDKIT_DESTDIR}
    __customize-base ${BSDKIT_DESTDIR}

    return 0
}

install-gpt-zfs() {
    eval $(__local-options)
    eval $(__parse-options $@)

    local _devices

    _devices=($*)

    [ ${#_devices} -gt 0 ]

    kldload -n zfs

    mkdir -p ${BSDKIT_DESTDIR}

    __zfs-create-gpt-pool ${BSDKIT_DESTDIR} ${_devices}
    __zfs-create-fs ${BSDKIT_DESTDIR}
    __install-release ${FREEBSD_REL_URL} ${BSDKIT_DESTDIR}
    __zfs-create-zpool-cache ${BSDKIT_DESTDIR}
    __swap-setup ${BSDKIT_DESTDIR}
    __procfs-setup ${BSDKIT_DESTDIR}
    __fdescfs-setup ${BSDKIT_DESTDIR}
    __finalize-fstab ${BSDKIT_DESTDIR}
    __customize-base ${BSDKIT_DESTDIR}

    return 0
}

install-mbr-zfs() {
    eval $(__local-options)
    eval $(__parse-options $@)

    local _devices

    _devices=($*)

    [ ${#_devices} -gt 0 ]

    kldload -n zfs

    mkdir -p ${BSDKIT_DESTDIR}

    __zfs-create-mbr-pool ${BSDKIT_DESTDIR} ${_devices}
    __zfs-create-fs ${BSDKIT_DESTDIR}
    __install-release ${FREEBSD_REL_URL} ${BSDKIT_DESTDIR}
    __zfs-create-zpool-cache ${BSDKIT_DESTDIR}
    __swap-setup ${BSDKIT_DESTDIR}
    __procfs-setup ${BSDKIT_DESTDIR}
    __fdescfs-setup ${BSDKIT_DESTDIR}
    __finalize-fstab ${BSDKIT_DESTDIR}
    __customize-base ${BSDKIT_DESTDIR}

    return 0
}

create-iocage() {
    __check-requirements

    eval $(__local-options)
    eval $(__parse-options $@)

    local _jail_name=$1

    shift

    unset IOCAGE_COLOR

    command -v iocage > /dev/null 2>&1 || error "iocage not found (create-iocage)."
    iocage get -p > /dev/null 2>&1 || error "unable to retrieve iocage mount point (create-iocage)."

    local _iocage_root
    _iocage_root=$(iocage get -p)

    local _iocage_jails
    _iocage_jails=$(zfs get -H -p -o value mountpoint ${_iocage_root}/iocage/jails)

    iocage create -e --name ${_jail_name} "$@"
    local _destdir=${_iocage_jails}/${_jail_name}/root

    [ -d ${_destdir} ] || error "iocage root does not exist (create-iocage)."

    BSDKIT_INSTALL_KERNEL=no BSDKIT_INSTALL_SRC=no __install-release ${FREEBSD_REL_URL} ${_destdir}

    __setup-jail ${_destdir}
}

create-iocage-thin() {
    __check-requirements
    __check-iocage

    eval $(__local-options)
    eval $(__parse-options $@)

    local _jail_name=$1

    shift

    unset IOCAGE_COLOR

    iocage get -p > /dev/null 2>&1 || error "unable to retrieve iocage mount point (create-iocage)."

    local _iocage_root
    _iocage_root=$(iocage get -p)

    local _iocage_jails
    _iocage_jails=$(zfs get -H -p -o value mountpoint ${_iocage_root}/iocage/jails)

    iocage create --name ${_jail_name} $@
    local _destdir=${_iocage_jails}/${_jail_name}/root

    [ -d ${_destdir} ] || error "iocage root does not exist (create-iocage)."

    __setup-jail ${_destdir}
}

is-iocage-jail-path() {
    local _path=$1

    if [ "${_path#/iocage/jails}" != "${_path}" ] && [ "${_path%/root}" != "${_path}" ]; then
        return 0
    fi

    return 1
}

create-iocage-jail() {
    __check-requirements
    __check-iocage

    eval $(__local-options)
    eval $(__parse-options $@)

    local _opts _opts_args

    # zparseopts flags:
    # -F: Fail if unrecognized options are found
    # -D: Remove recognized options from positional parameters
    # -E: Stop at first unrecognized option (don't error on unknown options)
    # -K: Keep existing array values if option not present (vs clearing array)
    # -a: Store options in array _opts
    # -A: Store options with arguments in associative array _opts_args
    zparseopts -F -D -E -K -a _opts -A _opts_args -thin -plain

    local _thin
    _thin=$(yes-if ${_opts[(Ie)--thin]})

    local _plain
    _plain=$(yes-if ${_opts[(Ie)--plain]})

    local _options=()

    if is-yes ${_thin}; then
        _options+="--thin"
    fi

    if is-yes ${_plain}; then
        _options+="--plain"
    fi

    local _jail_name=$1

    shift

    unset IOCAGE_COLOR

    _jail_path=/iocage/jails/${_jail_name}
    _jail_root=${_jail_path}/root

    iocage create -e --name ${_jail_name} ip4=inherit allow_raw_sockets=1

    ${BSDKIT_SCRIPT} create-jail ${=_options[*]} ${_jail_root}

    if is-yes ${_thin}; then
        echo "/ ${_jail_root}/.base nullfs ro" > ${_jail_path}/fstab
    fi

    cp ${BSDKIT_SRCDIR}/ansible/vendor.conf.jail ${_jail_root}/etc/defaults/vendor.conf
}

create-jail() {
    __check-requirements

    eval $(__local-options)
    eval $(__parse-options $@)

    local _opts _opts_args

    # zparseopts flags:
    # -F: Fail if unrecognized options are found
    # -D: Remove recognized options from positional parameters
    # -E: Stop at first unrecognized option (don't error on unknown options)
    # -K: Keep existing array values if option not present (vs clearing array)
    # -a: Store options in array _opts
    # -A: Store options with arguments in associative array _opts_args
    zparseopts -F -D -E -K -a _opts -A _opts_args -thin -plain

    # In this code snippet, `(Ie)` is a parameter expansion flag in the Zsh
    # shell. The `I` flag gives the index of the first (or, with a numeric
    # argument, the n-th) array element matching a given pattern, and the
    # `e` option makes the matching case-insensitive.

    # Therefore, `${_opts[(Ie)--thin]}` is checking for the
    # case-insensitive presence of `--thin` option in the `_opts`
    # associative array. If `--thin` is found in the `_opts` array, the
    # expression will return its index, otherwise, it will return 0.

    local _thin
    _thin=$(yes-if ${_opts[(Ie)--thin]})

    local _plain
    _plain=$(yes-if ${_opts[(Ie)--plain]})

    local _options=()

    if is-yes ${_thin}; then
        _options+="--thin"
    fi

    local _destdir=$1

    __create-jail-destdir ${_destdir}

    BSDKIT_INSTALL_KERNEL=no BSDKIT_INSTALL_SRC=no __install-release ${FREEBSD_REL_URL} ${_destdir} ${=_options[*]}

    install -o root -g wheel -m 644 /etc/resolv.conf ${_destdir}/etc/resolv.conf

    if [ -d /usr/local/etc/pkg/repos ]; then
        install -o root -g wheel -m 755 -d ${_destdir}/usr/local/etc/pkg/repos
        install -o root -g wheel -m 644 /usr/local/etc/pkg/repos/* ${_destdir}/usr/local/etc/pkg/repos/
    fi

    if is-yes ${_plain}; then
        mount -t devfs devfs ${_destdir}/dev

        if is-yes ${_thin}; then
            mount -t nullfs -o ro / ${_destdir}/.base
        fi

        {
            chroot ${_destdir} env ASSUME_ALWAYS_YES=yes pkg bootstrap
        } always {
            umount ${_destdir}/dev

            if is-yes ${_thin}; then
                umount ${_destdir}/.base
            fi
        }
    else
        # __setup-jail will mount devfs

        if is-yes ${_thin}; then
            mount -t nullfs -o ro / ${_destdir}/.base
        fi

        local _options=()

        if is-yes ${_plain}; then
            _options+="--plain"
        fi

        {
            __setup-jail ${=_options[*]} ${_destdir}
        } always {
            if is-yes ${_thin}; then
                umount ${_destdir}/.base
            fi
        }
    fi
}

make-thin-jail() {
    if [ $# -lt 1 ]; then
        usage "make-thin-jail <destdir>"
    fi

    local _destdir=$1

    _destdir=$(realpath ${_destdir})

    [ ${_destdir} != "/" ] || error "invalid destination directory ('/')"
    [ -d ${_destdir} ] || error "directory not found: ${_destdir}"
    [ -d ${_destdir}/etc/rc.d ] || error "invalid destination directory (missing etc/rc.d)"
    [ -d ${_destdir}/.base ] && error "invalid destination directory (already a thin jail)"

    local _directory_list=(
        "bin"
        "boot"
        "lib"
        "libexec"
        "rescue"
        "sbin"
        "usr/bin"
        "usr/include"
        "usr/lib"
        "usr/lib32"
        "usr/libdata"
        "usr/libexec"
        "usr/sbin"
        "usr/share"
    )

    if ! is-yes ${BSDKIT_INSTALL_KERNEL}; then
        _directory_list=(${_directory_list[@]/boot/})
        rm -r -f ${_destdir}/boot
    fi

    if is-yes ${BSDKIT_INSTALL_SRC}; then
        if [ -d ${_destdir}/usr/src ]; then
            _directory_list+="usr/src"
        fi
    else
        rm -r -f ${_destdir}/usr/src
    fi

    if is-yes ${BSDKIT_INSTALL_TESTS}; then
        if [ -d ${_destdir}/usr/tests ]; then
            _directory_list+="usr/tests"
        fi
    else
        rm -r -f ${_destdir}/usr/tests
    fi

    local _directory
    local _prefix

    for _directory in ${_directory_list}; do
        message "Processing ${_directory}"

        if [ -d ${_destdir}/${_directory} ]; then
            rm -r -f ${_destdir}/${_directory} > /dev/null 2>&1 || :
            chflags -R noschg ${_destdir}/${_directory} > /dev/null 2>&1 || :
            rm -r -f ${_destdir}/${_directory}
        fi

        if [ -L ${_destdir}/${_directory} ]; then
            rm -f ${_destdir}/${_directory}
        fi

        _prefix=$(echo ${_directory} | awk -F/ '{ for (i = 1; i <= NF; i++) printf "." }')

        ln -s -f ${_prefix}/.base/${_directory} ${_destdir}/${_directory}
    done

    mkdir -p ${_destdir}/.base
}

make-full-jail() {
    if [ $# -lt 2 ]; then
        usage "make-full-jail <srcdir> <destdir>"
    fi

    local _srcdir=$1
    local _destdir=$2

    _destdir=$(realpath ${_destdir})

    [ ${_destdir} != "/" ] || error "invalid destination directory ('/')"
    [ -d ${_destdir} ] || error "directory not found: ${_destdir}"
    [ -d ${_destdir}/etc/rc.d ] || error "invalid destination directory (missing etc/rc.d)"

    [ -d ${_srcdir} ] || error "directory not found: ${_srcdir}"
    [ -e ${_srcdir}/bin/sh ] || error "invalid source directory (missing /bin/sh)"
    [ -d ${_destdir}/.base ] || error "directory not found: ${_destdir}/.base"

    local _nullfs

    mount -p -t nullfs | cut -w -f 2 | while read _nullfs; do
        if [ ${_nullfs} = ${_destdir}/.base ]; then
            umount -f ${_destdir}/.base
        fi
    done

    local _directory_list=(
        "bin"
        "boot"
        "lib"
        "libexec"
        "rescue"
        "sbin"
        "usr/bin"
        "usr/include"
        "usr/lib"
        "usr/lib32"
        "usr/libdata"
        "usr/libexec"
        "usr/sbin"
        "usr/share"
    )

    if ! is-yes ${BSDKIT_INSTALL_KERNEL}; then
        _directory_list=(${_directory_list[@]/boot/})
        rm -r -f ${_destdir}/boot
    fi

    if ! is-yes ${BSDKIT_INSTALL_KERNEL}; then
        _directory_list=(${_directory_list[@]/boot/})
        rm -r -f ${_destdir}/boot
    fi

    if is-yes ${BSDKIT_INSTALL_SRC}; then
        if [ -d ${_destdir}/usr/src ]; then
            _directory_list+="usr/src"
        fi
    else
        rm -r -f ${_destdir}/usr/src
    fi

    if is-yes ${BSDKIT_INSTALL_TESTS}; then
        if [ -d ${_destdir}/usr/tests ]; then
            _directory_list+="usr/tests"
        fi
    else
        rm -r -f ${_destdir}/usr/tests
    fi

    pushd -q

    local _directory

    for _directory in ${_directory_list}; do
        if [ -L ${_destdir}/${_directory} ] || [ -f ${_destdir}/${_directory} ]; then
            rm -f ${_destdir}/${_directory}
        fi

        mkdir -p ${_destdir}/${_directory}

        message "Processing ${_directory}"

        cd ${_srcdir}/${_directory} && find . | cpio -pdu ${_destdir}/${_directory}
    done

    popd -q

    __run-mtree ${_destdir}

    if is-mount-point ${_destdir}/.base; then
        umount -f ${_destdir}/.base
    fi

    [ -d ${_destdir}/.base ] && rmdir ${_destdir}/.base
}

build-md-root-device() {
    local _option
    local _type
    local _size
    local _reboot

    _type=swap
    _size=2G
    _reboot=NO

    OPTIND=1
    while getopts "mws:r" _option; do
        case ${_option} in
            m)
                _type=malloc
                ;;
            w)
                _type=swap
                ;;
            s)
                _size=${OPTARG}
                ;;
            r)
                _reboot=YES
                ;;
            *) ;;
        esac
    done

    shift $((OPTIND - 1))

    local _md_device
    _md_device=$(mdconfig -a -o reserve -o compress -L "md_root" -t ${_type} -s ${_size})

    BSDKIT_INSTALL_SRC=no BSDKIT_INSTALL_KERNEL=no BSDKIT_PART_SIZE_SWAP=0 BSDKIT_LABEL_ROOT=md_root ${BSDKIT_SCRIPT} install-gpt-ufs $* single ${_md_device}

    rm -f ${BSDKIT_DESTDIR}/etc/rc.conf
    touch ${BSDKIT_DESTDIR}/etc/rc.conf

    sysrc -f ${BSDKIT_DESTDIR}/etc/rc.conf hostname=localhost
    sysrc -f ${BSDKIT_DESTDIR}/etc/rc.conf sshd_enable=YES

    sed -i '' -e '/^PermitRootLogin/d' ${BSDKIT_DESTDIR}/etc/ssh/sshd_config

    if [ -e ~root/.ssh/authorized_keys ]; then
        install -m 0644 ~root/.ssh/authorized_keys ${BSDKIT_DESTDIR}/root/.ssh/authorized_keys
    fi

    cat >> ${BSDKIT_DESTDIR}/etc/ssh/sshd_config << EOF
PermitRootLogin yes
EOF

    mkdir -p ${BSDKIT_DESTDIR}/root/bin/
    install -m 0755 -o root -g wheel ${BSDKIT_SRCDIR}/libexec/bsdkit-rewrite-pool ${BSDKIT_DESTDIR}/root/bin/

    mkdir -p ${BSDKIT_DESTDIR}/dev

    {
        mount -t devfs devfs ${BSDKIT_DESTDIR}/dev

        lockf -k -t ${BSDKIT_PKG_LOCKTIME} ${BSDKIT_PKG_LOCKFILE} pkg -c ${BSDKIT_DESTDIR} install -y \
              net/rsync \
              ports-mgmt/pkg \
              shells/zsh

        if [ -d ${BSDKIT_DESTDIR}/var/cache/pkg ]; then
            lockf -k -t ${BSDKIT_PKG_LOCKTIME} ${BSDKIT_PKG_LOCKFILE} pkg -c ${BSDKIT_DESTDIR} clean -y -a
        fi
    } always {
        umount -f ${BSDKIT_DESTDIR}/dev
    }

    if is-yes ${_reboot}; then
        kenv vfs.root.mountfrom="ufs:/dev/${_md_device}p3"
        reboot -r
    else
        echo "Use \"reboot -r\" after:"
        echo
        echo "    kenv vfs.root.mountfrom=\"ufs:/dev/${_md_device}p3\""
    fi
}

__create-jail-destdir() {
    local _destdir=$1

    if [ -d ${_destdir} ]; then
        [ "$(echo $(find ${_destdir} -type d -empty -maxdepth 0 | wc -l))" = "1" ] || error "${_destdir} already exists (__create-jail-destdir)."
    fi

    local _dirname _basename _parent_fs

    _dirname="$(dirname ${_destdir})"
    _basename="$(basename ${_destdir})"
    _parent_fs=$(zfs list -H -o mounted,mountpoint,name | awk "\$1 == \"yes\" && \$2 == \"${_dirname}\" { print \$3; }")

    local _zfs="NO"

    if [ -n ${_parent_fs} ]; then
        if ! zfs get -H -o value mountpoint ${_parent_fs}/${_basename} > /dev/null 2>&1; then
            ${ZFS_CREATE_CMD} -o compression=$(__zfs-compression) ${_parent_fs}/${_basename}
            _zfs="YES"
        fi
    else
        mkdir -p ${_destdir}
    fi
}

remove-jail() {
    if [ $# -ne 1 ]; then
        usage "remove-jail <jail_name>"
    fi

    local _destdir=$1

    __valid-destdir ${_destdir}

    local _dirname _basename _parent_fs

    _dirname=$(dirname ${_destdir})
    _basename=$(basename ${_destdir})
    _parent_fs=$(zfs list -H -o mounted,mountpoint,name | awk "\$1 == \"yes\" && \$2 == \"${_dirname}\" { print \$3; }")

    local _zfs="NO"

    local _devfs

    mount -p -t devfs | cut -w -f 2 | while read _devfs; do
        if [ ${_devfs} = ${_destdir}/dev ]; then
            umount -f ${_destdir}/dev
        fi
    done

    if [ -n ${_parent_fs} ]; then
        if zfs get -H -o value mountpoint ${_parent_fs}/${_basename} > /dev/null 2>&1; then
            _zfs="YES"
        fi
    fi

    if is-yes ${_zfs}; then
        zfs destroy ${_parent_fs}/${_basename}
    else
        rm -r -f ${_destdir} > /dev/null 2>&1 || :
        chflags -R noschg ${_destdir} > /dev/null 2>&1 || :
        rm -r -f ${_destdir}
    fi
}

build-setup-staging() {
    local _staging=$1
    local _bsdkit=$2
    local _relpath=$3
    local _pkgpath=$4

    _bsdkit=$(realpath ${_bsdkit})
    _relpath=$(realpath ${_relpath})
    _pkgpath=$(realpath ${_pkgpath})

    __valid-bsdkit ${_bsdkit}
    __valid-relpath ${_relpath}
    __valid-pkgpath ${_pkgpath}

    mkdir -p ${_staging}

    _staging=$(realpath ${_staging})

    [ ${_staging} != ${_bsdkit} ]
    [ ${_staging} != ${_relpath} ]
    [ ${_staging} != ${_pkgpath} ]
    [ ${_staging} != "/" ] || exit 1

    local _tmp="/tmp/tmp.$$"
    mkdir -p ${_tmp}
    mount -t tmpfs tmpfs ${_tmp}

    local _destdir=${_tmp}/destdir

    mkdir -p ${_destdir}

    BSDKIT_INSTALL_SRC=no __install-release ${_relpath} ${_destdir}

    rm -f ${_destdir}/boot/kernel/*.symbols(N)

    rm -f ${_destdir}/home

    mkdir -p ${_destdir}/cdrom
    mkdir -p ${_destdir}/img

    touch ${_destdir}/root/.hushlogin

    mkdir ${_destdir}/root/.ssh

    echo-bsdkit-authorized-keys > ${_destdir}/root/.ssh/authorized_keys

    local _mfsroot=${_tmp}/mfsroot

    mkdir -p ${_mfsroot}

    (cd ${_destdir} && pax -r -w -pe rescue ${_mfsroot})

    __make-read-only ${_destdir}

    __install-setup-runtime ${_destdir} ${_bsdkit} ${_pkgpath}

    mkdir ${_mfsroot}/dev
    mkdir ${_mfsroot}/baseroot

    rm -r -f ${_staging}

    mkdir ${_staging}

    _staging=$(realpath ${_staging})

    (cd ${_destdir} && pax -r -w -pe boot ${_staging})

    gzip ${_staging}/boot/kernel/kernel

    install -m 0644 -o root -g wheel ${_bsdkit}/ansible/loader.conf ${_staging}/boot/loader.conf

    cat > ${_staging}/boot/loader.conf.local << EOF
geom_uzip_load="YES"

nullfs_load="YES"
unionfs_load="YES"

hw.mca.enabled="0"
hint.atrtc.0.clock="0"

kern.cam.ada.legacy_aliases="0"
kern.cam.boot_delay="10000"

kern.geom.label.disk_ident.enable="0"

vfs.root_mount_always_wait="1"

mfsroot_load="YES"
mfsroot_type="md_image"
mfsroot_name="/memroot.ufs"

init_path="/rescue/init"
init_shell="/rescue/sh"
init_script="/baseroot.rc"
init_chroot="/baseroot"
EOF

    mkdir -p ${_mfsroot}/etc

    touch ${_mfsroot}/etc/fstab

    install -m 0600 -o root -g wheel ${_destdir}/etc/login.conf ${_mfsroot}/etc

    echo "#!/bin/sh" > ${_mfsroot}/baseroot.rc
    echo "IMG_PART=/dev/gpt/${BSDKIT_IMG_DATA_LABEL}" >> ${_mfsroot}/baseroot.rc

    cat >> ${_mfsroot}/baseroot.rc << "EOF"
set -e -u

trap '/rescue/sh' EXIT

export BASEROOT_IMG=/base.ufs.uzip

export BASEROOT_MP=/baseroot
export CDROM_MP=/cdrom
export IMG_MP=/img
export DEV_MP=/dev
export TMP_MP=/tmp

export ETC_MP=/etc
export ETC_RDWR_MP=/etc.rdwr
export ROOT_MP=/root
export ROOT_RDWR_MP=/root.rdwr

export PATH=/rescue

mount -u -w /

mkdir -p "${BASEROOT_MP}"
mkdir -p "${CDROM_MP}"
mkdir -p "${ETC_RDWR_MP}"
mkdir -p "${ROOT_RDWR_MP}"

if [ -e "${IMG_PART}" ]; then
    mkdir -p "${IMG_MP}"
    fsck -y -t ufs "${IMG_PART}"
    mount -r -t ufs "${IMG_PART}" "${IMG_MP}"
    ISO_MD=$(mdconfig -f "${IMG_MP}"/*.[iI][sS][oO])
    mount -t cd9660 "/dev/${ISO_MD}" "${CDROM_MP}"
else
    for _device in cd0 cd1 acd0 acd1; do
        if [ -e "/dev/${_device}" ]; then
            if mount -t cd9660 "/dev/${_device}" "${CDROM_MP}" > /dev/null 2>&1; then
                break
            fi
        fi
    done
fi

mdmfs -P -F "${CDROM_MP}${BASEROOT_IMG}" -o ro md.uzip "${BASEROOT_MP}"

mount -t devfs devfs "${BASEROOT_MP}${DEV_MP}"

mount -t nullfs -o ro "${CDROM_MP}" "${BASEROOT_MP}${CDROM_MP}"

mdmfs -s 8m  md "${ETC_RDWR_MP}"
mdmfs -s 64m md "${ROOT_RDWR_MP}"

mount -t unionfs "${ETC_RDWR_MP}"  "${BASEROOT_MP}${ETC_MP}"
mount -t unionfs "${ROOT_RDWR_MP}" "${BASEROOT_MP}${ROOT_MP}"

if [ -d "${IMG_MP}" ]; then
    mkdir -p "${BASEROOT_MP}${IMG_MP}"
    mount -t nullfs -o rw "${IMG_MP}" "${BASEROOT_MP}${IMG_MP}"
fi

kenv init_shell="/bin/sh"

if kenv bsdkit_ifconfig > /dev/null 2>&1; then
    bsdkit_ifconfig=$(kenv bsdkit_ifconfig)
    # shellcheck disable=SC2046
    set $(ifconfig -l ether)
    _interface=$1
    if [ -n "${_interface}" ]; then
        echo "ifconfig_${_interface}=\"${bsdkit_ifconfig}\"" >> /baseroot/etc/rc.conf
    fi
fi

if kenv bsdkit_defaultrouter > /dev/null 2>&1; then
    bsdkit_defaultrouter=$(kenv bsdkit_defaultrouter)
    echo "defaultrouter=\"${bsdkit_defaultrouter}\"" >> /baseroot/etc/rc.conf
fi

trap '' EXIT

exit 0
EOF

    install -m 0644 -o root -g wheel ${_bsdkit}/ansible/vendor.conf ${_destdir}/etc/rc.conf

    makefs ${_staging}/memroot.ufs ${_mfsroot}

    chmod -x ${_staging}/memroot.ufs

    rm -f ${_staging}/memroot.ufs.gz

    gzip ${_staging}/memroot.ufs

    makefs ${_staging}/base.ufs ${_destdir}

    mkuzip -o ${_staging}/base.ufs.uzip ${_staging}/base.ufs

    rm -f ${_staging}/base.ufs

    chmod -x ${_staging}/base.ufs.uzip

    while ! umount -f ${_tmp}; do
        message "Waiting for ${_tmp} (tmp)"
        sleep 3
    done

    rmdir ${_tmp}

    return 0
}

build-setup-iso() {
    local _iso=$1
    local _staging=$2
    local _relpath=$3
    local _pkgpath=$4

    if ! command -v mkisofs > /dev/null 2>&1; then
        error "required command missing (mkisofs)."
        # EX_UNAVAILABLE
        exit 69
    fi

    __valid-staging ${_staging}

    if [ ${_relpath} != "none" ]; then
        __valid-relpath ${_relpath}
    fi

    if [ ${_pkgpath} != "none" ]; then
        __valid-pkgpath ${_pkgpath}
    fi

    local _iso_path=${_iso}.fs

    mkdir -p ${_iso_path}

    ln -s -f $(realpath ${_staging}/*) ${_iso_path}

    if [ ${_relpath} != "none" ]; then
        ln -s -f $(realpath ${_relpath}) ${_iso_path}/$(basename ${_relpath})
    fi

    if [ ${_pkgpath} != "none" ]; then
        ln -s -f $(realpath ${_pkgpath}) ${_iso_path}/$(basename ${_pkgpath})
    fi

    # From src/release/amd64/mkisoimages.sh

    dd if=/dev/zero of=${_iso_path}/efiboot.img bs=${BSDKIT_PART_SIZE_EFI} count=1
    _efiboot_md_device=$(mdconfig -f ${_iso_path}/efiboot.img)

    {
        newfs_msdos -L efi -F 16 -c 2 /dev/${_efiboot_md_device}

        _efiboot_root=$(mktemp -d /tmp/XXXXXX)

        mount -t msdosfs /dev/${_efiboot_md_device} ${_efiboot_root}
        {
            mkdir -p ${_efiboot_root}/efi/boot
            cp ${_iso_path}/boot/loader.efi ${_efiboot_root}/efi/boot/bootx64.efi
        } always {
            umount ${_efiboot_root}
        }

        rmdir ${_efiboot_root}
    } always {
        mdconfig -d -u ${_efiboot_md_device}
    }

    mkisofs \
        -rational-rock \
        -follow-links \
        -J \
        -V FreeBSD \
        -publisher olgeni.com \
        -eltorito-boot boot/cdboot \
        -no-emul-boot \
        -eltorito-platform efi \
        -eltorito-boot efiboot.img \
        -no-emul-boot \
        -o ${_iso} \
        ${_iso_path}

    for _entry in $(etdump --format shell ${_iso}); do
        eval ${_entry}
        if [ ${et_platform} = "efi" ]; then
            _esp_start=$(expr ${et_lba} \* 2048)
            _esp_size=$(expr ${et_sectors} \* 512)
            _esp_param=(-p efi::${_esp_size}:${_esp_start})
            break
        fi
    done

    _hybrid_img=$(mktemp /tmp/XXXXXX)

    mkimg \
        -s gpt \
        --capacity $(stat -f %z ${_iso}) \
        -b ${_iso_path}/boot/pmbr \
        ${_esp_param} \
        -p freebsd-boot:=${_iso_path}/boot/isoboot \
        -o ${_hybrid_img}

    dd if=${_hybrid_img} of=${_iso} bs=32k count=1 conv=notrunc

    rm -f ${_hybrid_img}

    rm -r -f ${_iso_path}

    return 0
}

build-setup-img() {
    local _iso_file=$1
    local _img_file=$2

    #
    # EFI partition
    #

    local _efi_dir
    _efi_dir=$(mktemp -d /tmp/efi.XXXXXX)

    tar -x -f ${_iso_file} -C ${_efi_dir} boot/loader_lua.efi boot/loader.efi

    mkdir -p ${_efi_dir}/efi/boot
    install ${_efi_dir}/boot/loader.efi ${_efi_dir}/efi/boot/bootx64.efi

    rm -f ${_efi_dir}/boot/loader_lua.efi
    rm -f ${_efi_dir}/boot/loader.efi
    rmdir ${_efi_dir}/boot

    local _efi_img
    _efi_img=$(mktemp /tmp/ufs.XXXXXX)

    makefs -b 50% ${_efi_img} ${_efi_dir}

    rm -r -f ${_efi_dir}

    #
    # UFS partition
    #

    local _ufs_dir
    _ufs_dir=$(mktemp -d /tmp/staging.XXXXXX)

    tar -x -f ${_iso_file} -C ${_ufs_dir} boot memroot.ufs.gz

    mkdir -p ${_ufs_dir}/etc
    uuidgen > ${_ufs_dir}/etc/hostid

    cp ${_iso_file} ${_ufs_dir}

    local _ufs_img
    _ufs_img=$(mktemp /tmp/ufs.XXXXXX)

    makefs ${_ufs_img} ${_ufs_dir}

    rm -r -f ${_ufs_dir}

    #
    # Image
    #

    rm -f ${_img_file}

    mkimg -v \
          -s gpt \
          -b /boot/pmbr \
          -p efi:=${_efi_img} \
          -p freebsd-boot:=/boot/gptboot \
          -p freebsd-ufs/${BSDKIT_IMG_DATA_LABEL}:=${_ufs_img} \
          -o ${_img_file}

    rm -f ${_efi_img}
    rm -f ${_ufs_img}
}

with-quiet() {
    env \
        ANSIBLE_DISPLAY_OK_HOSTS=false \
        ANSIBLE_DISPLAY_SKIPPED_HOSTS=false \
        ${BSDKIT_SCRIPT} ${(@s/ /)@}
}

with-verbose() {
    env \
        ANSIBLE_DISPLAY_OK_HOSTS=true \
        ANSIBLE_DISPLAY_SKIPPED_HOSTS=true \
        ${BSDKIT_SCRIPT} ${(@s/ /)@}
}

deploy() {
    __check-requirements

    message "Running: $*"

    ${(@s/ /)@}

    ansible-chroot-playbook
}

remote-exec() {
    __check-requirements

    local _remote_address=""
    local _remote_port="22"
    local _option

    OPTIND=1
    while getopts "h:p:" _option; do
        case ${_option} in
            h)
                _remote_address=${OPTARG}
                ;;
            p)
                _remote_port=${OPTARG}
                ;;
            *) ;;
        esac
    done

    shift $((OPTIND - 1))

    [ -n ${_remote_address} ]
    [ -n ${_remote_port} ]

    message "Running: $*"

    local _ansible_root
    _ansible_root=$(mktemp -d /tmp/ansible_root.XXXXX)

    local _ansible_cfg=${_ansible_root}/ansible.cfg
    local _ansible_hosts=${_ansible_root}/ansible_hosts
    local _ansible_yml=${_ansible_root}/ansible.yml
    local _ansible_key=${_ansible_root}/ansible.key

    echo-bsdkit-private-key > ${_ansible_key}
    chmod 600 ${_ansible_key}

    cat > ${_ansible_cfg} << EOF
[defaults]
inventory = ${_ansible_hosts}
host_key_checking = False
action_warnings = False
deprecation_warnings = False
devel_warning = False
inventory_unparsed_warning = False
localhost_warning = False
system_warnings = False
ansible_shell_type = sh

[ssh_connection]
pipelining = True
ssh_args = -o ControlMaster=no -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null
EOF

    cat > ${_ansible_hosts} << EOF
install connection=ssh ansible_shell_type=sh ansible_python_interpreter=/usr/local/bin/python ansible_ssh_host=${_remote_address} ansible_ssh_port=${_remote_port} ansible_ssh_private_key_file=${_ansible_key}
EOF

    cat > ${_ansible_yml} << EOF
---
- hosts: install
  connection: ssh
  user: root
  tasks:
    - name: Install bsdkit
      delegate_to: localhost
      shell: |
        rsync -a --exclude=.git -e "ssh -p ${_remote_port} -i ${_ansible_key}" ${BSDKIT_SRCDIR}/ root@${_remote_address}:/root/bsdkit/

    - name: Run requested bsdkit function
      shell: $(__environment) /root/bsdkit/bsdkit "$@" > /tmp/bsdkit.log 2>&1

- hosts: install
  connection: ssh
  user: root
  tasks:
    - name: Remove bsdkit
      file: path=/root/bsdkit state=absent
EOF

    # SSH_AUTH_SOCK="" was removed to allow sysprep to run
    eval env \
         ANSIBLE_CONFIG=${_ansible_cfg} \
         $(__environment) \
         ansible-playbook ${_ansible_yml}

    rm -r ${_ansible_root}
}

ansible-local-playbook() {
    __check-requirements

    __install-facts /

    ansible-playbook \
        --inventory localhost, \
        --connection local \
        -e ansible_python_interpreter=${ANSIBLE_PYTHON_INTERPRETER} \
        ${BSDKIT_SRCDIR}/playbook/playbook.yml $*
}

ansible-chroot-playbook() {
    __check-requirements

    local _ansible_root
    _ansible_root=$(mktemp -d /tmp/ansible_root.XXXXX)

    local _ansible_cfg=${_ansible_root}/ansible.cfg
    local _ansible_hosts=${_ansible_root}/ansible_hosts

    cat > ${_ansible_cfg} << EOF
[defaults]
inventory = ${_ansible_hosts}
action_warnings = False
deprecation_warnings = False
devel_warning = False
inventory_unparsed_warning = False
localhost_warning = False
system_warnings = False
ansible_shell_type = sh
EOF

    cat > ${_ansible_hosts} << EOF
${BSDKIT_DESTDIR} ansible_connection=community.general.chroot ansible_shell_type=sh ansible_python_interpreter=/usr/local/bin/python
EOF

    _bsdkit_interface="$(ifconfig -l -u ether | awk '{ print $1 }')"
    _bsdkit_ifconfig="$(kenv bsdkit_ifconfig 2> /dev/null || :)"
    _bsdkit_defaultrouter="$(kenv bsdkit_defaultrouter 2> /dev/null || :)"

    __install-facts ${BSDKIT_DESTDIR}

    mount -t devfs devfs ${BSDKIT_DESTDIR}/dev

    {
        eval env \
             ANSIBLE_CONFIG=${_ansible_cfg} \
             SSH_AUTH_SOCK="" \
             $(__environment) \
             BSDKIT_INTERFACE=${_bsdkit_interface} \
             BSDKIT_IFCONFIG=${_bsdkit_ifconfig} \
             BSDKIT_DEFAULTROUTER=${_bsdkit_defaultrouter} \
             BSDKIT_CHROOT=1 \
             ansible-playbook ${BSDKIT_SRCDIR}/playbook/playbook.yml $* || :
    } always {
        umount -f ${BSDKIT_DESTDIR}/dev
        rm -r ${_ansible_root}
    }
}

ansible-jail-playbook() {
    __check-requirements

    local _jail_name=$1

    shift

    local _ansible_root
    _ansible_root=$(mktemp -d /tmp/ansible_root.XXXXX)

    local _ansible_cfg=${_ansible_root}/ansible.cfg
    local _ansible_hosts=${_ansible_root}/ansible_hosts

    cat > ${_ansible_cfg} << EOF
[defaults]
inventory = ${_ansible_hosts}
host_key_checking = False
action_warnings = False
deprecation_warnings = False
devel_warning = False
inventory_unparsed_warning = False
localhost_warning = False
system_warnings = False
ansible_shell_type = sh

[ssh_connection]
pipelining = True
ssh_args = -o ControlMaster=no -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null
EOF

    cat > ${_ansible_hosts} << EOF
${_jail_name} ansible_connection=jail ansible_shell_type=sh ansible_python_interpreter=${ANSIBLE_PYTHON_INTERPRETER}
EOF

    _bsdkit_interface="$(ifconfig -l -u ether | awk '{ print $1 }')"
    _bsdkit_ifconfig="$(kenv bsdkit_ifconfig 2> /dev/null || :)"
    _bsdkit_defaultrouter="$(kenv bsdkit_defaultrouter 2> /dev/null || :)"

    _jail_root=$(jls -j ${_jail_name} path)

    __install-facts ${_jail_root}

    eval env \
         ANSIBLE_CONFIG=${_ansible_cfg} \
         SSH_AUTH_SOCK="" \
         $(__environment) \
         BSDKIT_INTERFACE=${_bsdkit_interface} \
         BSDKIT_IFCONFIG=${_bsdkit_ifconfig} \
         BSDKIT_DEFAULTROUTER=${_bsdkit_defaultrouter} \
         ansible-playbook ${BSDKIT_SRCDIR}/playbook/playbook.yml $* || :

    rm -r ${_ansible_root}
}

__build-facts() {
    local _destdir=${1:-""}

    __check-go-yq

    install -d -o root -g wheel -m 755 ${_destdir}/usr/local/etc/ansible/facts.d

    [ -f ${_destdir}${BSDKIT_CONFIG} ] || touch ${_destdir}${BSDKIT_CONFIG}

    /usr/local/bin/yq -o=json ea '. as $item ireduce ({}; . * $item)' \
       ${BSDKIT_SRCDIR}/playbook/bsdkit-defaults.yml \
       ${_destdir}${BSDKIT_CONFIG} \
       > ${_destdir}/usr/local/etc/ansible/facts.d/bsdkit.fact
}

__find-jail() {
    local _jail_name=$1

    if ! jls -j ${_jail_name} name > /dev/null 2>&1; then
        _jail_name="ioc-${_jail_name}"
    fi

    if ! jls -j ${_jail_name} name > /dev/null 2>&1; then
        error "Jail ${_jail_name} does not exist"
    fi

    echo ${_jail_name}
}

__ansible-pre-cleanup() {
    local _path="/usr/local/lib/python*/site-packages/"

    for _dir in ${_path}; do
        if [ -d "${_dir}" ]; then
            find "${_dir}" -type d -name '__pycache__' | while read _directory; do
                for _file in ${(N)"${_directory}"/*.pyc}; do
                    if ! pkg which "${_file}" > /dev/null 2>&1; then
                        rm -f "${_file}"
                        message "Removed file ${_file}"
                    fi
                done

                if [ "$(find "${_directory}" -type f | wc -l)" = "0" ]; then
                    rmdir "${_directory}"
                    message "Removed directory ${_directory}"
                fi
            done
        fi
    done
}

configure() {
    __ansible-pre-cleanup
    __build-facts

    ansible-local-playbook -t configure
}

configure-jail() {
    if [ $# -lt 1 ]; then
        usage "configure-jail <jail_name> [options]"
    fi

    __check-go-yq

    local _jail_name=$(__find-jail $1)
    local _jail_root=$(jls -j ${_jail_name} path)

    __build-facts ${_jail_root}

    ansible-jail-playbook ${_jail_name} -t configure
}

monit-setup() {
    __build-facts

    ansible-local-playbook -t monit
}

monit-setup-jail() {
    if [ $# -lt 1 ]; then
        usage "monit-setup-jail <jail_name>"
    fi

    __check-go-yq

    local _jail_name=$(__find-jail $1)
    local _jail_root=$(jls -j ${_jail_name} path)

    __build-facts ${_jail_root}

    ansible-jail-playbook ${_jail_name} -t monit
}

configure-crontab() {
    __build-facts

    ansible-local-playbook -t crontab
}

configure-crontab-jail() {
    if [ $# -lt 1 ]; then
        usage "configure-crontab-jail <jail_name>"
    fi

    __check-go-yq

    local _jail_name=$(__find-jail $1)
    local _jail_root=$(jls -j ${_jail_name} path)

    __build-facts ${_jail_root}

    ansible-jail-playbook ${_jail_name} -t crontab
}

status() {
    if ! command -v monit > /dev/null 2>&1; then
        error "monit is not installed"
    fi

    monit -B summary
}

upgrade-os() {
    ${BSDKIT_SRCDIR}/libexec/bsdkit-upgrade-os "$@"
}

delete-old-files() {
    ${BSDKIT_SRCDIR}/libexec/bsdkit-delete-old-files "$@"
}

upgrade-etc() {
    ${BSDKIT_SRCDIR}/libexec/bsdkit-upgrade-etc "$@"
}

upgrade-loader() {
    ${BSDKIT_SRCDIR}/libexec/bsdkit-upgrade-loader "$@"
}

upgrade-postgresql() {
    ${BSDKIT_SRCDIR}/libexec/bsdkit-upgrade-postgresql "$@"
}

upgrade-python() {
    ${BSDKIT_SRCDIR}/libexec/bsdkit-upgrade-python "$@"
}

pkg-diff() {
    ${BSDKIT_SRCDIR}/libexec/bsdkit-pkg-diff "$@"
}

rewrite-pool() {
    ${BSDKIT_SRCDIR}/libexec/bsdkit-rewrite-pool "$@"
}

rewrite-filesystem() {
    ${BSDKIT_SRCDIR}/libexec/bsdkit-rewrite-filesystem "$@"
}

zfs-migrate-postgresql() {
    ${BSDKIT_PATH}/libexec/bsdkit-zfs-migrate-postgresql "$@"
}

zfs-migrate-mysql() {
    ${BSDKIT_PATH}/libexec/bsdkit-zfs-migrate-mysql "$@"
}

apply-mtree() {
    ${BSDKIT_SRCDIR}/libexec/bsdkit-apply-mtree "$@"
}

build() {
    ${BSDKIT_SRCDIR}/libexec/bsdkit-build "$@"
}

relocate-venv() {
    ${BSDKIT_SRCDIR}/libexec/bsdkit-relocate-venv "$@"
}

provision() {
    if platform-is-digitalocean; then
        ansible-local-playbook -t provision_digitalocean
    elif platform-is-aws; then
        ansible-local-playbook -t provision_aws
    else
        error "Unsupported provisioning platform"
    fi
}

sysprep() {
    __check-requirements

    local OPTIONS=""

    while getopts ":t:" opt; do
        case ${opt} in
            t)
                case ${OPTARG} in
                    aws|digitalocean)
                    ;;
                    *)
                        error "Invalid platform: ${OPTARG}"
                        ;;
                esac

                OPTIONS="${OPTIONS} -e sysprep_target=${OPTARG}"
                ;;
            *)
                error "Invalid option: ${opt}"
                ;;
        esac
    done

    ansible-playbook \
        --inventory localhost, \
        --connection local \
        -e ansible_python_interpreter=${ANSIBLE_PYTHON_INTERPRETER} \
        ${=OPTIONS} \
        ${BSDKIT_SRCDIR}/playbook/sysprep.yml
}

enable-swap-device() {
    if platform-is-aws; then
        __enable-swap-device-aws
    fi
}

__enable-swap-device-aws() {
    if [ -z "${BSDKIT_SWAP_DEVICE_SIZE}" ] || [ "${BSDKIT_SWAP_DEVICE_SIZE}" -eq 0 ]; then
        error "BSDKIT_SWAP_DEVICE_SIZE is not set"
    fi

    if grep -q '^/dev/gpt/swap' /etc/fstab; then
        message "Swap already configured"
    elif [ -e /dev/gpt/swap ]; then
        message "Configuring existing swap device"
        echo "/dev/gpt/swap none swap sw 0 0" >> /etc/fstab
        reformat-fstab /etc/fstab
    else
        for _disk in $(sysctl -n kern.disks); do
            if gpart list ${_disk} > /dev/null 2>&1; then
                message "Skipping ${_disk}: already partitioned"
                continue
            fi

            _mediasize=$(geom disk list ${_disk} | awk '$1 == "Mediasize:" { print $2 }')
            _mediasize=$(expr ${_mediasize} / 1073741824)

            if [ ${_mediasize} -gt ${BSDKIT_SWAP_DEVICE_SIZE} ]; then
                continue
            fi

            message "Creating GPT partition table on ${_disk}"
            gpart create -s gpt ${_disk}
            message "Creating swap partition on ${_disk}"
            gpart add -a 4k -i 1 -t freebsd-swap -l swap ${_disk}
            message "Enabling swap on ${_disk}"
            swapon /dev/gpt/swap
            echo "/dev/gpt/swap none swap sw 0 0" >> /etc/fstab

            reformat-fstab /etc/fstab

            break
        done
    fi
}

update() {
    [ -d ${BSDKIT_SRCDIR}/.git ] || error "local git repository not found"

    cd ${BSDKIT_SRCDIR}

    local _current_hash=$(git rev-parse --short HEAD)

    git fetch --no-tags || error "git fetch failed."

    git tag --list | xargs git tag -d > /dev/null 2>&1

    local _remote_hash=$(git rev-parse --short origin/master)

    if [ ${_current_hash} = ${_remote_hash} ]; then
        message "Already up-to-date."
        return 0
    fi

    git reset --hard ${_remote_hash} || error "git reset failed."

    if [ -t 1 ]; then
        GIT_PAGER=/bin/cat git log --pretty=oneline --abbrev-commit --graph --decorate ${_current_hash}..${_remote_hash}
    fi
}

echo-jail-conf() {
    if [ $# -ne 1 ]; then
        usage "echo-jail-conf <destdir>"
    fi

    local _destdir=$1

    __valid-destdir ${_destdir}

    local _jail_name

    _jail_name=$(basename ${_destdir})
    _jail_root=$(dirname ${_destdir})

    cat << EOF
exec.start = "/bin/sh /etc/rc";
exec.stop = "/bin/sh /etc/rc.shutdown";
exec.clean;

mount.devfs;
persist;

sysvsem = new;
sysvshm = new;
sysvmsg = new;

${_jail_name} {
        allow.raw_sockets;
        allow.sysvipc;

        osrelease = "$(get-osrelease ${_destdir})";
        osreldate = "$(get-osreldate ${_destdir})";

        path = "${_destdir%/}";
        host.hostname = "\${name}";
        host.domainname = "local";
        interface = "$(get-gateway-interface)";
        # ip4.addr = "";
        # mount.fstab = "${_jail_root%/}/\${name}.fstab";
}
EOF
}

shell() {
    local _private_key
    _private_key=$(mktemp /tmp/key.XXXXXX)

    ssh -v -i ${_private_key} "$@" || :

    rm -f ${_private_key}
}

echo-bsdkit-private-key() {
    cat ${BSDKIT_SRCDIR}/keypairs/id_rsa
}

echo-bsdkit-authorized-keys() {
    cat ${BSDKIT_SRCDIR}/keypairs/*.pub
}

rebuild-zpool-cache() {
    zpool set cachefile=/etc/zfs/zpool.cache $(get-boot-pool)
}

purge-libdir() {
    if [ $# -ne 1 ]; then
        usage "purge-libdir <directory>"
    fi

    local _directory=$1

    for _item in ${_directory}/*(/N); do
        case $(basename ${_item}) in
            site_*) ;;

            vendor_*) ;;

            *)
                if [ $(find ${_item} -type f | wc -l) -eq 1 ]; then
                    case $(find ${_item} -type f) in
                        */mandoc.db)
                            message "Removing ${_item} (mandoc)"
                            rm -r -f ${_item}
                            ;;
                        *) ;;
                    esac
                elif [ $(find ${_item} -type f | wc -l) -eq 0 ]; then
                    message "Removing ${_item} (empty)"
                    rm -r -f ${_item}
                fi
                ;;
        esac
    done
}

purge-local-libdirs() {
    local _ruby_version=$(get-ruby-version)
    local _perl_version=$(get-perl-version)

    for _ruby_libdir in ${RUBY_LIBDIR_LIST[@]}; do
        purge-libdir ${_ruby_libdir}
    done

    for _perl_libdir in ${PERL_LIBDIR_LIST[@]}; do
        purge-libdir ${_perl_libdir}
    done

    if [ -n "${_ruby_version}" ]; then
        for _ruby_libdir in ${RUBY_LIBDIR_LIST[@]}; do
            if ! [ -d ${_ruby_libdir}/${_ruby_version} ]; then
                message "Creating ${_ruby_libdir}/${_ruby_version}"
                mkdir -p ${_ruby_libdir}/${_ruby_version}
            fi
        done
    fi

    if [ -n "${_perl_version}" ]; then
        for _perl_libdir in ${PERL_LIBDIR_LIST[@]}; do
            if ! [ -d ${_perl_libdir}/${_perl_version} ]; then
                message "Creating ${_perl_libdir}/${_perl_version}"
                mkdir -p ${_perl_libdir}/${_perl_version}
            fi
        done
    fi
}

purge-python-libdir() {
    for _lib_directory in /usr/local/lib/python*(N/); do
        message "Checking directory: ${_lib_directory}"

        for _file in $(find ${_lib_directory} -type f -name '*.pkgsave'); do
            message "Removing file: ${_file}"
            rm -f ${_file}
        done

        for _site_directory in ${_lib_directory}/site-packages(N/); do
            find ${_site_directory} -name '.pkgtemp.*' -print0 | xargs -0 rm -r -f

            for _pycache in $(find ${_site_directory} -type d -name '__pycache__'); do
                for _file in ${_pycache}/*.pyc(N); do
                    _dirname=$(realpath $(dirname ${_file})/..)
                    _module=$(basename "${_file}" | cut -d '.' -f 1)

                    if ! [ -f ${_dirname}/${_module}.py ]; then
                        warning "Removing: ${_file}"
                        rm -f ${_file}
                    fi
                done
            done
        done

        find -d ${_lib_directory} -type d -empty -delete
    done
}

purge-pkg-tempfiles() {
    if [ $# -ne 1 ]; then
        usage "purge-pkg-tempfiles <path>"
    fi

    local _path=$1

    find ${_path} -name '.pkgtemp.*' -delete
}

purge-pkg-tempfiles-interactive() {
    if [ $# -ne 1 ]; then
        usage "purge-pkg-tempfiles-interactive <path>"
    fi

    local _path=$1

    find ${_path} -print0 \
        | awk 'BEGIN { RS="\\0" } $0 ~ /\.pkgtemp\.[^\/]*$/ { print $0 }' \
        | fzf -e -m --print0 \
        | xargs -0 rm -r -v
}

check-pkg-tempfiles() {
    if [ $# -ne 1 ]; then
        usage "check-pkg-tempfiles <path>"
    fi

    local _path=$1

    if ! find ${_path} -print0 \
            | awk 'BEGIN { RS="\\0"; exit_code = 0; } $0 ~ /\.pkgtemp\.[^\/]*$/ { exit_code = 1; } END { exit exit_code; }'; then
        error "check-pkg-tempfiles: found temporary files."
    fi
}

purge-be() {
    bectl list -H \
        | awk '$2 != "NR" && $2 != "R" && $2 != "N" { print $1 }' \
        | while read _bootenv; do
        message "Destroying boot environment: ${_bootenv}"
        if ! bectl destroy -Fo ${_bootenv} 2> /dev/null; then
            message "Destroying boot environment: ${_bootenv} (without origin)"
            if ! bectl destroy -F ${_bootenv}; then
                warning "Failed to destroy boot environment: ${_bootenv}"
            fi
        fi
    done
}

purge-distdir() {
    if __valid-freebsd-distdir "${BSDKIT_FREEBSD_DISTDIR}"; then
        rm -rf ${BSDKIT_FREEBSD_DISTDIR}
    fi
}

start-local() {
    local _service_list=("${(@f)$(service -e | grep "^/usr/local/etc/rc.d/" | sed -e "s@^/usr/local/etc/rc.d/@@g")}")

    for _blacklisted_service in "${SERVICE_RESTART_BLACKLIST[@]}"; do
        if [ -e "/usr/local/etc/rc.d/${_blacklisted_service}" ]; then
            message "Skipping service: ${_blacklisted_service}"
            _service_list=(${_service_list[@]/$_blacklisted_service})
        fi
    done

    # Remove monit from the service list to start it last
    local _monit_service=""

    if [[ "${_service_list[@]}" =~ "monit" ]]; then
        _service_list=(${_service_list[@]/monit})
        _monit_service="monit"
    fi

    local _service

    # Start other services
    for _service in "${_service_list[@]}"; do
        message "Starting service: ${_service}"
        service ${_service} start || :
    done

    # Start runit services
    if [ -d /var/service ]; then
        for _service in /var/service/*(N); do
            _service_name=$(basename ${_service})
            message "Starting runit service: ${_service_name}"
            sv start ${_service_name} || :
        done
    fi

    # Start monit last if it exists
    if [ -n "${_monit_service}" ]; then
        message "Starting service: ${_monit_service}"
        service ${_monit_service} start || :
    fi
}

stop-local() {
    local _service_list=("${(@f)$(service -e | grep "^/usr/local/etc/rc.d/" | sed -e "s@^/usr/local/etc/rc.d/@@g")}")

    for _blacklisted_service in "${SERVICE_RESTART_BLACKLIST[@]}"; do
        if [ -e "/usr/local/etc/rc.d/${_blacklisted_service}" ]; then
            message "Skipping service: ${_blacklisted_service}"
            _service_list=(${_service_list[@]/$_blacklisted_service})
        fi
    done

    # Remove monit from the service list to stop it first
    local _monit_service=""

    if [[ "${_service_list[@]}" =~ "monit" ]]; then
        _service_list=(${_service_list[@]/monit})
        _monit_service="monit"
    fi

    local _service

    # Stop monit first if it exists
    if [ -n "${_monit_service}" ]; then
        message "Stopping service: ${_monit_service}"
        service ${_monit_service} stop || :
    fi

    # Stop runit services
    if [ -d /var/service ]; then
        for _service in /var/service/*(N); do
            _service_name=$(basename ${_service})
            message "Stopping runit service: ${_service_name}"
            sv stop ${_service_name} || :
        done
    fi

    # Stop other services
    for _service in "${_service_list[@]}"; do
        message "Stopping service: ${_service}"
        service ${_service} stop || :
    done
}

restart-local() {
    local _service_list=("${(@f)$(service -e | grep "^/usr/local/etc/rc.d/" | sed -e "s@^/usr/local/etc/rc.d/@@g")}")

    for _blacklisted_service in "${SERVICE_RESTART_BLACKLIST[@]}"; do
        if [ -e "/usr/local/etc/rc.d/${_blacklisted_service}" ]; then
            message "Skipping service: ${_blacklisted_service}"
            _service_list=(${_service_list[@]/$_blacklisted_service})
        fi
    done

    # Remove monit from the service list to restart it last
    local _monit_service=""

    if [[ "${_service_list[@]}" =~ "monit" ]]; then
        _service_list=(${_service_list[@]/monit})
        _monit_service="monit"
    fi

    local _service

    # Stop monit first if it exists
    if [ -n "${_monit_service}" ]; then
        message "Stopping service: ${_monit_service}"
        service ${_monit_service} stop || :
    fi

    # Restart other services
    for _service in "${_service_list[@]}"; do
        message "Restarting service: ${_service}"
        service ${_service} restart || :
    done

    # Restart runit services
    if [ -d /var/service ]; then
        for _service in /var/service/*(N); do
            _service_name=$(basename ${_service})
            message "Restarting runit service: ${_service_name}"
            sv restart ${_service_name} || :
        done
    fi

    # Start monit last if it exists
    if [ -n "${_monit_service}" ]; then
        message "Starting service: ${_monit_service}"
        service ${_monit_service} start || :
    fi
}

destroy-zfs-snapshots() {
    if ! command -v fzf > /dev/null 2>&1; then
        error "required command missing (fzf)"
        return 69
    fi

    local _snapshot

    zfs list -H -o name -t snap \
        | awk -F@ '{ print $2 "|" $0 }' \
        | sort --reverse \
        | column -t -s\| \
        | fzf --exact --multi --no-sort --height=50% --print0 \
        | while IFS=$'\0' read -r -d '' _snapshot; do

        zfs destroy -v $(echo ${_snapshot} | cut -w -f2-64)
    done
}

update-zfs-compression() {
    _zfs_compression_algorithm=${1:-${ZFS_COMPRESSION_ALGORITHM}}

    zfs get -H -o value,name -s local compression \
        | awk "\$1 != \"off\" && \$1 != \"${_zfs_compression_algorithm}\" { print \$2 }" \
        | while IFS= read -r _dataset; do

        message "Updating compression for ${_dataset} to ${_zfs_compression_algorithm}"
        zfs set compression=${_zfs_compression_algorithm} ${_dataset}
    done
}

__config-merge() {
    __check-go-yq

    local _file=$1

    if [ ! -e ${_file} ]; then
        error "config_merge: ${_file} does not exists"
    fi

    /usr/local/bin/yq ea '. as $item ireduce ({}; . * $item)' \
       ${BSDKIT_SRCDIR}/playbook/bsdkit-defaults.yml \
       ${BSDKIT_CONFIG} \
       > ${_tmpfile}
}

__config-upgrade-key() {
    if [ $# -lt 2 ]; then
        error "config_update_key: missing arguments"
    fi

    local _old_key=$1
    local _new_key=$2

    local _value
    _value=$(config-get ${_old_key})

    if [ $? -ne 0 ]; then
        error "Failed to get the value of ${_old_key}"
    fi

    if [ "${_value}" != "null" ]; then
        message "Upgrading ${_old_key} to ${_new_key}"
        config-set ${_new_key} ${_value}

        if [ $? -ne 0 ]; then
            error "Failed to set the value of ${_new_key}"
        fi

        config-del ${_old_key}

        if [ $? -ne 0 ]; then
            error "Failed to delete the key ${_old_key}"
        fi
    fi
}

config-set() {
    if [ $# -lt 2 ]; then
        usage "config-set <key> <value>"
    fi

    local _key=$1
    local _value=$2

    yaml-set ${BSDKIT_CONFIG} ${_key} ${_value}
}

config-get() {
    if [ $# -lt 1 ]; then
        usage "config-get <key>"
    fi

    [ -f ${BSDKIT_CONFIG} ] || touch ${BSDKIT_CONFIG}

    local _key=$1

    local _tmpfile
    _tmpfile=$(mktemp)

    __config-merge ${_tmpfile}

    yaml-get ${_tmpfile} ${_key}

    rm -f ${_tmpfile}
}

config-del() {
    if [ $# -lt 1 ]; then
        usage "config-del <key>"
    fi

    [ -f ${BSDKIT_CONFIG} ] || touch ${BSDKIT_CONFIG}

    local _key=$1

    yaml-del ${BSDKIT_CONFIG} ${_key}
}

config-keys() {
    __check-py-pyaml

    [ -f ${BSDKIT_CONFIG} ] || touch ${BSDKIT_CONFIG}

    local _tmpfile
    _tmpfile=$(mktemp)

    __config-merge ${_tmpfile}

    yaml-list-keys ${_tmpfile}

    rm -f ${_tmpfile}
}

config-list() {
    __check-py-pyaml

    [ -f ${BSDKIT_CONFIG} ] || touch ${BSDKIT_CONFIG}

    local _tmpfile
    _tmpfile=$(mktemp)

    __config-merge ${_tmpfile}

    yaml-list-items ${_tmpfile}

    rm -f ${_tmpfile}
}

config-upgrade() {
    __config-upgrade-key "update_dns" "enable_update_dns"
    __config-upgrade-key "console_syslog" "enable_console_syslog"
}

if [ $# -gt 0 ]; then
    ${(@s/ /)@}
fi

# References:
#   https://wiki.freebsd.org/AndriyGapon/AvgLiveCD
#   https://wiki.freebsd.org/RootOnZFS/ZFSBootPartition

# Local Variables:
# mode: sh
# sh-indentation: 4
# sh-basic-offset: 4
# End:
