#!/bin/sh

set -e -u

error() {
    echo "bsdkit: $@"
    exit 1
}

is_yes() {
    case $1 in
        [Yy][Ee][Ss])
            return 0
            ;;
        [Nn][Oo])
            return 1
            ;;
        *)
            return 2
            ;;
    esac
}

is_efi() {
    [ "$(sysctl -n machdep.bootmethod)" = "UEFI" ]
}

: ${INSTALL_JAIL:="no"}
: ${INSTALL_KERNEL:="yes"}
: ${INSTALL_SRC:="yes"}
: ${INSTALL_DEBUG:="no"}
: ${INSTALL_TESTS:="no"}

: ${ZFS_POOL:="rpool"}
: ${PROCFS_ENABLE:="yes"}
: ${FDESCFS_ENABLE:="yes"}
: ${DESTDIR:="/mnt"}
: ${JAIL_ROOT:="/jails"}
: ${JAIL_NAME:="bsdkit"}
: ${SSH_PUBLIC_KEY:=""}

: ${PART_SIZE_BOOT:="512K"}
: ${PART_SIZE_EFI:="8M"}
: ${PART_SIZE_ROOT:="2G"}
: ${PART_SIZE_SWAP:="4G"}
: ${PART_SIZE_TMP:="16M"}
: ${PART_SIZE_VAR:="6G"}

: ${LABEL_BOOT:="boot"}
: ${LABEL_EFI:="efiboot"}
: ${LABEL_ROOT:="root"}
: ${LABEL_SWAP:="swap"}
: ${LABEL_TMP:="tmp"}
: ${LABEL_USR:="usr"}
: ${LABEL_VAR:="var"}

: ${BSDKIT_ROOT_URL:=https://olgeni.olgeni.com/FreeBSD}
: ${BSDKIT_VERSION:=12.1}
: ${BSDKIT_ARCH:=amd64}
: ${BSDKIT_TREE:=default}
: ${BSDKIT_PKGSET:=nox11}

: ${PV_UPDATE_DELAY:="0.1"}
: ${JAIL_PROXY:=""}

if which -s pv 2>/dev/null; then
    CAT_CMD="pv -i ${PV_UPDATE_DELAY}"
else
    CAT_CMD=/bin/cat
fi

if [ -z "${PART_SIZE_SWAP}" ]; then
    PART_SIZE_SWAP=0
fi

if [ -z "${SSH_PUBLIC_KEY}" -a -e ~/.ssh/id_rsa.pub ]; then
    SSH_PUBLIC_KEY="$(cat ~/.ssh/id_rsa.pub)"
fi

: ${IMG_DATA_LABEL:=2e158b17-5e10-11e5-ac21-080027af0e2a}

: ${PKG_LOCKFILE:="/tmp/pkg.lock"}
: ${PKG_LOCKTIME:=120}

environment() {
    echo INSTALL_JAIL=\"${INSTALL_JAIL}\" \
        INSTALL_KERNEL=\"${INSTALL_KERNEL}\" \
        INSTALL_SRC=\"${INSTALL_SRC}\" \
        INSTALL_DEBUG=\"${INSTALL_DEBUG}\" \
        INSTALL_TESTS=\"${INSTALL_TESTS}\" \
        ZFS_POOL=\"${ZFS_POOL}\" \
        PROCFS_ENABLE=\"${PROCFS_ENABLE}\" \
        FDESCFS_ENABLE=\"${FDESCFS_ENABLE}\" \
        DESTDIR=\"${DESTDIR}\" \
        JAIL_ROOT=\"${JAIL_ROOT}\" \
        JAIL_NAME=\"${JAIL_NAME}\" \
        SSH_PUBLIC_KEY=\"${SSH_PUBLIC_KEY}\" \
        PART_SIZE_EFI=\"${PART_SIZE_EFI}\" \
        PART_SIZE_ROOT=\"${PART_SIZE_ROOT}\" \
        PART_SIZE_SWAP=\"${PART_SIZE_SWAP}\" \
        PART_SIZE_TMP=\"${PART_SIZE_TMP}\" \
        PART_SIZE_VAR=\"${PART_SIZE_VAR}\" \
        LABEL_BOOT=\"${LABEL_BOOT}\" \
        LABEL_EFI=\"${LABEL_EFI}\" \
        LABEL_ROOT=\"${LABEL_ROOT}\" \
        LABEL_SWAP=\"${LABEL_SWAP}\" \
        LABEL_TMP=\"${LABEL_TMP}\" \
        LABEL_USR=\"${LABEL_USR}\" \
        LABEL_VAR=\"${LABEL_VAR}\" \
        BSDKIT_ROOT_URL=\"${BSDKIT_ROOT_URL}\" \
        BSDKIT_VERSION=\"${BSDKIT_VERSION}\" \
        BSDKIT_ARCH=\"${BSDKIT_ARCH}\" \
        BSDKIT_TREE=\"${BSDKIT_TREE}\" \
        BSDKIT_PKGSET=\"${BSDKIT_PKGSET}\" \
        JAIL_PROXY=\"${JAIL_PROXY}\"
}

: ${FREEBSD_REL_URL_TEMPLATE:='%%ROOT_URL%%/release-%%VERSION%%-%%ARCH%%'}
: ${FREEBSD_PKG_URL_TEMPLATE:='%%ROOT_URL%%/packages-${ABI}-%%TREE%%-%%PKGSET%%'}

# FREEBSD_REL_URL, FREEBSD_PKG_URL: initialized by parse_options

: ${PARSE_OPTIONS_SHIFT:=0}

ZPOOL_CREATE_CMD="zpool create"
ZFS_CREATE_CMD="zfs create"
ZPOOL_CACHE="/tmp/zpool.cache"

BSDKIT_DIR=$(realpath $(dirname $0))

parse_url() {
    local _url="$1"

    echo ${_url} | sed -e "s|%%ROOT_URL%%|${BSDKIT_ROOT_URL}|g" \
        -e                "s|%%VERSION%%|${BSDKIT_VERSION}|g" \
        -e                "s|%%ARCH%%|${BSDKIT_ARCH}|g" \
        -e                "s|%%TREE%%|${BSDKIT_TREE}|g" \
        -e                "s|%%PKGSET%%|${BSDKIT_PKGSET}|g"
}

parse_options() {
    while getopts "r:v:a:p:z:" OPT; do
        case ${OPT} in
            r)
                BSDKIT_ROOT_URL=${OPTARG%/}
                ;;
            v)
                BSDKIT_VERSION=${OPTARG}
                ;;
            a)
                BSDKIT_ARCH=${OPTARG}
                ;;
            p)
                BSDKIT_TREE=${OPTARG}
                ;;
            z)
                BSDKIT_PKGSET=${OPTARG}
                ;;
            *)
                return 1
                ;;
        esac
    done

    FREEBSD_REL_URL=$(parse_url ${FREEBSD_REL_URL_TEMPLATE})

    if [ "${BSDKIT_PKGSET}" = "none" ]; then
        FREEBSD_PKG_URL="none"
    else
        FREEBSD_PKG_URL=$(parse_url ${FREEBSD_PKG_URL_TEMPLATE})
    fi

    PARSE_OPTIONS_SHIFT=$((OPTIND - 1))
}

rc_set() {
    local _file="$1"
    local _key="$2"
    local _value="$3"

    if grep -E "^[[:space:]]*${_key}|#[[:space:]]*${_key}" ${_file} >/dev/null  2>&1; then
        sed -E -i '' -e "/^[[:space:]]*${_key}[[:space:]]*=[[:space:]]*/ c\\
${_key}=\"${_value}\"
/^[[:space:]]*#[[:space:]]*${_key}/ c\\
${_key}=\"${_value}\"
" ${_file}
    else
        echo "${_key}=\"${_value}\"" >>${_file}
    fi
}

rc_delete() {
    local _file="$1"
    local _key="$2"

    [ -e ${_file} ] || return 0

    sed -E -i '' -e "/^[[:space:]]*${_key}[[:space:]]*=/d" ${_file}
}

rc_get() {
    local _file="$1"
    local _key="$2"

    local _buffer

    _buffer="$(grep -E "^[[:space:]]*${_key}[[:space:]]*=" ${_file})"

    local _value=$(echo ${_buffer} | sed -E -e "s/[^=]*[[:space:]]*=//")

    local _value2=$(expr "${_value}" : "\"\(.*\)\"")

    if [ -n "${_value2}" ]; then
        echo ${_value2}
    else
        echo ${_value}
    fi
}

valid_url() {
    local _url="$1"

    case ${_url} in
        http://*)
            return 0
            ;;
        https://*)
            return 0
            ;;
        ftp://*)
            return 0
            ;;
        file://*)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

check_bsdkit_runtime() {
    mount -p | grep "/baseroot" >/dev/null  2>&1
}

valid_relpath() {
    local _relpath="$1"

    valid_url ${_relpath} && return 0

    [ -d ${_relpath} ]

    [ -f ${_relpath}/base.txz ]

    return 0
}

valid_pkgpath() {
    local _pkgpath="$1"

    valid_url ${_pkgpath} && return 0

    [ -d ${_pkgpath} ]

    [ -f ${_pkgpath}/packagesite.txz ]
}

valid_staging() {
    local _staging="$1"

    [ -f ${_staging}/base.ufs.uzip ]
    [ -d ${_staging}/boot ]
    [ -f ${_staging}/memroot.ufs.gz ]
}

valid_destdir() {
    local _destdir="$1"

    [ -d ${_destdir} -a ${_destdir} != "/" -a -f "${_destdir}/bin/sh" ]
}

valid_bsdkit() {
    local _bsdkit="$1"

    [ -d ${_bsdkit} -a -f "${_bsdkit}/bsdkit" ]
}

valid_class() {
    local _class="$1"

    case ${_class} in
        small)
            return 0
            ;;
        large)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

gmirror_configure() {
    local _mirror="$1"

    shift

    [ -n ${_mirror} ]

    local _device="$1"

    shift

    [ -n ${_device} ]

    gmirror label -v ${_mirror} ${_device}

    for _device in "$@"; do
        gmirror insert ${_mirror} ${_device}
    done

    return 0
}

gpt_ufs_partition_large() {
    local _destdir="$1"
    local _device="$2"

    [ -d ${_destdir} ]
    [ -n ${_device} ]

    [ -e "/dev/${_device}" ]

    gpart destroy -F ${_device} 2>/dev/null || :
    gpart create -s gpt ${_device}

    gpart bootcode -b /boot/pmbr ${_device}

    local _p=1

    gpart add -i ${_p} -s ${PART_SIZE_BOOT} -t freebsd-boot -l ${LABEL_BOOT} ${_device}
    gpart bootcode -p /boot/gptboot -i ${_p} ${_device}
    _p=$((_p + 1))

    gpart add -i ${_p} -s ${PART_SIZE_EFI} -t efi -l ${LABEL_EFI} ${_device}
    gpart bootcode -p /boot/boot1.efifat -i ${_p} ${_device}
    _p=$((_p + 1))

    if has_swap; then
        gpart add -i ${_p} -s ${PART_SIZE_SWAP} -t freebsd-swap -l ${LABEL_SWAP} ${_device}
        _p=$((_p + 1))
        swapon /dev/gpt/${LABEL_SWAP}
    fi

    gpart add -i ${_p} -s ${PART_SIZE_ROOT} -t freebsd-ufs -l ${LABEL_ROOT} ${_device}
    _p=$((_p + 1))
    gpart add -i ${_p} -s ${PART_SIZE_TMP}  -t freebsd-ufs -l ${LABEL_TMP}  ${_device}
    _p=$((_p + 1))
    gpart add -i ${_p} -s ${PART_SIZE_VAR}  -t freebsd-ufs -l ${LABEL_VAR}  ${_device}
    _p=$((_p + 1))
    gpart add -i ${_p}                      -t freebsd-ufs -l ${LABEL_USR}  ${_device}
    _p=$((_p + 1))

    # FIXME use -j

    newfs    -L ${LABEL_ROOT}    /dev/gpt/${LABEL_ROOT}
    newfs -U -L ${LABEL_TMP}  -n /dev/gpt/${LABEL_TMP}
    newfs -U -L ${LABEL_VAR}     /dev/gpt/${LABEL_VAR}
    newfs -U -L ${LABEL_USR}     /dev/gpt/${LABEL_USR}

    mount -o async,noatime /dev/gpt/${LABEL_ROOT} ${_destdir}

    mkdir -p ${_destdir}/cdrom
    mkdir -p ${_destdir}/etc
    mkdir -p ${_destdir}/tmp
    mkdir -p ${_destdir}/usr
    mkdir -p ${_destdir}/var

    if check_bsdkit_runtime; then
        mount -t nullfs /cdrom ${DESTDIR}/cdrom
    fi

    mount -o async,noatime /dev/gpt/${LABEL_VAR} ${_destdir}/var
    mount -o async,noatime /dev/gpt/${LABEL_TMP} ${_destdir}/tmp
    mount -o async,noatime /dev/gpt/${LABEL_USR} ${_destdir}/usr

    touch ${_destdir}/etc/fstab

    echo "/dev/ufs/${LABEL_ROOT} /    ufs rw 1 1" >>${_destdir}/etc/fstab
    echo "/dev/ufs/${LABEL_VAR}  /var ufs rw 2 2" >>${_destdir}/etc/fstab
    echo "/dev/ufs/${LABEL_TMP}  /tmp ufs rw 2 2" >>${_destdir}/etc/fstab
    echo "/dev/ufs/${LABEL_USR}  /usr ufs rw 2 2" >>${_destdir}/etc/fstab

    link_home ${_destdir}

    return 0
}

gpt_ufs_partition_small() {
    local _destdir="$1"
    local _device="$2"

    [ -d ${_destdir} ]
    [ -n ${_device} ]

    [ -e "/dev/${_device}" ]

    gpart destroy -F ${_device} 2>/dev/null || :
    gpart create -s gpt ${_device}

    gpart bootcode -b /boot/pmbr ${_device}

    local _p=1

    gpart add -i ${_p} -s ${PART_SIZE_BOOT} -t freebsd-boot -l ${LABEL_BOOT} ${_device}
    gpart bootcode -p /boot/gptboot -i ${_p} ${_device}
    _p=$((_p + 1))

    gpart add -i ${_p} -s ${PART_SIZE_EFI} -t efi -l ${LABEL_EFI} ${_device}
    gpart bootcode -p /boot/boot1.efifat -i ${_p} ${_device}
    _p=$((_p + 1))

    gpart add -i ${_p} -t freebsd-ufs -l ${LABEL_ROOT} ${_device}
    _p=$((_p + 1))

    # FIXME use -j

    newfs -U -L ${LABEL_ROOT} -n /dev/gpt/${LABEL_ROOT}

    mount -o async,noatime /dev/gpt/${LABEL_ROOT} ${_destdir}

    mkdir -p ${_destdir}/cdrom
    mkdir -p ${_destdir}/etc

    if check_bsdkit_runtime; then
        mount -t nullfs /cdrom ${DESTDIR}/cdrom
    fi

    touch ${_destdir}/etc/fstab

    echo "/dev/ufs/${LABEL_ROOT} / ufs rw 1 1" >>${_destdir}/etc/fstab

    link_home ${_destdir}

    return 0
}

mbr_ufs_partition_large() {
    local _destdir="$1"
    local _device="$2"

    [ -d ${_destdir} ]
    [ -n ${_device} ]
    [ -e "/dev/${_device}" ]

    # FIXME refactor

    gpart destroy -F ${_device} 2>/dev/null || :
    gpart create -s mbr ${_device}
    gpart add -i 1 -t freebsd ${_device}
    gpart set -a active -i 1 ${_device}

    gpart destroy -F ${_device}s1 2>/dev/null || :
    gpart create -s BSD ${_device}s1

    gpart bootcode -b /boot/mbr ${_device}
    gpart bootcode -b /boot/boot ${_device}s1

    # FIXME refactor (end)

    gpart add -i 1 -s ${PART_SIZE_ROOT} -t freebsd-ufs  ${_device}s1 # a

    if has_swap; then
        gpart add -i 2 -s ${PART_SIZE_SWAP} -t freebsd-swap ${_device}s1 # b
        swapon /dev/${_device}s1b
    fi

    # reserved partition c
    gpart add -i 4 -s ${PART_SIZE_TMP}  -t freebsd-ufs  ${_device}s1 # d
    gpart add -i 5 -s ${PART_SIZE_VAR}  -t freebsd-ufs  ${_device}s1 # e
    gpart add -i 6                      -t freebsd-ufs  ${_device}s1 # f

    # FIXME use -j

    newfs    -L ${LABEL_ROOT} -n /dev/${_device}s1a
    newfs -U -L ${LABEL_TMP}  -n /dev/${_device}s1e
    newfs -U -L ${LABEL_VAR}     /dev/${_device}s1d
    newfs -U -L ${LABEL_USR}     /dev/${_device}s1f

    glabel label -v swap /dev/${_device}s1b

    mount -o async,noatime /dev/ufs/${LABEL_ROOT} ${_destdir}

    mkdir -p ${_destdir}/cdrom
    mkdir -p ${_destdir}/etc
    mkdir -p ${_destdir}/tmp
    mkdir -p ${_destdir}/usr
    mkdir -p ${_destdir}/var

    if check_bsdkit_runtime; then
        mount -t nullfs /cdrom ${DESTDIR}/cdrom
    fi

    mount -o async,noatime /dev/ufs/${LABEL_VAR} ${_destdir}/var
    mount -o async,noatime /dev/ufs/${LABEL_TMP} ${_destdir}/tmp
    mount -o async,noatime /dev/ufs/${LABEL_USR} ${_destdir}/usr

    touch ${_destdir}/etc/fstab

    echo "/dev/ufs/${LABEL_ROOT} /    ufs rw 1 1" >>${_destdir}/etc/fstab
    echo "/dev/ufs/${LABEL_VAR}  /var ufs rw 2 2" >>${_destdir}/etc/fstab
    echo "/dev/ufs/${LABEL_TMP}  /tmp ufs rw 2 2" >>${_destdir}/etc/fstab
    echo "/dev/ufs/${LABEL_USR}  /usr ufs rw 2 2" >>${_destdir}/etc/fstab

    link_home ${_destdir}

    return 0
}

mbr_ufs_partition_small() {
    local _destdir="$1"
    local _device="$2"

    [ -d ${_destdir} ]
    [ -n ${_device} ]
    [ -e "/dev/${_device}" ]

    # FIXME refactor

    gpart destroy -F ${_device} 2>/dev/null || :
    gpart create -s mbr ${_device}
    gpart add -i 1 -t freebsd ${_device}
    gpart set -a active -i 1 ${_device}

    gpart destroy -F ${_device}s1 2>/dev/null || :
    gpart create -s BSD ${_device}s1

    gpart bootcode -b /boot/mbr ${_device}
    gpart bootcode -b /boot/boot ${_device}s1

    # FIXME refactor (end)

    gpart add -i 1 -t freebsd-ufs  ${_device}s1 # a

    # FIXME use -j

    newfs -U -L ${LABEL_ROOT} /dev/${_device}s1a

    mount -o async,noatime /dev/ufs/${LABEL_ROOT} ${_destdir}

    mkdir -p ${_destdir}/cdrom
    mkdir -p ${_destdir}/etc

    if check_bsdkit_runtime; then
        mount -t nullfs /cdrom ${DESTDIR}/cdrom
    fi

    touch ${_destdir}/etc/fstab

    echo "/dev/ufs/${LABEL_ROOT} / ufs rw 1 1" >>${_destdir}/etc/fstab

    link_home ${_destdir}

    return 0
}

zfs_create_pool() {
    local _destdir="$1"

    shift 1

    local _devices

    _devices="$@"

    [ -d ${_destdir} ]

    sysctl -q kern.geom.debugflags=0x10

    for _device in ${_devices}; do
        gpart destroy -F ${_device} 2>/dev/null || :

        dd if=/boot/zfsboot of=/dev/${_device} count=1
        dd if=/boot/zfsboot of=/dev/${_device} iseek=1 oseek=1024
    done

    sysctl -q kern.geom.debugflags=0x00

    local _options="-f -m none -o cachefile=${ZPOOL_CACHE} -o altroot=${_destdir}"

    set ${_devices}

    local _device

    for _device in ${_device}; do
        zpool labelclear -f ${_device} 2>/dev/null || :
    done

    case $# in
        1)
            ${ZPOOL_CREATE_CMD} ${_options} ${ZFS_POOL} ${1}
            ;;
        2)
            ${ZPOOL_CREATE_CMD} ${_options} ${ZFS_POOL} mirror ${1} ${2}
            ;;
        3)
            ${ZPOOL_CREATE_CMD} ${_options} ${ZFS_POOL} raidz1 ${1} ${2} ${3}
            ;;
        *)
            error "unsupported number of devices in pool (zfs_create_pool)."
            ;;
    esac

    # zfs_auto_snapshot ${ZFS_POOL}

    if has_swap; then
        zfs create \
            -o checksum=off \
            -o compression=off \
            -o dedup=off \
            -o sync=disabled \
            -o primarycache=none \
            -o org.freebsd:swap=on \
            -V ${PART_SIZE_SWAP} \
            ${ZFS_POOL}/swap
    fi

    return 0
}

zfs_create_gpt_pool() {
    local _destdir="$1"

    shift 1

    local _devices

    _devices="$@"

    [ -d ${_destdir} ]

    local _device_index=0

    local _pool_partition=0

    for _device in ${_devices}; do
        gpart destroy -F ${_device} 2>/dev/null || :
        gpart create -s gpt ${_device}

        local _p=1

        gpart add -i ${_p} -s ${PART_SIZE_BOOT} -t freebsd-boot -l ${LABEL_BOOT}${_device_index} ${_device}
        gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i ${_p} ${_device}
        _p=$((_p + 1))

        gpart add -i ${_p} -s ${PART_SIZE_EFI} -t efi -l ${LABEL_EFI}${_device_index} ${_device}
        gpart bootcode -p /boot/boot1.efifat -i ${_p} ${_device}
        _p=$((_p + 1))

        if has_swap; then
            gpart add -i ${_p} -s ${PART_SIZE_SWAP} -t freebsd-swap -l ${LABEL_SWAP}${_device_index} ${_device}
            _p=$((_p + 1))
            swapon /dev/gpt/${LABEL_SWAP}${_device_index}
        fi

        gpart add -i ${_p} -t freebsd-zfs -l pool${_device_index} ${_device}
        gpart set -a bootme -i ${_p} ${_device}
        _pool_partition=${_p}
        _p=$((_p + 1))

        _device_index=$((_device_index + 1))
    done

    local _options="-f -m none -o cachefile=${ZPOOL_CACHE} -o altroot=${_destdir}"

    set ${_devices}

    local _suffix="p${_pool_partition}"

    local _device

    for _device in ${_device}; do
        zpool labelclear -f ${_device}${_suffix} 2>/dev/null || :
    done

    case $# in
        1)
            ${ZPOOL_CREATE_CMD} ${_options} ${ZFS_POOL} ${1}${_suffix}
            ;;
        2)
            ${ZPOOL_CREATE_CMD} ${_options} ${ZFS_POOL} mirror ${1}${_suffix} ${2}${_suffix}
            ;;
        3)
            ${ZPOOL_CREATE_CMD} ${_options} ${ZFS_POOL} raidz1 ${1}${_suffix} ${2}${_suffix} ${3}${_suffix}
            ;;
        *)
            error "unsupported number of devices in pool (zfs_create_gpt_pool)."
            ;;
    esac

    return 0
}

zfs_create_mbr_pool() {
    local _destdir="$1"

    shift 1

    local _devices

    _devices="$@"

    [ -d ${_destdir} ]

    local _device

    for _device in ${_devices}; do
        # FIXME refactor

        gpart destroy -F ${_device} 2>/dev/null || :
        gpart create -s mbr ${_device}
        gpart add -i 1 -t freebsd ${_device}
        gpart set -a active -i 1 ${_device}
        gpart destroy -F ${_device}s1 2>/dev/null || :
        gpart create -s BSD ${_device}s1
        gpart bootcode -b /boot/mbr ${_device}

        local _autorootsize="$(($(diskinfo ${_device} | cut -f 3) / 1024 / 1024 - PART_SIZE_SWAP))"

        # do not align partitions here
        gpart add -i 1 -s ${_autorootsize} -t freebsd-zfs  ${_device}s1 # a

        if has_swap; then
            gpart add -i 2 -t freebsd-swap ${_device}s1 # b
            swapon /dev/${_device}s1b
        fi

        dd if=/boot/zfsboot of=/dev/${_device}s1a count=1
        dd if=/boot/zfsboot of=/dev/${_device}s1a iseek=1 oseek=1024
    done

    local _options="-f -m none -o cachefile=${ZPOOL_CACHE} -o altroot=${_destdir}"

    set ${_devices}

    local _suffix="s1a"

    local _device

    for _device in ${_device}; do
        zpool labelclear -f ${_device}${_suffix} 2>/dev/null || :
    done

    case $# in
        1)
            ${ZPOOL_CREATE_CMD} ${_options} ${ZFS_POOL} ${1}${_suffix}
            ;;
        2)
            ${ZPOOL_CREATE_CMD} ${_options} ${ZFS_POOL} mirror ${1}${_suffix} ${2}${_suffix}
            ;;
        3)
            ${ZPOOL_CREATE_CMD} ${_options} ${ZFS_POOL} raidz1 ${1}${_suffix} ${2}${_suffix} ${3}${_suffix}
            ;;
        *)
            error "unsupported number of devices in pool (zfs_create_mbr_pool)."
            ;;
    esac

    return 0
}

zfs_create_fs() {
    local _destdir="$1"

    [ -d ${_destdir} ]

    zfs set atime=off ${ZFS_POOL}

    ${ZFS_CREATE_CMD} -o mountpoint=none -o canmount=noauto ${ZFS_POOL}/ROOT
    ${ZFS_CREATE_CMD} -o mountpoint=/    -o canmount=noauto ${ZFS_POOL}/ROOT/default

    zfs mount ${ZFS_POOL}/ROOT/default

    ${ZFS_CREATE_CMD} -o mountpoint=/tmp -o setuid=off   ${ZFS_POOL}/tmp
    ${ZFS_CREATE_CMD} -o mountpoint=/usr -o canmount=off ${ZFS_POOL}/usr
    ${ZFS_CREATE_CMD} -o mountpoint=/var -o canmount=off ${ZFS_POOL}/var
    ${ZFS_CREATE_CMD} -o mountpoint=/jails               ${ZFS_POOL}/jails
    ${ZFS_CREATE_CMD} -o compression=on                  ${ZFS_POOL}/usr/src
    ${ZFS_CREATE_CMD} -o setuid=off                      ${ZFS_POOL}/usr/ports
    ${ZFS_CREATE_CMD} -o setuid=off -o exec=off          ${ZFS_POOL}/var/audit
    ${ZFS_CREATE_CMD} -o setuid=off -o exec=off          ${ZFS_POOL}/var/crash
    ${ZFS_CREATE_CMD} -o setuid=off -o exec=off          ${ZFS_POOL}/var/log
    ${ZFS_CREATE_CMD} -o atime=on                        ${ZFS_POOL}/var/mail
    ${ZFS_CREATE_CMD} -o setuid=off                      ${ZFS_POOL}/var/tmp
    ${ZFS_CREATE_CMD} -o canmount=off                    ${ZFS_POOL}/usr/local
    ${ZFS_CREATE_CMD}                                    ${ZFS_POOL}/usr/home

    mkdir -p ${_destdir}/altroot
    mkdir -p ${_destdir}/boot
    mkdir -p ${_destdir}/cdrom
    mkdir -p ${_destdir}/etc

    if check_bsdkit_runtime; then
        mount -t nullfs /cdrom ${DESTDIR}/cdrom
    fi

    touch ${_destdir}/etc/fstab

    link_home ${_destdir}

    zpool set bootfs=${ZFS_POOL}/ROOT/default ${ZFS_POOL}

    return 0
}

link_home() {
    local _destdir="$1"

    mkdir -p ${_destdir}/usr/home
    ln -s -f usr/home ${_destdir}/home
}

swap_setup() {
    local _destdir="$1"

    valid_destdir ${_destdir}

    local _swap

    for _swap in $(find /dev | grep -E "(gpt|label)/swap" | rs 1 0); do
        echo "${_swap} none swap sw 0 0" >>${_destdir}/etc/fstab
    done

    return 0
}

procfs_setup() {
    if ! is_yes "${PROCFS_ENABLE}"; then
        return 0
    fi

    local _destdir="$1"

    [ -d ${_destdir} ]

    echo "proc /proc procfs rw 0 0" >>${_destdir}/etc/fstab

    return 0
}

fdescfs_setup() {
    if ! is_yes "${FDESCFS_ENABLE}"; then
        return 0
    fi

    local _destdir="$1"

    [ -d ${_destdir} ]

    echo "fdescfs /dev/fd fdescfs rw 0 0" >>${_destdir}/etc/fstab

    return 0
}

has_swap() {
    [ "${PART_SIZE_SWAP}" = "0" ] && return 1

    return 0
}

format_fstab() {
    local _destdir="$1"

    valid_destdir ${_destdir}

    local _fstab="${_destdir}/etc/fstab"

    echo "#linprocfs /compat/linux/proc linprocfs rw 0 0"      >>${_destdir}/etc/fstab
    echo "#tmpfs /compat/linux/dev/shm tmpfs rw,mode=1777 0 0" >>${_destdir}/etc/fstab

    column -t <${_fstab}  | sort >${_fstab}.0

    install -m 644 -o root -g wheel ${_fstab}.0 ${_fstab}

    rm ${_fstab}.0
}

install_release() {
    local _relpath="$1"
    local _destdir="$2"

    valid_relpath ${_relpath}

    [ -d ${_destdir} ]
    [ ${_destdir} != "/" ]

    local _is_remote="no"

    if valid_url ${_relpath}; then
        _is_remote="yes"

        local _local_relpath_root
        local _local_relpath

        local _release_tag="${BSDKIT_VERSION}-${BSDKIT_ARCH}"

        if is_yes ${INSTALL_JAIL}; then
            _local_relpath_root="/usr/freebsd-dist"
        else
            _local_relpath_root="${_destdir}/freebsd-dist"
        fi

        _local_relpath="${_local_relpath_root}/${_release_tag}"

        mkdir -p ${_local_relpath}

        fetch -o ${_local_relpath}/MANIFEST ${_relpath}/MANIFEST

        cat ${_local_relpath}/MANIFEST | while read _filename _sha256 _size _package _desc _enable; do
            if ! is_yes ${INSTALL_SRC} && [ ${_package} = "src" ]; then
                continue
            fi

            if ! is_yes ${INSTALL_KERNEL} && [ ${_package} != "${_package#kernel}" ]; then
                continue
            fi

            if ! is_yes ${INSTALL_DEBUG} && [ ${_package} != "${_package%_dbg}" ]; then
                continue
            fi

            if ! is_yes ${INSTALL_TESTS} && [ ${_package} = "tests" ]; then
                continue
            fi

            local _sha256_local

            if [ -f "${_local_relpath}/${_filename}" ]; then
                echo "Checking: ${_filename}"
                _sha256_local=$(${CAT_CMD} "${_local_relpath}/${_filename}" | sha256 -q)
            else
                _sha256_local="0"
            fi

            while [ "${_sha256}" != "${_sha256_local}" ]; do
                fetch -o ${_local_relpath}/${_filename} ${_relpath}/${_filename}
                echo "Checking: ${_filename}"
                _sha256_local=$(${CAT_CMD} "${_local_relpath}/${_filename}" | sha256 -q)
            done
        done

        _relpath=${_local_relpath}
    fi

    cat ${_relpath}/MANIFEST | while read _filename _sha256 _size _package _desc _enable; do
        if ! is_yes ${INSTALL_SRC} && [ ${_package} = "src" ]; then
            continue
        fi

        if ! is_yes ${INSTALL_KERNEL} && [ ${_package} != "${_package#kernel}" ]; then
            continue
        fi

        if ! is_yes ${INSTALL_DEBUG} && [ ${_package} != "${_package%_dbg}" ]; then
            continue
        fi

        if ! is_yes ${INSTALL_TESTS} && [ ${_package} = "tests" ]; then
            continue
        fi

        echo "Extracting: ${_filename}"
        ${CAT_CMD} "${_relpath}/${_filename}" | tar --unlink -xpJf - -C ${_destdir}

        sync
    done

    if is_yes ${_is_remote}; then
        if ! is_yes ${INSTALL_JAIL}; then
            rm -f ${_local_relpath}/*
            rmdir ${_local_relpath}
            rmdir ${_local_relpath_root}
        fi
    fi

    mtree -ideU -N ${_destdir}/etc -f ${_destdir}/etc/mtree/BSD.root.dist -p ${_destdir}/
    mtree -ideU -N ${_destdir}/etc -f ${_destdir}/etc/mtree/BSD.var.dist  -p ${_destdir}/var
    mtree -ideU -N ${_destdir}/etc -f ${_destdir}/etc/mtree/BSD.usr.dist  -p ${_destdir}/usr

    if [ -f ${_destdir}/etc/mtree/BSD.include.dist ]; then
        mtree -ideU -N ${_destdir}/etc -f ${_destdir}/etc/mtree/BSD.include.dist -p ${_destdir}/usr/include
    fi

    if [ -f ${_destdir}/etc/mtree/BSD.sendmail.dist ]; then
        mtree -ideU -N ${_destdir}/etc -f ${_destdir}/etc/mtree/BSD.sendmail.dist -p ${_destdir}/
    fi

    if [ -f ${_destdir}/etc/mtree/BSD.tests.dist ]; then
        mtree -ideU -N ${_destdir}/etc -f ${_destdir}/etc/mtree/BSD.tests.dist -p ${_destdir}/usr/tests
    fi

    return 0
}

install_resolv_conf() {
    if [ -f /etc/resolv.conf -a ! -f ${_destdir}/etc/resolv.conf ]; then
        install -m 644 -o root -g wheel /etc/resolv.conf ${_destdir}/etc/resolv.conf
    fi
}

install_ca_root_nss() {
    if [ -f /usr/local/share/certs/ca-root-nss.crt -a ! -e ${_destdir}/usr/local/etc/ssl/cert.pem ]; then
        mkdir -p ${_destdir}/usr/local/etc/ssl
        install -m 644 -o root -g wheel /usr/local/share/certs/ca-root-nss.crt ${_destdir}/usr/local/etc/ssl/cert.pem
    fi
}

customize_base() {
    local _destdir="$1"

    valid_destdir ${_destdir}

    chroot ${_destdir} chpass -p '$1$El8jLO2w$KX9lQ3ScWeZF6SqG267w9.' root

    mkdir -p ${_destdir}/root/.ssh

    echo_bsdkit_public_key >${_destdir}/root/.ssh/authorized_keys

    chown -R root:wheel ${_destdir}/root

    # ===

    sed -i '' -e '/^PermitRootLogin/d' ${_destdir}/etc/ssh/sshd_config
    sed -i '' -e '/^UseDNS/d' ${_destdir}/etc/ssh/sshd_config

    cat >>${_destdir}/etc/ssh/sshd_config  <<EOF
UseDNS no
PermitRootLogin yes
EOF

    mkdir -p ${_destdir}/etc/rc.conf.d

    install_resolv_conf ${_destdir}
    install_ca_root_nss ${_destdir}

    local _login_env=",LC_ALL=en_US.UTF-8"
    # _login_env="${_login_env},..."

    sed -i '' -e "s/:\(setenv.*\):/:\1${_login_env}:/" ${_destdir}/etc/login.conf

    sed -i '' -e '/^	:umask=022:/i\
	:charset=UTF-8:\\\
	:lang=en_US.UTF-8:\\\' ${_destdir}/etc/login.conf

    cap_mkdb ${_destdir}/etc/login.conf

    return 0
}

inet_interface() {
    route get default | awk '/interface:/ { print $2 }'
}

inet_address() {
    ifconfig $(inet_interface) | awk '$1 == "inet" { print $2; exit }'
}

start_jail() {
    local _destdir="$1"
    valid_destdir ${_destdir}
    local _jail_conf=$(mktemp /tmp/jail.conf.XXXXXX)
    echo_runtime_jail_conf ${_destdir} >${_jail_conf}
    jail -f ${_jail_conf} -c ${JAIL_NAME}
    rm ${_jail_conf}
}

stop_jail() {
    local _destdir="$1"
    valid_destdir ${_destdir}
    local _jail_conf=$(mktemp /tmp/jail.conf.XXXXXX)
    echo_runtime_jail_conf ${_destdir} >${_jail_conf}
    jail -f ${_jail_conf} -r ${JAIL_NAME}
    rm ${_jail_conf}
}

reset_state() {
    jail -R '*'

    mount -p |
        cut   -w -f 2 |
        grep   /baseroot${DESTDIR} |
        sort   -r |
        xargs   umount -f

    swapctl -l | grep "^/" | cut -f 1 -d' ' | xargs swapoff

    # This is dangerous, and we do not do it here:
    #   zpool destroy ${ZFS_POOL} || :
}

install_mbr_ufs() {
    parse_options "$@"

    shift ${PARSE_OPTIONS_SHIFT}

    local _class="$1"
    local _device="$2"

    [ -n ${_class} ]
    [ -n ${_device} ]

    valid_class ${_class}

    mkdir -p ${DESTDIR}

    mbr_ufs_partition_${_class} ${DESTDIR} ${_device}
    install_release ${FREEBSD_REL_URL} ${DESTDIR}
    swap_setup ${DESTDIR}
    procfs_setup ${DESTDIR}
    fdescfs_setup ${DESTDIR}
    format_fstab ${DESTDIR}
    customize_base ${DESTDIR}

    return 0
}

install_mbr_ufs_gmirror() {
    parse_options "$@"

    shift ${PARSE_OPTIONS_SHIFT}

    local _class="$1"
    local _mirror="$2"

    shift 2

    local _devices

    _devices="$@"

    [ -n ${_class} ]
    [ -n ${_mirror} ]
    [ -n "${_devices}" ]

    valid_class ${_class}

    kldload -n geom_mirror

    mkdir -p ${DESTDIR}

    gmirror_configure ${_mirror} ${_devices}
    mbr_ufs_partition_${_class} ${DESTDIR} mirror/${_mirror}
    install_release ${FREEBSD_REL_URL} ${DESTDIR}
    swap_setup ${DESTDIR}
    procfs_setup ${DESTDIR}
    fdescfs_setup ${DESTDIR}
    format_fstab ${DESTDIR}
    customize_base ${DESTDIR}

    return 0
}

install_gpt_ufs() {
    parse_options "$@"

    shift ${PARSE_OPTIONS_SHIFT}

    local _class="$1"
    local _device="$2"

    [ -n ${_class} ]
    [ -n ${_device} ]

    valid_class ${_class}

    mkdir -p ${DESTDIR}

    gpt_ufs_partition_${_class} ${DESTDIR} ${_device}
    install_release ${FREEBSD_REL_URL} ${DESTDIR}
    swap_setup ${DESTDIR}
    procfs_setup ${DESTDIR}
    fdescfs_setup ${DESTDIR}
    format_fstab ${DESTDIR}
    customize_base ${DESTDIR}

    return 0
}

install_zfs() {
    check_bsdkit_runtime

    parse_options "$@"

    shift ${PARSE_OPTIONS_SHIFT}

    local _devices

    _devices="$@"

    [ -n "${_devices}" ]

    kldload -n zfs

    mkdir -p ${DESTDIR}

    zfs_create_pool ${DESTDIR} ${_devices}
    zfs_create_fs ${DESTDIR}
    install_release ${FREEBSD_REL_URL} ${DESTDIR}
    install -v -m 644 -o root -g wheel ${ZPOOL_CACHE} ${DESTDIR}/boot/zfs
    swap_setup ${DESTDIR}
    procfs_setup ${DESTDIR}
    fdescfs_setup ${DESTDIR}
    format_fstab ${DESTDIR}
    customize_base ${DESTDIR}

    return 0
}

install_gpt_zfs() {
    check_bsdkit_runtime

    parse_options "$@"

    shift ${PARSE_OPTIONS_SHIFT}

    local _devices

    _devices="$@"

    [ -n "${_devices}" ]

    kldload -n zfs

    mkdir -p ${DESTDIR}

    zfs_create_gpt_pool ${DESTDIR} ${_devices}
    zfs_create_fs ${DESTDIR}
    install_release ${FREEBSD_REL_URL} ${DESTDIR}
    install -v -m 644 -o root -g wheel ${ZPOOL_CACHE} ${DESTDIR}/boot/zfs
    swap_setup ${DESTDIR}
    procfs_setup ${DESTDIR}
    fdescfs_setup ${DESTDIR}
    format_fstab ${DESTDIR}
    customize_base ${DESTDIR}

    return 0
}

install_mbr_zfs() {
    check_bsdkit_runtime

    parse_options "$@"

    shift ${PARSE_OPTIONS_SHIFT}

    local _devices

    _devices="$@"

    [ -n "${_devices}" ]

    kldload -n zfs

    mkdir -p ${DESTDIR}

    zfs_create_mbr_pool ${DESTDIR} ${_devices}
    zfs_create_fs ${DESTDIR}
    install_release ${FREEBSD_REL_URL} ${DESTDIR}
    install -v -m 644 -o root -g wheel ${ZPOOL_CACHE} ${DESTDIR}/boot/zfs
    swap_setup ${DESTDIR}
    procfs_setup ${DESTDIR}
    fdescfs_setup ${DESTDIR}
    format_fstab ${DESTDIR}
    customize_base ${DESTDIR}

    return 0
}

# bsdkit create_iocell tag -v12.1
create_iocell() {
    parse_options "$@"

    shift ${PARSE_OPTIONS_SHIFT}

    local _tag="$1"

    shift

    which iocell >/dev/null  2>&1 || error "iocell not found (create_iocell)."

    local _uuid=$(iocell create -e tag="${_tag}" host_hostname="${_tag}" "$@")
    local _mountpoint=$(iocell get mountpoint "${_tag}") || error "iocell could not retrieve mountpoint"
    local _destdir=${_mountpoint}/root

    [ -d ${_destdir} ] || error "iocell root does not exist (create_iocell)."

    INSTALL_KERNEL=no INSTALL_SRC=no _do_create_jail ${_destdir}

    _do_configure_jail ${_destdir}
}

# bsdkit create_iocell_thin tag release=12.1-RELEASE
create_iocell_thin() {
    parse_options "$@"

    shift ${PARSE_OPTIONS_SHIFT}

    local _tag="$1"

    shift 1

    which iocell >/dev/null  2>&1 || error "iocell not found (create_iocell_thin)."

    iocell create tag="${_tag}" host_hostname="${_tag}" "$@" || error "iocell could not create jail"

    local _uuid=$(iocell get host_hostuuid "${_tag}") || error "iocell could not retrieve host_hostuuid"
    local _mountpoint=$(iocell get mountpoint "${_tag}") || error "iocell could not retrieve mountpoint"
    local _destdir=${_mountpoint}/root

    [ -d ${_destdir} ] || error "iocell root does not exist (create_iocell_thin)."

    _do_configure_jail ${_destdir}
}

# bsdkit create_iocage -v12.1 tag
create_iocage() {
    parse_options "$@"

    shift ${PARSE_OPTIONS_SHIFT}

    local _jail_name="$1"

    shift

    unset IOCAGE_COLOR

    which iocage >/dev/null  2>&1 || error "iocage not found (create_iocage)."
    iocage get -p >/dev/null  2>&1 || error "unable to retrieve iocage mount point (create_iocage)."
    local _iocage_root=$(iocage get -p)
    local _iocage_jails=$(zfs get -H -p -o value mountpoint ${_iocage_root}/iocage/jails)
    iocage create -e --name "${_jail_name}" "$@"
    local _destdir=${_iocage_jails}/${_jail_name}/root

    [ -d ${_destdir} ] || error "iocage root does not exist (create_iocage)."

    INSTALL_KERNEL=no INSTALL_SRC=no _do_create_jail ${_destdir}

    _do_configure_jail ${_destdir}
}

# bsdkit create_iocage_thin tag -r 12.1-RELEASE ip4_addr='lo0|172.16.1.1/32'
create_iocage_thin() {
    parse_options "$@"

    shift ${PARSE_OPTIONS_SHIFT}

    local _jail_name="$1"

    shift

    unset IOCAGE_COLOR

    which iocage >/dev/null  2>&1 || error "iocage not found (create_iocage)."
    iocage get -p >/dev/null  2>&1 || error "unable to retrieve iocage mount point (create_iocage)."
    local _iocage_root=$(iocage get -p)
    local _iocage_jails=$(zfs get -H -p -o value mountpoint ${_iocage_root}/iocage/jails)
    iocage create --name "${_jail_name}" "$@"
    local _destdir=${_iocage_jails}/${_jail_name}/root

    [ -d ${_destdir} ] || error "iocage root does not exist (create_iocage)."

    _do_configure_jail ${_destdir}
}

create_jail() {
    parse_options "$@"

    shift ${PARSE_OPTIONS_SHIFT}

    local _jail_name="$1"

    local _destdir=${JAIL_ROOT}/${_jail_name}

    create_jail_destdir ${_jail_name}

    INSTALL_KERNEL=no INSTALL_SRC=no _do_create_jail ${_destdir}

    _do_configure_jail ${_destdir}
}

configure_jail() {
    parse_options "$@"

    shift ${PARSE_OPTIONS_SHIFT}

    local _destdir="$1"

    shift

    [ -d ${_destdir} ] || error "jail root does not exist (configure_jail)."
    [ -f ${_destdir}/etc/rc.conf ] || error "rc.conf does not exist in jail (configure_jail)."

    _do_configure_jail ${_destdir}
}

create_md() {
    local _md_device=$(mdconfig -a -t swap -o reserve -s 2G)

    env INSTALL_SRC=no FS_SWAP_SIZE=0 LABEL_ROOT=mdroot "$0" deploy install_gpt_ufs "$@" small "${_md_device}"

    rm -f ${DESTDIR}/etc/rc.conf

    rc_set ${DESTDIR}/etc/rc.conf hostname localhost
    rc_set ${DESTDIR}/etc/rc.conf sshd_enable YES

    sed -i '' -e '/^PermitRootLogin/d' ${DESTDIR}/etc/ssh/sshd_config

    cat >>${DESTDIR}/etc/ssh/sshd_config  <<EOF
PermitRootLogin yes
EOF

    echo "Previous value of vfs.root.mountfrom: \"$(kenv vfs.root.mountfrom)\""

    kenv vfs.root.mountfrom="ufs:/dev/${_md_device}p3"
}

create_jail_destdir() {
    local _jail_name="$1"

    local _destdir=${JAIL_ROOT}/${_jail_name}

    if [ -d "${_destdir}" ]; then
        [ "$(echo $(find ${_destdir} -type d -empty -maxdepth 0 | wc -l))" = "1" ] || error "${_destdir} already exists (create_jail_destdir)."
    fi

    local _dirname="$(dirname ${_destdir})"
    local _parent_fs=$(zfs list -H -o mounted,mountpoint,name | awk "\$1 == \"yes\" && \$2 == \"${_dirname}\" { print \$3; }")
    local _zfs="NO"

    if [ -n "${_parent_fs}" ]; then
        if ! zfs get -H -o value mountpoint "${_parent_fs}/${_jail_name}" >/dev/null  2>&1; then
            ${ZFS_CREATE_CMD} -o compression=on "${_parent_fs}/${_jail_name}"
            _zfs="YES"
        fi
    else
        mkdir -p ${_destdir}
    fi
}

_do_create_jail() {
    local _destdir="$1"

    INSTALL_KERNEL=${INSTALL_KERNEL} INSTALL_SRC=${INSTALL_SRC} INSTALL_JAIL=yes install_release ${FREEBSD_REL_URL} ${_destdir}
}

_do_configure_jail() {
    local _destdir="$1"

    link_home ${_destdir}

    mkdir -p ${_destdir}/usr/ports

    customize_base ${_destdir}

    if [ -f /etc/hosts -a ! -f ${_destdir}/etc/hosts ]; then
        install -m 644 -o root -g wheel /etc/hosts ${_destdir}/etc/hosts
    fi

    start_jail ${_destdir}
    pw -V ${_destdir}/etc usermod root -s /bin/sh
    INSTALL_JAIL=yes ansible_jail_playbook
    pw -V ${_destdir}/etc usermod root -s /bin/csh
    stop_jail ${_destdir}

    return 0
}

remove_jail() {
    local _jail_name="$1"

    local _destdir=${JAIL_ROOT}/${_jail_name}

    valid_destdir ${_destdir}

    local _dirname="$(dirname ${_destdir})"
    local _parent_fs=$(mount -p | awk "\$2 == \"${_dirname}\" { print \$1 }")
    local _zfs="NO"

    local _devfs

    mount -p -t devfs | cut -w -f 2 | while read _devfs; do
        if [ "${_devfs}" = "${_destdir}/dev" ]; then
            umount -f ${_destdir}/dev
        fi
    done

    if [ -n "${_parent_fs}" ]; then
        if zfs get -H -o value mountpoint "${_parent_fs}/${_jail_name}" >/dev/null  2>&1; then
            _zfs="YES"
        fi
    fi

    if [ "${_zfs}" = "YES" ]; then
        zfs destroy "${_parent_fs}/${_jail_name}"
    else
        rm -r -f ${_destdir} >/dev/null  2>&1 || :
        chflags -R noschg ${_destdir} >/dev/null  2>&1 || :
        rm -r -f ${_destdir}
    fi
}

make_read_only() {
    local _destdir="$1"

    valid_destdir ${_destdir}

    sed -i '' -e '/^root:/ c\
root:$1$PkLp4/DM$/3D/umXPR0XIb0HsPHByU/:0:0::0:0:System Administrator:/root:/bin/csh' \
        ${_destdir}/etc/master.passwd

    pwd_mkdb -d ${_destdir}/etc ${_destdir}/etc/master.passwd

    touch ${_destdir}/etc/fstab

    # newsyslog -v -C -f ${_destdir}/etc/newsyslog.conf -d ${_destdir}

    cat >${_destdir}/etc/ttys  <<EOF
ttyv0 "/usr/libexec/getty autologin" xterm onifexists  secure
ttyv1 "/usr/libexec/getty autologin" xterm onifexists  secure
ttyv2 "/usr/libexec/getty autologin" xterm onifexists  secure
ttyv3 "/usr/libexec/getty autologin" xterm onifexists  secure
ttyu0 "/usr/libexec/getty autologin" vt100 onifconsole secure
EOF

    cat >${_destdir}/etc/rc.conf.local  <<EOF
background_dhclient="YES"
background_fsck="NO"
cleanvar_enable="NO"
crashinfo_enable="NO"
cron_enable="NO"
defaultroute_delay="10"
entropy_boot_file="NO"
entropy_file="NO"
hostid_enable="NO"
hostname="bsdkit"
ifconfig_DEFAULT="DHCP"
ip6addrctl_enable="NO"
keyrate="fast"
mixer_enable="NO"
moused_nondefault_enable="NO"
newsyslog_enable="YES"
ntpd_enable="YES"
ntpd_sync_on_start="YES"
root_rw_mount="NO"
sendmail_enable="NONE"
sendmail_msp_queue_enable="NO"
sendmail_outbound_enable="NO"
sendmail_submit_enable="NO"
sshd_enable="YES"
syslogd_enable="YES"
tmpmfs="YES"
varmfs="YES"
virecover_enable="NO"
EOF

    sed -i '' -e '/^PermitRootLogin/d' ${_destdir}/etc/ssh/sshd_config
    sed -i '' -e '/^UseDNS/d' ${_destdir}/etc/ssh/sshd_config
    sed -i '' -e '/^GatewayPorts/d' ${_destdir}/etc/ssh/sshd_config
    sed -i '' -e '/^MaxAuthTries/d' ${_destdir}/etc/ssh/sshd_config
    sed -i '' -e '/^leapfile/d' ${_destdir}/etc/ntp.conf

    cat >>${_destdir}/etc/ssh/sshd_config  <<EOF
UseDNS no
PermitRootLogin yes
GatewayPorts yes
MaxAuthTries 32
EOF

    cat >${_destdir}/etc/host.conf  <<EOF
# Auto-generated from nsswitch.conf
hosts
dns
EOF

    return 0
}

install_setup_runtime() {
    local _destdir="$1"
    local _bsdkit="$2"
    local _pkgpath="$3"

    valid_destdir ${_destdir}
    valid_bsdkit ${_bsdkit}
    valid_pkgpath ${_pkgpath}

    local _runtime=""

    # required
    _runtime="${_runtime} ca_root_nss"
    _runtime="${_runtime} pkg"
    _runtime="${_runtime} pv"
    _runtime="${_runtime} py37-ansible"
    _runtime="${_runtime} py37-tqdm"
    _runtime="${_runtime} python"
    _runtime="${_runtime} zsh"

    # optional
    _runtime="${_runtime} align"
    _runtime="${_runtime} augeas"
    _runtime="${_runtime} bcwipe"
    _runtime="${_runtime} beadm"
    _runtime="${_runtime} buffer"
    _runtime="${_runtime} bvi"
    _runtime="${_runtime} cdialog"
    _runtime="${_runtime} clone"
    _runtime="${_runtime} cpdup"
    _runtime="${_runtime} curl"
    _runtime="${_runtime} dar"
    _runtime="${_runtime} ddrescue"
    _runtime="${_runtime} fusefs-exfat"
    _runtime="${_runtime} fusefs-ext2"
    _runtime="${_runtime} fusefs-ntfs"
    _runtime="${_runtime} git"
    _runtime="${_runtime} gnu-watch"
    _runtime="${_runtime} go-cs"
    _runtime="${_runtime} go-www"
    _runtime="${_runtime} hextools"
    _runtime="${_runtime} hfsutils"
    _runtime="${_runtime} inplace"
    _runtime="${_runtime} ipmitool"
    _runtime="${_runtime} kermit"
    _runtime="${_runtime} lftp"
    _runtime="${_runtime} mbuffer"
    _runtime="${_runtime} megacli"
    _runtime="${_runtime} memtester"
    _runtime="${_runtime} nano"
    _runtime="${_runtime} ncdu"
    _runtime="${_runtime} openvpn"
    _runtime="${_runtime} pipemeter"
    _runtime="${_runtime} py37-libzfs"
    _runtime="${_runtime} py37-python-augeas"
    _runtime="${_runtime} py37-sh"
    _runtime="${_runtime} rdate"
    _runtime="${_runtime} redir"
    _runtime="${_runtime} renameutils"
    _runtime="${_runtime} rsync"
    _runtime="${_runtime} smartmontools"
    _runtime="${_runtime} tinyproxy"
    _runtime="${_runtime} tio"
    _runtime="${_runtime} tmux"
    _runtime="${_runtime} vim"
    _runtime="${_runtime} xe"
    _runtime="${_runtime} zip"

    # disabled
    # _runtime="${_runtime} sysutils/genisoimage"

    local _allpkg=${_pkgpath}/All

    local _pkgdir=/usr/ports/packages

    mkdir -p ${_destdir}/${_pkgdir}
    mkdir -p ${_destdir}/dev

    {
        mount -t devfs devfs ${_destdir}/dev
        mount -t nullfs ${_pkgpath} ${_destdir}/${_pkgdir}

        mkdir -p ${_destdir}/usr/local/etc/pkg/repos

        cat >${_destdir}/usr/local/etc/pkg/repos/FreeBSD.conf  <<EOF
FreeBSD: {
    enabled: no
}
EOF

        cat >${_destdir}/usr/local/etc/pkg/repos/bsdkit.conf  <<EOF
bsdkit: {
    url: "file://${_pkgdir}"
}
EOF

        lockf -k -t ${PKG_LOCKTIME} ${PKG_LOCKFILE} pkg -c ${_destdir} install -y ${_runtime}

        if [ -d ${_destdir}/var/cache/pkg ]; then
            lockf -k -t ${PKG_LOCKTIME} ${PKG_LOCKFILE} pkg -c ${_destdir} clean -y -a
        fi

        rm -f ${_destdir}/usr/local/etc/pkg/repos/bsdkit.conf

        umount -f ${_destdir}/${_pkgdir}
        umount -f ${_destdir}/dev
    }

    rmdir ${_destdir}/${_pkgdir}

    local _master_passwd=$(mktemp ${_destdir}/tmp/master.passwd.XXXXXX)

    cp -p ${_destdir}/etc/master.passwd ${_master_passwd}

    sed -i '' -e '/^root/s@/bin/csh@/usr/local/bin/zsh@' ${_master_passwd}

    pwd_mkdb -d ${_destdir}/etc ${_master_passwd}

    rm -f ${_master_passwd}

    install -m 644 -o root -g wheel ${_bsdkit}/ansible/dot.zshrc ${_destdir}/root/.zshrc

    cat >>${_destdir}/root/.zshrc  <<EOF
echo -n "Available disks: "
sysctl -n kern.disks | rs 0 1 | sort | grep -v -E "^cd|^acd" | rs 1 0 | sed -E -e "s/ +/ /g"
echo
EOF

    return 0
}

build_setup_staging() {
    local _staging="$1"
    local _bsdkit="$2"
    local _relpath="$3"
    local _pkgpath="$4"

    mkdir -p ${_staging}

    _staging=$(realpath ${_staging})
    _bsdkit=$(realpath ${_bsdkit})
    _relpath=$(realpath ${_relpath})
    _pkgpath=$(realpath ${_pkgpath})

    valid_bsdkit ${_bsdkit}
    valid_relpath ${_relpath}
    valid_pkgpath ${_pkgpath}

    [ ${_staging} != ${_bsdkit} ]
    [ ${_staging} != ${_relpath} ]
    [ ${_staging} != ${_pkgpath} ]
    [ ${_staging} != "/" ] || exit 1

    local _tmp="/tmp/tmp.$$"
    mkdir -p ${_tmp}
    mount -t tmpfs tmpfs ${_tmp}

    local _destdir="${_tmp}/destdir"

    mkdir -p ${_destdir}

    INSTALL_SRC=no install_release ${_relpath} ${_destdir}

    rm -f ${_destdir}/boot/kernel/*.symbols

    rm -f ${_destdir}/home

    mkdir -p ${_destdir}/cdrom
    mkdir -p ${_destdir}/img

    touch ${_destdir}/root/.hushlogin

    mkdir ${_destdir}/root/.ssh

    echo_bsdkit_public_key >${_destdir}/root/.ssh/authorized_keys

    local _mfsroot="${_tmp}/mfsroot"

    mkdir -p ${_mfsroot}

    (cd ${_destdir} && pax -r -w -pe rescue ${_mfsroot})

    make_read_only ${_destdir}

    install_setup_runtime ${_destdir} ${_bsdkit} ${_pkgpath}

    mkdir ${_mfsroot}/dev
    mkdir ${_mfsroot}/baseroot

    rm -r -f ${_staging}

    mkdir ${_staging}

    _staging=$(realpath ${_staging})

    (cd ${_destdir} && pax -r -w -pe boot ${_staging})

    gzip ${_staging}/boot/kernel/kernel

    install -m 644 -o root -g wheel ${_bsdkit}/ansible/loader.conf.vendor ${_staging}/boot/loader.conf

    cat >${_staging}/boot/loader.conf.local  <<EOF
geom_uzip_load="YES"

nullfs_load="YES"
tmpfs_load="YES"
unionfs_load="YES"

hw.mca.enabled="0"
hint.atrtc.0.clock="0"

kern.cam.ada.legacy_aliases="0"
kern.cam.boot_delay="10000"

kern.geom.label.disk_ident.enable="0"

mfsroot_load="YES"
mfsroot_type="md_image"
mfsroot_name="/memroot.ufs"

init_path="/rescue/init"
init_shell="/rescue/sh"
init_script="/baseroot.rc"
init_chroot="/baseroot"
EOF

    mkdir -p ${_mfsroot}/etc

    touch ${_mfsroot}/etc/fstab

    install -m 600 -o root -g wheel ${_destdir}/etc/login.conf ${_mfsroot}/etc

    echo "#!/bin/sh" >${_mfsroot}/baseroot.rc
    echo "IMG_PART=/dev/gpt/${IMG_DATA_LABEL}" >>${_mfsroot}/baseroot.rc

    cat >>${_mfsroot}/baseroot.rc  <<"EOF"
BASEROOT_IMG=/base.ufs.uzip

BASEROOT_MP=/baseroot
CDROM_MP=/cdrom
IMG_MP=/img
DEV_MP=/dev
TMP_MP=/tmp

ETC_MP=/etc
ETC_RDWR_MP=/etc.rdwr
ROOT_MP=/root
ROOT_RDWR_MP=/root.rdwr

PATH=/rescue

mount -u -w /

mkdir -p ${BASEROOT_MP}
mkdir -p ${CDROM_MP}
mkdir -p ${ETC_RDWR_MP}
mkdir -p ${ROOT_RDWR_MP}

if [ -e ${IMG_PART} ]; then
    mkdir -p ${IMG_MP}
    fsck -y -t ufs ${IMG_PART}
    mount -r -t ufs ${IMG_PART} ${IMG_MP}
    ISO_MD=$(mdconfig -a -t vnode -f ${IMG_MP}/*.[iI][sS][oO])
    mount -t cd9660 /dev/${ISO_MD} ${CDROM_MP}
else
    mount -t cd9660 /dev/cd0 ${CDROM_MP} >/dev/null 2>&1

    if [ $? -ne 0 ]; then
        mount -t cd9660 /dev/cd1 ${CDROM_MP} >/dev/null 2>&1
    fi

    if [ $? -ne 0 ]; then
        mount -t cd9660 /dev/acd0 ${CDROM_MP} >/dev/null 2>&1
    fi

    if [ $? -ne 0 ]; then
        mount -t cd9660 /dev/acd1 ${CDROM_MP} >/dev/null 2>&1
    fi
fi

mdmfs -P -F ${CDROM_MP}${BASEROOT_IMG} -o ro md.uzip ${BASEROOT_MP}

mount -t devfs devfs ${BASEROOT_MP}${DEV_MP}

mount -t nullfs -o ro ${CDROM_MP} ${BASEROOT_MP}${CDROM_MP}

mdmfs -s 8m  md ${ETC_RDWR_MP}
mdmfs -s 64m md ${ROOT_RDWR_MP}

mount -t unionfs ${ETC_RDWR_MP}  ${BASEROOT_MP}${ETC_MP}
mount -t unionfs ${ROOT_RDWR_MP} ${BASEROOT_MP}${ROOT_MP}

if [ -d ${IMG_MP} ]; then
    mkdir -p ${BASEROOT_MP}${IMG_MP}
    mount -t nullfs -o rw ${IMG_MP} ${BASEROOT_MP}${IMG_MP}
fi

kenv init_shell="/bin/sh"

if kenv bsdkit_ifconfig >/dev/null 2>&1; then
    bsdkit_ifconfig=$(kenv bsdkit_ifconfig)
    set $(ifconfig -l ether)
    _interface=$1
    if [ -n "${_interface}" ]; then
        echo "ifconfig_${_interface}=\"${bsdkit_ifconfig}\"" >> /baseroot/etc/rc.conf
    fi
fi

if kenv bsdkit_defaultrouter >/dev/null 2>&1; then
    bsdkit_defaultrouter=$(kenv bsdkit_defaultrouter)
    echo "defaultrouter=\"${bsdkit_defaultrouter}\"" >> /baseroot/etc/rc.conf
fi

exit 0
EOF

    install -m 644 -o root -g wheel ${_bsdkit}/ansible/vendor.conf ${_destdir}/etc/rc.conf

    makefs ${_staging}/memroot.ufs ${_mfsroot}

    chmod -x ${_staging}/memroot.ufs

    rm -f ${_staging}/memroot.ufs.gz

    gzip ${_staging}/memroot.ufs

    makefs ${_staging}/base.ufs ${_destdir}

    mkuzip -o ${_staging}/base.ufs.uzip ${_staging}/base.ufs

    rm -f ${_staging}/base.ufs

    chmod -x ${_staging}/base.ufs.uzip

    while ! umount -f ${_tmp}; do
        echo "Waiting for ${_tmp} (tmp)"
        sleep 3
    done

    rmdir ${_tmp}

    return 0
}

build_setup_iso() {
    local _iso="$1"
    local _staging="$2"
    local _relpath="$3"
    local _pkgpath="$4"

    if ! which mkisofs >/dev/null  2>&1; then
        error "required command missing (mkisofs)"
        # EX_UNAVAILABLE
        exit 69
    fi

    valid_staging ${_staging}

    if [ ${_relpath} != "none" ]; then
        valid_relpath ${_relpath}
    fi

    if [ ${_pkgpath} != "none" ]; then
        valid_pkgpath ${_pkgpath}
    fi

    local _iso_path="${_iso}.fs"

    mkdir -p ${_iso_path}

    ln -s -f $(realpath ${_staging}/*) ${_iso_path}

    if [ ${_relpath} != "none" ]; then
        ln -s -f $(realpath ${_relpath}) ${_iso_path}/$(basename ${_relpath})
    fi

    if [ ${_pkgpath} != "none" ]; then
        ln -s -f $(realpath ${_pkgpath}) ${_iso_path}/$(basename ${_pkgpath})
    fi

    # From src/release/amd64/mkisoimages.sh

    dd if=/dev/zero of=${_iso_path}/efiboot.img bs=4k count=200
    _efiboot_md_device=$(mdconfig -a -t vnode -f ${_iso_path}/efiboot.img)

    {
        newfs_msdos -F 12 -m 0xF8 /dev/${_efiboot_md_device}

        _efiboot_root=$(mktemp -d /tmp/XXXXXX)

        mount -t msdosfs /dev/${_efiboot_md_device} ${_efiboot_root}
        {
            mkdir -p ${_efiboot_root}/efi/boot
            cp "${_iso_path}/boot/loader.efi" ${_efiboot_root}/efi/boot/bootx64.efi
        }
        umount ${_efiboot_root}

        rmdir ${_efiboot_root}
    }

    mdconfig -d -u ${_efiboot_md_device}

    mkisofs -rational-rock -follow-links -J -V FreeBSD -publisher olgeni.com \
        -eltorito-boot     boot/cdboot -no-emul-boot \
        -eltorito-platform     efi -eltorito-boot efiboot.img -no-emul-boot \
        -o     ${_iso} ${_iso_path}

    for _entry in $(etdump --format shell ${_iso}); do
        eval ${_entry}
        if [ "${et_platform}" = "efi" ]; then
            _esp_start=$(expr ${et_lba} \* 2048)
            _esp_size=$(expr ${et_sectors} \* 512)
            _esp_param="-p efi::${_esp_size}:${_esp_start}"
            break
        fi
    done

    _hybrid_img=$(mktemp /tmp/XXXXXX)

    mkimg -s gpt \
        --capacity   $(stat -f %z ${_iso}) \
        -b   ${_iso_path}/boot/pmbr \
        ${_esp_param} \
        -p   freebsd-boot:=${_iso_path}/boot/isoboot \
        -o   ${_hybrid_img}

    dd if=${_hybrid_img} of=${_iso} bs=32k count=1 conv=notrunc

    rm -f ${_hybrid_img}

    rm -r -f ${_iso_path}

    return 0
}

build_setup_img() {
    local -

    local _iso="$1"
    local _img="$2"

    local _staging=$(mktemp -d /tmp/staging.XXXXXX)

    tar -x -f ${_iso} -C ${_staging} boot memroot.ufs.gz

    cp ${_iso} ${_staging}

    local _ufs=$(mktemp /tmp/ufs.XXXXXX)

    makefs ${_ufs} ${_staging}

    rm -r -f ${_staging}/memroot.ufs.gz ${_staging}

    mkimg -v \
        -s   gpt \
        -b   /boot/pmbr \
        -p   efi:=/boot/boot1.efifat \
        -p   freebsd-boot:=/boot/gptboot \
        -p   freebsd-ufs/${IMG_DATA_LABEL}:=${_ufs} \
        -o   ${_img}

    rm -f ${_ufs}
}

deploy() {
    echo "Running: $@"

    ${BSDKIT_DIR}/bsdkit "$@"
    ${BSDKIT_DIR}/bsdkit start_jail ${DESTDIR}
    ${BSDKIT_DIR}/bsdkit ansible_jail_playbook
}

remote_deploy() {
    local _remote_address=""
    local _remote_port="22"

    while getopts "h:p:" OPT; do
        case $OPT in
            h)
                _remote_address=${OPTARG}
                ;;
            p)
                _remote_port=${OPTARG}
                ;;
            *) ;;
        esac
    done

    shift $((OPTIND - 1))

    [ -n "${_remote_address}" ]
    [ -n "${_remote_port}" ]

    echo "Running: $@"

    local _ansible_root=$(mktemp -d /tmp/ansible_root.XXXXX)
    local _ansible_cfg=${_ansible_root}/ansible.cfg
    local _ansible_hosts=${_ansible_root}/ansible_hosts
    local _ansible_yml=${_ansible_root}/ansible.yml
    local _ansible_key=${_ansible_root}/ansible.key

    echo_bsdkit_private_key >${_ansible_key}
    chmod 600 ${_ansible_key}

    cat >${_ansible_cfg}  <<EOF
[defaults]
inventory = ${_ansible_hosts}
host_key_checking = False

[ssh_connection]
pipelining = True
ssh_args = -o ControlMaster=no -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null
EOF

    cat >${_ansible_hosts}  <<EOF
install connection=ssh ansible_shell_type=sh ansible_python_interpreter=/usr/local/bin/python ansible_ssh_host=${_remote_address} ansible_ssh_port=${_remote_port} ansible_ssh_private_key_file=${_ansible_key}
EOF

    cat >${_ansible_yml}  <<EOF
---
- hosts: install
  connection: ssh
  user: root
  tasks:
    - name: "Install bsdkit"
      synchronize: src=${BSDKIT_DIR} dest=/root/ delete=true archive=true mode=push rsync_opts="--exclude=.git"

    - name: "Run requested bsdkit function"
      shell: $(environment) /root/bsdkit/bsdkit deploy "$@" >> /tmp/bsdkit.log 2>&1

- hosts: install
  connection: ssh
  user: root
  tasks:
    - name: "Remove bsdkit"
      file: path=/root/bsdkit state=absent
EOF

    env ANSIBLE_CONFIG=${_ansible_cfg} \
        SSH_AUTH_SOCK="" \
        BSDKIT_SSH_PUBLIC_KEY="${SSH_PUBLIC_KEY}" \
        ansible-playbook ${_ansible_yml}

    rm -r ${_ansible_root}

    # stop_jail ${_destdir}
}

ansible_local_playbook() {
    ansible-playbook \
        -i localhost, \
        -c local \
        -e ansible_python_interpreter=/usr/local/bin/python3 \
        ${BSDKIT_DIR}/playbook/bsdkit.yml
}

ansible_jail_playbook() {
    local _ansible_root=$(mktemp -d /tmp/ansible_root.XXXXX)
    local _ansible_cfg=${_ansible_root}/ansible.cfg
    local _ansible_hosts=${_ansible_root}/ansible_hosts

    cat >${_ansible_cfg}  <<EOF
[defaults]
inventory = ${_ansible_hosts}
host_key_checking = False

[ssh_connection]
pipelining = True
ssh_args = -o ControlMaster=no -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null
EOF

    cat >${_ansible_hosts}  <<EOF
${JAIL_NAME} ansible_connection=jail ansible_shell_type=sh ansible_python_interpreter=/usr/local/bin/python
EOF

    _bsdkit_interface="$(ifconfig -l -u ether | awk '{ print $1 }')"
    _bsdkit_ifconfig="$(kenv bsdkit_ifconfig 2>/dev/null || :)"
    _bsdkit_defaultrouter="$(kenv bsdkit_defaultrouter 2>/dev/null || :)"

    env ANSIBLE_CONFIG=${_ansible_cfg} \
        SSH_AUTH_SOCK="" \
        BSDKIT_SSH_PUBLIC_KEY="${SSH_PUBLIC_KEY}" \
        BSDKIT_JAIL_PROXY="${JAIL_PROXY}" \
        BSDKIT_INSTALL_JAIL="${INSTALL_JAIL}" \
        BSDKIT_INTERFACE="${_bsdkit_interface}" \
        BSDKIT_IFCONFIG="${_bsdkit_ifconfig}" \
        BSDKIT_DEFAULTROUTER="${_bsdkit_defaultrouter}" \
        ansible-playbook ${BSDKIT_DIR}/playbook/bsdkit.yml

    rm -r ${_ansible_root}
}

osrelease() {
    local _destdir="$1"
    ${_destdir}/bin/freebsd-version -u
}

osreldate() {
    local _destdir="$1"

    if [ -f ${_destdir}/usr/include/sys/param.h ]; then
        awk '/^\#define[[:blank:]]__FreeBSD_version/ { print $3 }' ${_destdir}/usr/include/sys/param.h
    else
        ${_destdir}/usr/bin/uname -K
    fi
}

echo_jail_conf() {
    local _jail_name="$1"

    local _destdir=${JAIL_ROOT}/${_jail_name}

    valid_destdir ${_destdir}

    cat <<EOF
exec.start = "/bin/sh /etc/rc";
exec.stop = "/bin/sh /etc/rc.shutdown";
exec.clean;

mount.devfs;
persist;

sysvsem = new;
sysvshm = new;
sysvmsg = new;

${_jail_name} {
	allow.raw_sockets;
	allow.sysvipc;

	osrelease = "$(osrelease ${_destdir})";
	osreldate = "$(osreldate ${_destdir})";

	path = "${_destdir%/}";
	host.hostname = "\$name";
	host.domainname = "local";
        interface = "$(inet_interface)";
	# ip4.addr = "";
	# mount.fstab = "${_destdir%/}/\$name.fstab";
}
EOF
}

echo_runtime_jail_conf() {
    local _destdir="$1"

    valid_destdir ${_destdir}

    cat >${_jail_conf}  <<EOF
exec.clean;

mount.devfs;
persist;

sysvsem = new;
sysvshm = new;
sysvmsg = new;

${JAIL_NAME} {
	allow.raw_sockets;
	allow.sysvipc;

	osrelease = "$(osrelease ${_destdir})";
	osreldate = "$(osreldate ${_destdir})";

	path = "${_destdir%/}";
	host.hostname = "${JAIL_NAME}";
	host.domainname = "local";
	ip4.addr = "$(inet_address)";
}
EOF
}

shell() {
    local _private_key=$(mktemp /tmp/key.XXXXXX)

    ssh -v -i ${_private_key} "$@" || :

    rm -f ${_private_key}
}

echo_bsdkit_private_key() {
    cat <<EOF
-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEA1HXtR02wnKZhLILRVCWSmJqyMSvjDAAGRK9JQmNSkWTiMRu+
eeta+/JMR6a1PdeOKzLaf9hoySY3w6CMHl4fmCp0SlY9wAz8OVh0vd3SVSubxxhr
/nxdbXV5W8jtvYEMMKq1mz5qr7IW3PRdgDj1h5ldArqmKWekpNBM7wQlZsedrmRP
TW69fXQQZPPOcVlTR+FODR7hGFIW8YHGmgrRo7Ccv/sIFKgkyaesWrwe9z39tO8i
PGZzM32o3tBDDdrw67qZ7Q6J95YLaXNlRZ7RdQ0MJ9AUhg9SFtccqJHWxCD7doQr
dN3G4txv+z5e6GlWS33LTWBO4/aKK7mRGf6LzQIDAQABAoIBAQDNT/iwgx89Anu9
a92mF3kHB9dTNToACrYEAfAlu52662a6VjlH0GzoNEoKo8tZq8izbj1Adn0shUY2
Qhul7QdTIROoEpcx1FqZgCWwpX/w1md/itYx4zTV5kQUsqMsEl0ZWp6NG1A14T++
3lbM5j4/f7EmRgD02jd9Hd56y+Lo4hGirKSI9bZrHX5EnuFnNfLbZa12Po8e/4IR
D67c73psfohTMDMXTajRHJvd7CytH2MfnoXwHbewVZiph6lVEe1DRxDzwmQXEboi
xtTzk78cu7GJVDlt4KjojuumBsy/82Fz/ptbwyr0NnddCRftUVhAPdft+4lhlRGc
yn9C+DzxAoGBAP9PR+O4o/mvc5d5bQsUeagyXskzdwpgbEnsARizfmjC7uVLe5oz
It/IsuQUXwcg5ZIPzvTiHyE3XSUxuz/+uEXYXnXlweE5YILCMR2g60XvwNDQGWXw
bY9e8oO5fs7QYGHfgaezfGMRVcOuU8gWI6pw1wQwv40vUBOm/ZEO2lf/AoGBANUI
/KsBOhK4mEJTY9Bzds42muoEuqdWa/cGkA5cZKMaDg/sb35oTON6jkCTjZrlYdBE
aeaBsw2yJlTCBPHeZ+CW4BOvx9VYwktOmgdhBB6GbzY6qtn5E9YNHoNYQibbD+bt
dsVLQeX6wCu+oSFtKetbzJBAfg+ic1MNia7KIPwzAoGBALcXjQ+jP3z1NSlA/FFA
2sojbVRPIyR+58nPhS3Is3O/sAEiM77uwyjHTntAnLGJBvnLenilnPt+L79Xvdhz
/ISiWYOlRHgXZL4BM6Xy3CbofFeDlWNEm92Aktyib20zhJtL5Th2AFMvgFj3sL/C
GMvHZntr1kMS1hNx41Be3XjTAoGAA3Vp5LzYXIVys2D3NeMqAp8QVMxO23ijuBb7
L8CAQcWihM+p37uBxA+xT4sVuXYP6Hmz3nIsngROawHbYrHhrdvFN4ybCfOu89oK
1iPVFUnJdG/vZiqND+SWojtEl6zmzTD9xKY8I6e2hv9JTmmfTJro706cvVQ92xNV
MOlHL9ECgYBw+gct9S92ZzpdWnVWkuo35sbD165OgBS/FBcZ/mBBlPewvPEl6Eib
nSxJrY3R2CaDt3O1YDRbv/ObGzQgQGnDuPoolsiBtT511tpgtm4WbXEQU/2X71p8
aHEWO0IB4Qpy47FIEiPSCd35Mc1iu6EjuRDAFTrHfVb+dDatWlzDOA==
-----END RSA PRIVATE KEY-----
EOF
}

echo_bsdkit_public_key() {
    cat <<EOF
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDUde1HTbCcpmEsgtFUJZKYmrIxK+MMAAZEr0lCY1KRZOIxG75561r78kxHprU9144rMtp/2GjJJjfDoIweXh+YKnRKVj3ADPw5WHS93dJVK5vHGGv+fF1tdXlbyO29gQwwqrWbPmqvshbc9F2AOPWHmV0CuqYpZ6Sk0EzvBCVmx52uZE9Nbr19dBBk885xWVNH4U4NHuEYUhbxgcaaCtGjsJy/+wgUqCTJp6xavB73Pf207yI8ZnMzfaje0EMN2vDrupntDon3lgtpc2VFntF1DQwn0BSGD1IW1xyokdbEIPt2hCt03cbi3G/7Pl7oaVZLfctNYE7j9ooruZEZ/ovN bsdkit
EOF
}

if ! which ansible-playbook >/dev/null  2>&1; then
    error "required command missing (ansible-playbook)"
    # EX_UNAVAILABLE
    exit 69
fi

if [ $# -gt 0 ]; then
    "$@"
fi

# References:
#   https://wiki.freebsd.org/AvgLiveCD
#   https://wiki.freebsd.org/RootOnZFS/ZFSBootPartition

# Local Variables:
# mode: sh
# sh-indentation: 4
# sh-basic-offset: 4
# End:
