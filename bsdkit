#!/usr/bin/env zsh

set -e -u -o pipefail

autoload throw catch

: ${BSDKIT_DESTDIR:="/mnt"}
: ${BSDKIT_PV_UPDATE_DELAY:="0.1"}
: ${BSDKIT_JAIL_NAME:="bsdkit"}
: ${BSDKIT_PART_SIZE_BOOT:="512K"}
: ${BSDKIT_PART_SIZE_EFI:="8M"}
: ${BSDKIT_PART_SIZE_ROOT:="2G"}
: ${BSDKIT_PART_SIZE_SWAP:="4G"}
: ${BSDKIT_PART_SIZE_TMP:="64M"}
: ${BSDKIT_PART_SIZE_VAR:="4G"}
: ${BSDKIT_LABEL_BOOT:="boot"}
: ${BSDKIT_LABEL_EFI:="efiboot"}
: ${BSDKIT_LABEL_ROOT:="root"}
: ${BSDKIT_LABEL_SWAP:="swap"}
: ${BSDKIT_LABEL_TMP:="tmp"}
: ${BSDKIT_LABEL_USR:="usr"}
: ${BSDKIT_LABEL_VAR:="var"}

: ${BSDKIT_INSTALL_KERNEL:="YES"}
: ${BSDKIT_INSTALL_SRC:="YES"}
: ${BSDKIT_INSTALL_DEBUG:="NO"}
: ${BSDKIT_INSTALL_TESTS:="NO"}

: ${BSDKIT_PROCFS_ENABLE:="YES"}
: ${BSDKIT_FDESCFS_ENABLE:="YES"}

: ${BSDKIT_ZFS_POOL:="rpool"}
: ${BSDKIT_IMG_DATA_LABEL:="2e158b17-5e10-11e5-ac21-080027af0e2a"}
: ${BSDKIT_PKG_LOCKFILE:="/tmp/pkg.lock"}
: ${BSDKIT_PKG_LOCKTIME:="120"}
: ${BSDKIT_FREEBSD_DISTDIR:="/usr/freebsd-dist"}

: ${BSDKIT_ROOT_URL:="https://hub.olgeni.com/FreeBSD"}
: ${BSDKIT_VERSION:="13.1"}
: ${BSDKIT_ARCH:="amd64"}
: ${BSDKIT_TREE:="default"}
: ${BSDKIT_PKGSET:="nox11"}
: ${BSDKIT_SSH_PUBLIC_KEY:=""}
: ${BSDKIT_JAIL_PROXY:=""}

: ${FREEBSD_REL_URL_TEMPLATE:='%%ROOT_URL%%/release-%%VERSION%%-%%ARCH%%'}
: ${FREEBSD_PKG_URL_TEMPLATE:='%%ROOT_URL%%/packages-${ABI}-%%TREE%%-%%PKGSET%%'}

: ${FREEBSD_REL_URL:=''} # initialized by __parse_options
: ${FREEBSD_PKG_URL:=''} # initialized by __parse_options

ZPOOL_CREATE_CMD=(zpool create -o ashift=12)
ZFS_CREATE_CMD=(zfs create)
ZFS_CMD=(zfs)

BSDKIT_SRCDIR=$(realpath "$(dirname "$0")")
BSDKIT_SCRIPT=$(realpath $0)
ANSIBLE_PYTHON_INTERPRETER=/usr/local/bin/python3

if command -v pv > /dev/null 2>&1; then
    CAT_CMD=(pv -i ${BSDKIT_PV_UPDATE_DELAY})
else
    CAT_CMD=/bin/cat
fi

if [ -z ${BSDKIT_PART_SIZE_SWAP} ]; then
    BSDKIT_PART_SIZE_SWAP=0
fi

if [ -z ${BSDKIT_SSH_PUBLIC_KEY} ] && [ -e ~/.ssh/id_rsa.pub ]; then
    BSDKIT_SSH_PUBLIC_KEY="$(cat ~/.ssh/id_rsa.pub)"
fi

error() {
    echo "bsdkit: $*"
    exit 1
}

is_yes() {
    case $1 in
        [Yy][Ee][Ss])
            return 0
            ;;
        [Nn][Oo])
            return 1
            ;;
        *)
            if [[ $1 == <-> ]]; then
                [ $1 -ne 0 ]
            else
                return 2
            fi
            ;;
    esac
}

yes_if() {
    if is_yes $1; then
        echo "YES"
    else
        echo "NO"
    fi
}

is_bios() {
    [ "$(sysctl -n machdep.bootmethod)" = "BIOS" ]
}

is_efi() {
    [ "$(sysctl -n machdep.bootmethod)" = "UEFI" ]
}

__check_freebsd() {
    if [ $(uname) != "FreeBSD" ]; then
        error "only works on FreeBSD."
    fi
}

__check_ansible() {
    if ! command -v ansible-playbook > /dev/null 2>&1; then
        error "required command missing (ansible-playbook)."
        # EX_UNAVAILABLE
        exit 69
    fi
}

__environment() {
    echo \
        BSDKIT_DESTDIR=\"${BSDKIT_DESTDIR}\" \
        BSDKIT_PV_UPDATE_DELAY=\"${BSDKIT_PV_UPDATE_DELAY}\" \
        BSDKIT_JAIL_NAME=\"${BSDKIT_JAIL_NAME}\" \
        BSDKIT_PART_SIZE_BOOT=\"${BSDKIT_PART_SIZE_BOOT}\" \
        BSDKIT_PART_SIZE_EFI=\"${BSDKIT_PART_SIZE_EFI}\" \
        BSDKIT_PART_SIZE_ROOT=\"${BSDKIT_PART_SIZE_ROOT}\" \
        BSDKIT_PART_SIZE_SWAP=\"${BSDKIT_PART_SIZE_SWAP}\" \
        BSDKIT_PART_SIZE_TMP=\"${BSDKIT_PART_SIZE_TMP}\" \
        BSDKIT_PART_SIZE_VAR=\"${BSDKIT_PART_SIZE_VAR}\" \
        BSDKIT_LABEL_BOOT=\"${BSDKIT_LABEL_BOOT}\" \
        BSDKIT_LABEL_EFI=\"${BSDKIT_LABEL_EFI}\" \
        BSDKIT_LABEL_ROOT=\"${BSDKIT_LABEL_ROOT}\" \
        BSDKIT_LABEL_SWAP=\"${BSDKIT_LABEL_SWAP}\" \
        BSDKIT_LABEL_TMP=\"${BSDKIT_LABEL_TMP}\" \
        BSDKIT_LABEL_USR=\"${BSDKIT_LABEL_USR}\" \
        BSDKIT_LABEL_VAR=\"${BSDKIT_LABEL_VAR}\" \
        BSDKIT_INSTALL_KERNEL=\"${BSDKIT_INSTALL_KERNEL}\" \
        BSDKIT_INSTALL_SRC=\"${BSDKIT_INSTALL_SRC}\" \
        BSDKIT_INSTALL_DEBUG=\"${BSDKIT_INSTALL_DEBUG}\" \
        BSDKIT_INSTALL_TESTS=\"${BSDKIT_INSTALL_TESTS}\" \
        BSDKIT_PROCFS_ENABLE=\"${BSDKIT_PROCFS_ENABLE}\" \
        BSDKIT_FDESCFS_ENABLE=\"${BSDKIT_FDESCFS_ENABLE}\" \
        BSDKIT_ZFS_POOL=\"${BSDKIT_ZFS_POOL}\" \
        BSDKIT_IMG_DATA_LABEL=\"${BSDKIT_IMG_DATA_LABEL}\" \
        BSDKIT_PKG_LOCKFILE=\"${BSDKIT_PKG_LOCKFILE}\" \
        BSDKIT_PKG_LOCKTIME=\"${BSDKIT_PKG_LOCKTIME}\" \
        BSDKIT_FREEBSD_DISTDIR=\"${BSDKIT_FREEBSD_DISTDIR}\" \
        BSDKIT_ROOT_URL=\"${BSDKIT_ROOT_URL}\" \
        BSDKIT_JAIL_PROXY=\"${BSDKIT_JAIL_PROXY}\" \
        BSDKIT_VERSION=\"${BSDKIT_VERSION}\" \
        BSDKIT_ARCH=\"${BSDKIT_ARCH}\" \
        BSDKIT_TREE=\"${BSDKIT_TREE}\" \
        BSDKIT_PKGSET=\"${BSDKIT_PKGSET}\" \
        BSDKIT_SSH_PUBLIC_KEY=\"${BSDKIT_SSH_PUBLIC_KEY}\"
}

__parse_url() {
    local _url=$1

    echo ${_url} | sed \
        -e "s|%%ROOT_URL%%|${BSDKIT_ROOT_URL}|g" \
        -e "s|%%VERSION%%|${BSDKIT_VERSION}|g" \
        -e "s|%%ARCH%%|${BSDKIT_ARCH}|g" \
        -e "s|%%TREE%%|${BSDKIT_TREE}|g" \
        -e "s|%%PKGSET%%|${BSDKIT_PKGSET}|g"
}

__local_options() {
    cat << EOF
local BSDKIT_ROOT_URL='${BSDKIT_ROOT_URL}';
local BSDKIT_VERSION='${BSDKIT_VERSION}';
local BSDKIT_ARCH='${BSDKIT_ARCH}';
local BSDKIT_TREE='${BSDKIT_TREE}';
local BSDKIT_PKGSET='${BSDKIT_PKGSET}';
local FREEBSD_REL_URL='${FREEBSD_REL_URL}';
local FREEBSD_PKG_URL='${FREEBSD_PKG_URL}';
EOF
}

__parse_options() {
    zparseopts -D -E -a _opts -A _opts_args r: v: a: p: z:

    local _option

    for _option in ${(@k)_opts_args}; do
        case ${_option} in
            -r)
                BSDKIT_ROOT_URL=${_opts_args[-r]}
                ;;
            -v)
                BSDKIT_VERSION=${_opts_args[-v]}
                ;;
            -a)
                BSDKIT_ARCH=${_opts_args[-a]}
                ;;
            -p)
                BSDKIT_TREE=${_opts_args[-p]}
                ;;
            -z)
                BSDKIT_PKGSET=${_opts_args[-z]}
                ;;
            *)
                ;;
        esac
    done

    FREEBSD_REL_URL=$(__parse_url ${FREEBSD_REL_URL_TEMPLATE})
    FREEBSD_PKG_URL=$(__parse_url ${FREEBSD_PKG_URL_TEMPLATE})

    cat << EOF
BSDKIT_ROOT_URL='${BSDKIT_ROOT_URL}';
BSDKIT_VERSION='${BSDKIT_VERSION}';
BSDKIT_ARCH='${BSDKIT_ARCH}';
BSDKIT_TREE='${BSDKIT_TREE}';
BSDKIT_PKGSET='${BSDKIT_PKGSET}';
FREEBSD_REL_URL='${FREEBSD_REL_URL}';
FREEBSD_PKG_URL='${FREEBSD_PKG_URL}';
set -- $*;
EOF
}

__valid_url() {
    local _url=$1

    case ${_url} in
        http://*)
            return 0
            ;;
        https://*)
            return 0
            ;;
        ftp://*)
            return 0
            ;;
        file://*)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

__check_bsdkit_runtime() {
    mount -p | grep "/baseroot" > /dev/null 2>&1
}

__valid_relpath() {
    local _relpath=$1

    __valid_url ${_relpath} && return 0

    [ -d ${_relpath} ]
    [ -f ${_relpath}/base.txz ]

    return 0
}

__valid_pkgpath() {
    local _pkgpath=$1

    __valid_url ${_pkgpath} && return 0

    [ -d ${_pkgpath} ]
    [ -f ${_pkgpath}/packagesite.txz ]
}

__valid_staging() {
    local _staging=$1

    [ -f ${_staging}/base.ufs.uzip ]
    [ -d ${_staging}/boot ]
    [ -f ${_staging}/memroot.ufs.gz ]
}

__valid_destdir() {
    local _destdir=$1

    [ -d ${_destdir} ] && [ ${_destdir} != "/" ] && [ -f ${_destdir}/bin/sh ]
}

__valid_bsdkit() {
    local _bsdkit=$1

    [ -d ${_bsdkit} ] && [ -f ${_bsdkit}/bsdkit ]
}

__valid_class() {
    local _class=$1

    case ${_class} in
        single)
            return 0
            ;;
        multi)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

__gmirror_configure() {
    local _mirror=$1

    shift

    [ -n ${_mirror} ]

    local _device=$1

    shift

    [ -n ${_device} ]

    gmirror label -v ${_mirror} ${_device}

    for _device in "$@"; do
        gmirror insert ${_mirror} ${_device}
    done

    return 0
}

__install_efi_loader() {
    local _device=$1

    # FreeBSD < 13.0: gpart bootcode -p /boot/boot1.efifat -i ${_p} ${_device}

    newfs_msdos -L efi -F 16 -c 2 ${_device}

    mkdir -p /tmp/efi
    mount -t msdos ${_device} /tmp/efi
    mkdir -p /tmp/efi/efi/boot
    install /boot/loader.efi /tmp/efi/efi/boot/bootx64.efi
    umount /tmp/efi
}

__gpt_ufs_partition_multi() {
    local _destdir=$1
    local _device=$2

    [ -d ${_destdir} ]
    [ -n ${_device} ]
    [ -e /dev/${_device} ]

    gpart destroy -F ${_device} 2> /dev/null || :
    gpart create -s gpt ${_device}

    gpart bootcode -b /boot/pmbr ${_device}

    local _p=1

    gpart add -a 4k -i ${_p} -s ${BSDKIT_PART_SIZE_BOOT} -t freebsd-boot -l ${BSDKIT_LABEL_BOOT} ${_device}
    gpart bootcode -p /boot/gptboot -i ${_p} ${_device}
    _p=$((_p + 1))

    gpart add -a 4k -i ${_p} -s ${BSDKIT_PART_SIZE_EFI} -t efi -l ${BSDKIT_LABEL_EFI} ${_device}
    __install_efi_loader /dev/${_device}p${_p}
    _p=$((_p + 1))

    if __has_swap; then
        gpart add -a 4k -i ${_p} -s ${BSDKIT_PART_SIZE_SWAP} -t freebsd-swap -l ${BSDKIT_LABEL_SWAP} ${_device}
        _p=$((_p + 1))
        swapon /dev/gpt/${BSDKIT_LABEL_SWAP}
    fi

    gpart add -a 4k -i ${_p} -s ${BSDKIT_PART_SIZE_ROOT} -t freebsd-ufs -l ${BSDKIT_LABEL_ROOT} ${_device}
    _p=$((_p + 1))
    gpart add -a 4k -i ${_p} -s ${BSDKIT_PART_SIZE_TMP} -t freebsd-ufs -l ${BSDKIT_LABEL_TMP} ${_device}
    _p=$((_p + 1))
    gpart add -a 4k -i ${_p} -s ${BSDKIT_PART_SIZE_VAR} -t freebsd-ufs -l ${BSDKIT_LABEL_VAR} ${_device}
    _p=$((_p + 1))
    gpart add -a 4k -i ${_p} -t freebsd-ufs -l ${BSDKIT_LABEL_USR} ${_device}
    _p=$((_p + 1))

    # FIXME: use -j

    newfs -L ${BSDKIT_LABEL_ROOT} /dev/gpt/${BSDKIT_LABEL_ROOT}
    newfs -U -L ${BSDKIT_LABEL_TMP} -n /dev/gpt/${BSDKIT_LABEL_TMP}
    newfs -U -L ${BSDKIT_LABEL_VAR} /dev/gpt/${BSDKIT_LABEL_VAR}
    newfs -U -L ${BSDKIT_LABEL_USR} /dev/gpt/${BSDKIT_LABEL_USR}

    mount -o async,noatime /dev/gpt/${BSDKIT_LABEL_ROOT} ${_destdir}

    mkdir -p ${_destdir}/cdrom
    mkdir -p ${_destdir}/etc
    mkdir -p ${_destdir}/tmp
    mkdir -p ${_destdir}/usr
    mkdir -p ${_destdir}/var

    if __check_bsdkit_runtime; then
        mount -t nullfs /cdrom ${_destdir}/cdrom
    fi

    mount -o async,noatime /dev/gpt/${BSDKIT_LABEL_VAR} ${_destdir}/var
    mount -o async,noatime /dev/gpt/${BSDKIT_LABEL_TMP} ${_destdir}/tmp
    mount -o async,noatime /dev/gpt/${BSDKIT_LABEL_USR} ${_destdir}/usr

    touch ${_destdir}/etc/fstab

    {
        echo "/dev/ufs/${BSDKIT_LABEL_ROOT} /    ufs rw 1 1"
        echo "/dev/ufs/${BSDKIT_LABEL_VAR}  /var ufs rw 2 2"
        echo "/dev/ufs/${BSDKIT_LABEL_TMP}  /tmp ufs rw 2 2"
        echo "/dev/ufs/${BSDKIT_LABEL_USR}  /usr ufs rw 2 2"
    } >> ${_destdir}/etc/fstab

    __link_home ${_destdir}

    return 0
}

__gpt_ufs_partition_single() {
    local _destdir=$1
    local _device=$2

    [ -d ${_destdir} ]
    [ -n ${_device} ]
    [ -e /dev/${_device} ]

    gpart destroy -F ${_device} 2> /dev/null || :
    gpart create -s gpt ${_device}

    gpart bootcode -b /boot/pmbr ${_device}

    local _p=1

    gpart add -a 4k -i ${_p} -s ${BSDKIT_PART_SIZE_BOOT} -t freebsd-boot -l ${BSDKIT_LABEL_BOOT} ${_device}
    gpart bootcode -p /boot/gptboot -i ${_p} ${_device}
    _p=$((_p + 1))

    gpart add -a 4k -i ${_p} -s ${BSDKIT_PART_SIZE_EFI} -t efi -l ${BSDKIT_LABEL_EFI} ${_device}
    __install_efi_loader /dev/${_device}p${_p}
    _p=$((_p + 1))

    gpart add -a 4k -i ${_p} -t freebsd-ufs -l ${BSDKIT_LABEL_ROOT} ${_device}
    _p=$((_p + 1))

    # FIXME: use -j

    newfs -U -L ${BSDKIT_LABEL_ROOT} -n /dev/gpt/${BSDKIT_LABEL_ROOT}

    mount -o async,noatime /dev/gpt/${BSDKIT_LABEL_ROOT} ${_destdir}

    mkdir -p ${_destdir}/cdrom
    mkdir -p ${_destdir}/etc

    if __check_bsdkit_runtime; then
        mount -t nullfs /cdrom ${_destdir}/cdrom
    fi

    touch ${_destdir}/etc/fstab

    echo "/dev/ufs/${BSDKIT_LABEL_ROOT} / ufs rw 1 1" >> ${_destdir}/etc/fstab

    __link_home ${_destdir}

    return 0
}

__mbr_ufs_partition_multi() {
    local _destdir=$1
    local _device=$2

    [ -d ${_destdir} ]
    [ -n ${_device} ]
    [ -e /dev/${_device} ]

    # FIXME: refactor

    gpart destroy -F ${_device} 2> /dev/null || :
    gpart create -s mbr ${_device}
    gpart add -a 4k -i 1 -t freebsd ${_device}
    gpart set -a active -i 1 ${_device}

    gpart destroy -F ${_device}s1 2> /dev/null || :
    gpart create -s BSD ${_device}s1

    gpart bootcode -b /boot/mbr ${_device}
    gpart bootcode -b /boot/boot ${_device}s1

    # FIXME: refactor (end)

    gpart add -a 4k -i 1 -s ${BSDKIT_PART_SIZE_ROOT} -t freebsd-ufs ${_device}s1 # a

    if __has_swap; then
        gpart add -a 4k -i 2 -s ${BSDKIT_PART_SIZE_SWAP} -t freebsd-swap ${_device}s1 # b
        swapon /dev/${_device}s1b
    fi

    # reserved partition c
    gpart add -a 4k -i 4 -s ${BSDKIT_PART_SIZE_TMP} -t freebsd-ufs ${_device}s1 # d
    gpart add -a 4k -i 5 -s ${BSDKIT_PART_SIZE_VAR} -t freebsd-ufs ${_device}s1 # e
    gpart add -a 4k -i 6 -t freebsd-ufs ${_device}s1                            # f

    # FIXME: use -j

    newfs -L ${BSDKIT_LABEL_ROOT} -n /dev/${_device}s1a
    newfs -U -L ${BSDKIT_LABEL_TMP} -n /dev/${_device}s1d
    newfs -U -L ${BSDKIT_LABEL_VAR} /dev/${_device}s1e
    newfs -U -L ${BSDKIT_LABEL_USR} /dev/${_device}s1f

    glabel label -v swap /dev/${_device}s1b

    mount -o async,noatime /dev/ufs/${BSDKIT_LABEL_ROOT} ${_destdir}

    mkdir -p ${_destdir}/cdrom
    mkdir -p ${_destdir}/etc
    mkdir -p ${_destdir}/tmp
    mkdir -p ${_destdir}/usr
    mkdir -p ${_destdir}/var

    if __check_bsdkit_runtime; then
        mount -t nullfs /cdrom ${_destdir}/cdrom
    fi

    mount -o async,noatime /dev/ufs/${BSDKIT_LABEL_VAR} ${_destdir}/var
    mount -o async,noatime /dev/ufs/${BSDKIT_LABEL_TMP} ${_destdir}/tmp
    mount -o async,noatime /dev/ufs/${BSDKIT_LABEL_USR} ${_destdir}/usr

    touch ${_destdir}/etc/fstab

    {
        echo "/dev/ufs/${BSDKIT_LABEL_ROOT} /    ufs rw 1 1"
        echo "/dev/ufs/${BSDKIT_LABEL_VAR}  /var ufs rw 2 2"
        echo "/dev/ufs/${BSDKIT_LABEL_TMP}  /tmp ufs rw 2 2"
        echo "/dev/ufs/${BSDKIT_LABEL_USR}  /usr ufs rw 2 2"
    } >> ${_destdir}/etc/fstab

    __link_home ${_destdir}

    return 0
}

__mbr_ufs_partition_single() {
    local _destdir=$1
    local _device=$2

    [ -d ${_destdir} ]
    [ -n ${_device} ]
    [ -e /dev/${_device} ]

    # FIXME: refactor

    gpart destroy -F ${_device} 2> /dev/null || :
    gpart create -s mbr ${_device}
    gpart add -a 4k -i 1 -t freebsd ${_device}
    gpart set -a active -i 1 ${_device}

    gpart destroy -F ${_device}s1 2> /dev/null || :
    gpart create -s BSD ${_device}s1

    gpart bootcode -b /boot/mbr ${_device}
    gpart bootcode -b /boot/boot ${_device}s1

    # FIXME: refactor (end)

    gpart add -a 4k -i 1 -t freebsd-ufs ${_device}s1 # a

    # FIXME: use -j

    newfs -U -L ${BSDKIT_LABEL_ROOT} /dev/${_device}s1a

    mount -o async,noatime /dev/ufs/${BSDKIT_LABEL_ROOT} ${_destdir}

    mkdir -p ${_destdir}/cdrom
    mkdir -p ${_destdir}/etc

    if __check_bsdkit_runtime; then
        mount -t nullfs /cdrom ${_destdir}/cdrom
    fi

    touch ${_destdir}/etc/fstab

    {
        echo "/dev/ufs/${BSDKIT_LABEL_ROOT} / ufs rw 1 1"
    } >> ${_destdir}/etc/fstab

    __link_home ${_destdir}

    return 0
}

__zfs_create_pool() {
    local _destdir=$1

    shift 1

    local _device
    local _devices

    _devices=($*)

    [ -d ${_destdir} ]

    sysctl -q kern.geom.debugflags=0x10

    for _device in ${_devices}; do
        gpart destroy -F ${_device} 2> /dev/null || :

        dd if=/boot/zfsboot of=/dev/${_device} count=1
        dd if=/boot/zfsboot of=/dev/${_device} iseek=1 oseek=1024
    done

    sysctl -q kern.geom.debugflags=0x00

    local _options=(-m none -o altroot=${_destdir})
    local _device

    for _device in ${_devices}; do
        zpool labelclear -f ${_device} 2> /dev/null || :
    done

    case ${#_devices} in
        1)
            ${ZPOOL_CREATE_CMD} \
                ${_options} ${BSDKIT_ZFS_POOL} \
                ${_devices[1]}
            ;;
        2)
            ${ZPOOL_CREATE_CMD} \
                ${_options} ${BSDKIT_ZFS_POOL} \
                mirror ${_devices[1]} ${_devices[2]}
            ;;
        3)
            ${ZPOOL_CREATE_CMD} \
                ${_options} ${BSDKIT_ZFS_POOL} \
                raidz1 ${_devices[1]} ${_devices[2]} ${_devices[3]}
            ;;
        *)
            error "unsupported number of devices in pool (__zfs_create_pool)."
            ;;
    esac

    if [ $(uname -K) -ge 1300000 ]; then
        ${ZFS_CMD} set xattr=sa ${BSDKIT_ZFS_POOL}
    fi

    if __has_swap; then
        ${ZFS_CREATE_CMD} \
            -o checksum=off \
            -o compression=off \
            -o dedup=off \
            -o sync=disabled \
            -o primarycache=none \
            -o org.freebsd:swap=on \
            -V ${BSDKIT_PART_SIZE_SWAP} \
            ${BSDKIT_ZFS_POOL}/swap
    fi

    return 0
}

__zfs_create_gpt_pool() {
    local _destdir=$1

    shift 1

    local _devices

    _devices=($*)

    [ -d ${_destdir} ]

    local _device_index=0

    local _pool_partition=0

    for _device in ${_devices}; do
        gpart destroy -F ${_device} 2> /dev/null || :
        gpart create -s gpt ${_device}

        local _p=1

        gpart add -a 4k -i ${_p} -s ${BSDKIT_PART_SIZE_BOOT} -t freebsd-boot -l ${BSDKIT_LABEL_BOOT}${_device_index} ${_device}
        gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i ${_p} ${_device}
        _p=$((_p + 1))

        gpart add -a 4k -i ${_p} -s ${BSDKIT_PART_SIZE_EFI} -t efi -l ${BSDKIT_LABEL_EFI}${_device_index} ${_device}
        __install_efi_loader /dev/${_device}p${_p}
        _p=$((_p + 1))

        if __has_swap; then
            gpart add -a 4k -i ${_p} -s ${BSDKIT_PART_SIZE_SWAP} -t freebsd-swap -l ${BSDKIT_LABEL_SWAP}${_device_index} ${_device}
            _p=$((_p + 1))
            swapon /dev/gpt/${BSDKIT_LABEL_SWAP}${_device_index}
        fi

        gpart add -a 4k -i ${_p} -t freebsd-zfs -l pool${_device_index} ${_device}
        gpart set -a bootme -i ${_p} ${_device}
        _pool_partition=${_p}
        _p=$((_p + 1))

        _device_index=$((_device_index + 1))
    done

    local _options=(-f -m none -o altroot=${_destdir})

    local _suffix="p${_pool_partition}"

    local _device

    for _device in ${_devices}; do
        zpool labelclear -f ${_device}${_suffix} 2> /dev/null || :
    done

    case ${#_devices} in
        1)
            ${ZPOOL_CREATE_CMD} \
                ${_options} ${BSDKIT_ZFS_POOL} \
                ${_devices[1]}${_suffix}
            ;;
        2)
            ${ZPOOL_CREATE_CMD} \
                ${_options} ${BSDKIT_ZFS_POOL} \
                mirror ${_devices[1]}${_suffix} ${_devices[2]}${_suffix}
            ;;
        3)
            ${ZPOOL_CREATE_CMD} \
                ${_options} ${BSDKIT_ZFS_POOL} \
                raidz1 ${_devices[1]}${_suffix} ${_devices[2]}${_suffix} ${_devices[3]}${_suffix}
            ;;
        *)
            error "unsupported number of devices in pool (__zfs_create_gpt_pool)."
            ;;
    esac

    if [ $(uname -K) -ge 1300000 ]; then
        ${ZFS_CMD} set xattr=sa ${BSDKIT_ZFS_POOL}
    fi

    return 0
}

__zfs_create_mbr_pool() {
    local _destdir=$1

    shift 1

    local _devices

    _devices=($*)

    [ -d ${_destdir} ]

    local _device

    for _device in ${_devices}; do
        # FIXME: refactor

        gpart destroy -F ${_device} 2> /dev/null || :
        gpart create -s mbr ${_device}
        gpart add -a 4k -i 1 -t freebsd ${_device}
        gpart set -a active -i 1 ${_device}
        gpart destroy -F ${_device}s1 2> /dev/null || :
        gpart create -s BSD ${_device}s1
        gpart bootcode -b /boot/mbr ${_device}

        local _autorootsize="$(($(diskinfo ${_device} | cut -f 3) / 1024 / 1024 - ${BSDKIT_PART_SIZE_SWAP%G} * 1024))"

        # do not align partitions here
        gpart add -a 4k -i 1 -s ${_autorootsize}M -t freebsd-zfs ${_device}s1 # a

        if __has_swap; then
            gpart add -a 4k -i 2 -t freebsd-swap ${_device}s1 # b
            swapon /dev/${_device}s1b
        fi

        dd if=/boot/zfsboot of=/dev/${_device}s1a count=1
        dd if=/boot/zfsboot of=/dev/${_device}s1a iseek=1 oseek=1024
    done

    local _options=(-f -m none -o altroot=${_destdir})

    local _suffix="s1a"

    local _device

    for _device in ${_device}; do
        zpool labelclear -f ${_device}${_suffix} 2> /dev/null || :
    done

    case ${#_devices} in
        1)
            ${ZPOOL_CREATE_CMD} \
                ${_options} ${BSDKIT_ZFS_POOL} \
                ${_devices[1]}${_suffix}
            ;;
        2)
            ${ZPOOL_CREATE_CMD} \
                ${_options} ${BSDKIT_ZFS_POOL} \
                mirror ${_devices[1]}${_suffix} ${_devices[2]}${_suffix}
            ;;
        3)
            ${ZPOOL_CREATE_CMD} \
                ${_options} ${BSDKIT_ZFS_POOL} \
                raidz1 ${_devices[1]}${_suffix} ${_devices[2]}${_suffix} ${_devices[3]}${_suffix}
            ;;
        *)
            error "unsupported number of devices in pool (__zfs_create_mbr_pool)."
            ;;
    esac

    if [ $(uname -K) -ge 1300000 ]; then
        ${ZFS_CMD} set xattr=sa ${BSDKIT_ZFS_POOL}
    fi

    return 0
}

__zfs_create_zpool_cache() {
    local _destdir=$1

    [ -d ${_destdir} ]

    zpool set cachefile=${_destdir}/etc/zfs/zpool.cache ${BSDKIT_ZFS_POOL}
}

__zfs_compression() {
    if [ $(uname -K) -ge 1300000 ]; then
        echo zstd
    else
        echo lz4
    fi
}

__zfs_create_fs() {
    local _destdir=$1

    [ -d ${_destdir} ]

    zfs set atime=off ${BSDKIT_ZFS_POOL}

    ${ZFS_CREATE_CMD} -o mountpoint=none -o canmount=noauto ${BSDKIT_ZFS_POOL}/ROOT
    ${ZFS_CREATE_CMD} -o mountpoint=/ -o canmount=noauto ${BSDKIT_ZFS_POOL}/ROOT/default

    zfs mount ${BSDKIT_ZFS_POOL}/ROOT/default

    ${ZFS_CREATE_CMD} -o mountpoint=/tmp -o setuid=off ${BSDKIT_ZFS_POOL}/tmp
    ${ZFS_CREATE_CMD} -o mountpoint=/jails ${BSDKIT_ZFS_POOL}/jails
    ${ZFS_CREATE_CMD} -o mountpoint=/usr -o canmount=off ${BSDKIT_ZFS_POOL}/usr
    ${ZFS_CREATE_CMD} -o mountpoint=/var -o canmount=off ${BSDKIT_ZFS_POOL}/var

    ${ZFS_CREATE_CMD} -o canmount=off ${BSDKIT_ZFS_POOL}/usr/local
    ${ZFS_CREATE_CMD} -o canmount=off ${BSDKIT_ZFS_POOL}/var/db

    ${ZFS_CREATE_CMD} -o compression=$(__zfs_compression) ${BSDKIT_ZFS_POOL}/usr/src
    ${ZFS_CREATE_CMD} -o compression=$(__zfs_compression) ${BSDKIT_ZFS_POOL}/usr/obj
    ${ZFS_CREATE_CMD} -o compression=$(__zfs_compression) ${BSDKIT_ZFS_POOL}/usr/ports

    ${ZFS_CREATE_CMD} -o exec=off -o compression=$(__zfs_compression) ${BSDKIT_ZFS_POOL}/var/audit
    ${ZFS_CREATE_CMD} -o exec=off -o compression=$(__zfs_compression) ${BSDKIT_ZFS_POOL}/var/crash
    ${ZFS_CREATE_CMD} -o exec=off -o compression=$(__zfs_compression) ${BSDKIT_ZFS_POOL}/var/log
    ${ZFS_CREATE_CMD} -o exec=off -o compression=$(__zfs_compression) -o atime=on ${BSDKIT_ZFS_POOL}/var/mail

    ${ZFS_CREATE_CMD} -o setuid=off ${BSDKIT_ZFS_POOL}/var/tmp
    ${ZFS_CREATE_CMD} -o setuid=off ${BSDKIT_ZFS_POOL}/usr/home

    # These cannot be created from within the chroot (wrong mountpoint). Properties will be set by Ansible.
    ${ZFS_CREATE_CMD} ${BSDKIT_ZFS_POOL}/var/db/postgres
    ${ZFS_CREATE_CMD} ${BSDKIT_ZFS_POOL}/var/db/mysql

    mkdir -p ${_destdir}/altroot
    mkdir -p ${_destdir}/boot
    mkdir -p ${_destdir}/cdrom
    mkdir -p ${_destdir}/etc

    if __check_bsdkit_runtime; then
        mount -t nullfs /cdrom ${_destdir}/cdrom
    fi

    touch ${_destdir}/etc/fstab

    __link_home ${_destdir}

    zpool set bootfs=${BSDKIT_ZFS_POOL}/ROOT/default ${BSDKIT_ZFS_POOL}

    return 0
}

__link_home() {
    local _destdir=$1

    mkdir -p ${_destdir}/usr/home
    ln -s -f usr/home ${_destdir}/home
}

__swap_setup() {
    local _destdir=$1

    __valid_destdir ${_destdir}

    local _swap

    for _swap in $(find /dev | grep -E "(gpt|label)/swap" | rs 1 0); do
        echo "${_swap} none swap sw 0 0" >> ${_destdir}/etc/fstab
    done

    return 0
}

__procfs_setup() {
    if ! is_yes ${BSDKIT_PROCFS_ENABLE}; then
        return 0
    fi

    local _destdir=$1

    [ -d ${_destdir} ]

    echo "proc /proc procfs rw 0 0" >> ${_destdir}/etc/fstab

    return 0
}

__fdescfs_setup() {
    if ! is_yes ${BSDKIT_FDESCFS_ENABLE}; then
        return 0
    fi

    local _destdir=$1

    [ -d ${_destdir} ]

    echo "fdescfs /dev/fd fdescfs rw 0 0" >> ${_destdir}/etc/fstab

    return 0
}

__has_swap() {
    [ ${BSDKIT_PART_SIZE_SWAP} = 0 ] && return 1

    return 0
}

__finalize_fstab() {
    local _destdir=$1

    __valid_destdir ${_destdir}

    local _fstab=${_destdir}/etc/fstab

    echo "#linprocfs /compat/linux/proc linprocfs rw 0 0" >> ${_destdir}/etc/fstab
    echo "#tmpfs /compat/linux/dev/shm tmpfs rw,mode=1777 0 0" >> ${_destdir}/etc/fstab
    echo "#md0 none swap sw,late,file=/var/swap 0 0" >> ${_destdir}/etc/fstab

    column -t < ${_fstab} | sort > ${_fstab}.0

    install -m 0644 -o root -g wheel ${_fstab}.0 ${_fstab}

    rm ${_fstab}.0
}

__fetch_release() {
    local _relpath=$1
    local _local_relpath=$2

    fetch -q -o ${_local_relpath}/MANIFEST ${_relpath}/MANIFEST

    cat ${_local_relpath}/MANIFEST | while read _filename _sha256 _size _package _desc _enable; do
        local _fetch="NO"

        case ${_package} in
            kernel_dbg)
                if is_yes ${BSDKIT_INSTALL_KERNEL} && is_yes ${BSDKIT_INSTALL_DEBUG}; then
                    _fetch="YES"
                fi
                ;;

            base_dbg)
                if is_yes ${BSDKIT_INSTALL_DEBUG}; then
                    _fetch="YES"
                fi
                ;;

            lib32_dbg)
                if is_yes ${BSDKIT_INSTALL_DEBUG}; then
                    _fetch="YES"
                fi
                ;;

            kernel)
                if is_yes ${BSDKIT_INSTALL_KERNEL}; then
                    _fetch="YES"
                fi
                ;;

            base)
                _fetch="YES"
                ;;

            lib32)
                _fetch="YES"
                ;;

            src)
                if is_yes ${BSDKIT_INSTALL_SRC}; then
                    _fetch="YES"
                fi
                ;;

            tests)
                if is_yes ${BSDKIT_INSTALL_TESTS}; then
                    _fetch="YES"
                fi
                ;;

            ports) ;;

            *) ;;
        esac

        if is_yes ${_fetch}; then
            local _sha256_local=""

            if [ -f ${_local_relpath}/${_filename} ]; then
                echo "Checking: ${_filename}"
                _sha256_local=$(${CAT_CMD} ${_local_relpath}/${_filename} | sha256 -q)
            else
                _sha256_local="0"
            fi

            while [ ${_sha256} != ${_sha256_local} ]; do
                fetch -o ${_local_relpath}/${_filename} ${_relpath}/${_filename}
                echo "Checking: ${_filename}"
                _sha256_local=$(${CAT_CMD} ${_local_relpath}/${_filename} | sha256 -q)
            done
        fi
    done
}

make_thin_jail() {
    local _destdir=$1

    _destdir=$(realpath ${_destdir})

    [ ${_destdir} != "/" ] || error "invalid destination directory ('/')"
    [ -d ${_destdir} ] || error "directory not found: ${_destdir}"
    [ -d ${_destdir}/etc/rc.d ] || error "invalid destination directory (missing rc.d)"

    local _directory_list=(
        "bin" "."
        "boot" "."
        "lib" "."
        "libexec" "."
        "rescue" "."
        "sbin" "."
        "usr/bin" ".."
        "usr/include" ".."
        "usr/lib" ".."
        "usr/lib32" ".."
        "usr/libdata" ".."
        "usr/libexec" ".."
        "usr/sbin" ".."
        "usr/share" "..")

    if is_yes ${BSDKIT_INSTALL_SRC}; then
        _directory_list+=("usr/src" "..")
    else
        rm -r -f ${_destdir}/usr/src
    fi

    if is_yes ${BSDKIT_INSTALL_TESTS}; then
        _directory_list+=("usr/tests" "..")
    else
        rm -r -f ${_destdir}/usr/tests
    fi

    local _directory

    for _directory _prefix in ${_directory_list}; do
        if [ -d ${_destdir}/${_directory} ]; then
            rm -r -f ${_destdir}/${_directory} > /dev/null 2>&1 || :
            chflags -R noschg ${_destdir}/${_directory} > /dev/null 2>&1 || :
            rm -r -f ${_destdir}/${_directory}
        fi

        echo "${_directory}"

        if [ -L ${_destdir}/${_directory} ]; then
            rm -f ${_destdir}/${_directory}
        fi

        ln -s -f ${_prefix}/.base/${_directory} ${_destdir}/${_directory}
    done

    mkdir -p ${_destdir}/.base
}

make_full_jail() {
    local _srcdir=$1
    local _destdir=$2

    _destdir=$(realpath ${_destdir})

    [ ${_destdir} != "/" ] || error "invalid destination directory ('/')"
    [ -d ${_destdir} ] || error "directory not found: ${_destdir}"
    [ -d ${_destdir}/etc/rc.d ] || error "invalid destination directory (missing rc.d)"

    [ -d ${_srcdir} ] || error "directory not found: ${_srcdir}"
    [ -e ${_srcdir}/bin/sh ] || error "invalid source directory (missing /bin/sh)"
    [ -d ${_destdir}/.base ] || error "directory not found: ${_destdir}/.base"

    local _nullfs

    mount -p -t nullfs | cut -w -f 2 | while read _nullfs; do
        if [ ${_nullfs} = ${_destdir}/.base ]; then
            umount -f ${_destdir}/.base
        fi
    done

    local _directory_list=(
        "bin"
        "boot"
        "lib"
        "libexec"
        "rescue"
        "sbin"
        "usr/bin"
        "usr/include"
        "usr/lib"
        "usr/lib32"
        "usr/libdata"
        "usr/libexec"
        "usr/sbin"
        "usr/share")

    if is_yes ${BSDKIT_INSTALL_SRC}; then
        _directory_list+="usr/src"
    else
        rm -f ${_destdir}/usr/src
    fi

    if is_yes ${BSDKIT_INSTALL_TESTS}; then
        _directory_list+="usr/tests"
    else
        rm -f ${_destdir}/usr/tests
    fi

    pushd -q

    local _directory

    for _directory in ${_directory_list}; do
        if [ -L ${_destdir}/${_directory} ] || [ -f ${_destdir}/${_directory} ]; then
            rm -f ${_destdir}/${_directory}
        fi

        mkdir -p ${_destdir}/${_directory}

        echo -n "${_directory}: "

        cd ${_srcdir}/${_directory} && find . | cpio -pdu ${_destdir}/${_directory}
    done

    popd -q

    __run_mtree ${_destdir}

    [ -d ${_destdir}/.base ] && rmdir ${_destdir}/.base
}

__install_release() {
    local _opts _opts_args

    zparseopts -F -D -E -a _opts -A _opts_args -thin

    local _thin
    _thin=$(yes_if ${_opts[(Ie)--thin]})

    local _relpath=$1
    local _destdir=$2

    __valid_relpath ${_relpath}

    [ -d ${_destdir} ]
    [ ${_destdir} != "/" ]

    local _delete="NO"

    if __valid_url ${_relpath}; then
        local _local_relpath_root
        local _local_relpath

        local _release_tag=${BSDKIT_VERSION}-${BSDKIT_ARCH}

        _local_relpath_root=${BSDKIT_FREEBSD_DISTDIR}
        _local_relpath=${_local_relpath_root}/${_release_tag}

        if ! mkdir -p ${_local_relpath}; then
            _delete="YES"

            _local_relpath_root=${_destdir}/${BSDKIT_FREEBSD_DISTDIR}
            _local_relpath=${_local_relpath_root}/${_release_tag}

            echo "Using ${_local_relpath_root}"

            mkdir -p ${_local_relpath}
        fi

        __fetch_release ${_relpath} ${_local_relpath}

        _relpath=${_local_relpath}
    fi

    cat ${_relpath}/MANIFEST | while read _filename _sha256 _size _package _desc _enable; do
        local _extract="NO"
        local _options=()

        if is_yes ${_thin}; then
            _options+="--exclude ./bin"
            _options+="--exclude ./boot"
            _options+="--exclude ./lib"
            _options+="--exclude ./libexec"
            _options+="--exclude ./rescue"
            _options+="--exclude ./sbin"
            _options+="--exclude ./usr/bin"
            _options+="--exclude ./usr/include"
            _options+="--exclude ./usr/lib"
            _options+="--exclude ./usr/lib32"
            _options+="--exclude ./usr/libdata"
            _options+="--exclude ./usr/libexec"
            _options+="--exclude ./usr/sbin"
            _options+="--exclude ./usr/share"
            _options+="--exclude ./usr/src"
            _options+="--exclude ./usr/tests"
        fi

        if ! is_yes ${BSDKIT_INSTALL_TESTS}; then
            _options+="--exclude ./usr/tests"
        fi

        case ${_package} in
            kernel_dbg)
                if is_yes ${BSDKIT_INSTALL_KERNEL} && is_yes ${BSDKIT_INSTALL_DEBUG}; then
                    _extract="YES"
                fi
                ;;

            base_dbg)
                if is_yes ${BSDKIT_INSTALL_DEBUG}; then
                    _extract="YES"
                fi
                ;;

            lib32_dbg)
                if is_yes ${BSDKIT_INSTALL_DEBUG}; then
                    _extract="YES"
                fi
                ;;

            kernel)
                if is_yes ${BSDKIT_INSTALL_KERNEL}; then
                    _extract="YES"
                fi
                ;;

            base)
                _extract="YES"
                ;;

            lib32)
                _options+="--exclude ./etc"
                _extract="YES"
                ;;

            src)
                if is_yes ${BSDKIT_INSTALL_SRC}; then
                    _options+="--include ./usr/src"
                    _extract="YES"
                fi
                ;;

            tests)
                if is_yes ${BSDKIT_INSTALL_TESTS}; then
                    _options+="--include ./usr/tests"
                    _extract="YES"
                fi
                ;;

            ports)
                ;;

            *)
                ;;
        esac

        if is_yes ${_extract}; then
            echo "Extracting: ${_filename}"
            ${CAT_CMD} ${_relpath}/${_filename} | tar -x -p -U -C ${_destdir} -f - ${=_options[*]}
        fi

        sync
    done

    if is_yes ${_thin}; then
        mkdir ${_destdir}/.base

        ln -s -f .base/bin ${_destdir}/bin
        ln -s -f .base/boot ${_destdir}/boot
        ln -s -f .base/lib ${_destdir}/lib
        ln -s -f .base/libexec ${_destdir}/libexec
        ln -s -f .base/rescue ${_destdir}/rescue
        ln -s -f .base/sbin ${_destdir}/sbin

        ln -s -f ../.base/usr/bin ${_destdir}/usr/bin
        ln -s -f ../.base/usr/include ${_destdir}/usr/include
        ln -s -f ../.base/usr/lib ${_destdir}/usr/lib
        ln -s -f ../.base/usr/lib32 ${_destdir}/usr/lib32
        ln -s -f ../.base/usr/libdata ${_destdir}/usr/libdata
        ln -s -f ../.base/usr/libexec ${_destdir}/usr/libexec
        ln -s -f ../.base/usr/sbin ${_destdir}/usr/sbin
        ln -s -f ../.base/usr/share ${_destdir}/usr/share

        if is_yes ${BSDKIT_INSTALL_SRC}; then
            ln -s -f ../.base/usr/src ${_destdir}/usr/src
        fi

        if is_yes ${BSDKIT_INSTALL_TESTS}; then
            ln -s -f ../.base/usr/tests ${_destdir}/usr/tests
        fi
    else
        __run_mtree ${_destdir}

        {
            mount -t devfs devfs ${_destdir}/dev
            chroot ${_destdir} /etc/rc.d/ldconfig start
        } always {
            umount -f ${_destdir}/dev
        }
    fi

    if is_yes ${_delete}; then
        rm -f ${_local_relpath}/*
        rmdir ${_local_relpath}
        rmdir ${_local_relpath_root}
    fi

    return 0
}

__run_mtree() {
    local _destdir=$1

    [ -d ${_destdir} ]
    [ ${_destdir} != "/" ]

    mtree -ideU -N ${_destdir}/etc -f ${_destdir}/etc/mtree/BSD.root.dist -p ${_destdir}/
    mtree -ideU -N ${_destdir}/etc -f ${_destdir}/etc/mtree/BSD.var.dist -p ${_destdir}/var
    mtree -ideU -N ${_destdir}/etc -f ${_destdir}/etc/mtree/BSD.usr.dist -p ${_destdir}/usr

    if [ -f ${_destdir}/etc/mtree/BSD.include.dist ]; then
        mtree -ideU -N ${_destdir}/etc -f ${_destdir}/etc/mtree/BSD.include.dist -p ${_destdir}/usr/include
    fi

    if [ -f ${_destdir}/etc/mtree/BSD.sendmail.dist ]; then
        mtree -ideU -N ${_destdir}/etc -f ${_destdir}/etc/mtree/BSD.sendmail.dist -p ${_destdir}/
    fi

    if [ -f ${_destdir}/etc/mtree/BSD.tests.dist -a -d ${_destdir}/usr/tests ]; then
        mtree -ideU -N ${_destdir}/etc -f ${_destdir}/etc/mtree/BSD.tests.dist -p ${_destdir}/usr/tests
    fi
}

__install_resolv_conf() {
    local _destdir=$1

    [ -d ${_destdir} ]
    [ ${_destdir} != "/" ]

    if [ -f /etc/resolv.conf ] && [ ! -f ${_destdir}/etc/resolv.conf ]; then
        install -m 0644 -o root -g wheel /etc/resolv.conf ${_destdir}/etc/resolv.conf
    fi
}

__install_ca_root_nss() {
    local _destdir=$1

    [ -d ${_destdir} ]
    [ ${_destdir} != "/" ]

    if [ -f /usr/local/share/certs/ca-root-nss.crt ] && [ ! -e ${_destdir}/usr/local/etc/ssl/cert.pem ]; then
        mkdir -p ${_destdir}/usr/local/etc/ssl
        install -m 0644 -o root -g wheel -lr /usr/local/share/certs/ca-root-nss.crt ${_destdir}/usr/local/etc/ssl/cert.pem
    fi
}

__customize_base() {
    local _destdir=$1

    __valid_destdir ${_destdir}

    chroot ${_destdir} chpass -p '$1$Kk8uqtid$UZr4tpkPw6388O6xDSFLt1' root

    mkdir -p ${_destdir}/root/.ssh

    echo_bsdkit_public_key > ${_destdir}/root/.ssh/authorized_keys

    chown -R root:wheel ${_destdir}/root

    # ===

    sed -i '' -e '/^PermitRootLogin/d' ${_destdir}/etc/ssh/sshd_config
    sed -i '' -e '/^UseDNS/d' ${_destdir}/etc/ssh/sshd_config

    cat >> ${_destdir}/etc/ssh/sshd_config << EOF
UseDNS no
PermitRootLogin yes
EOF

    mkdir -p ${_destdir}/etc/rc.conf.d

    __install_resolv_conf ${_destdir}
    __install_ca_root_nss ${_destdir}

    mkdir -p ${_destdir}/usr/local/etc/pkg/repos

    cat > ${_destdir}/usr/local/etc/pkg/repos/FreeBSD.conf << EOF
FreeBSD: {
    enabled: no
}
EOF

    cat > ${_destdir}/usr/local/etc/pkg/repos/bsdkit.conf << EOF
bsdkit: {
    url: "${FREEBSD_PKG_URL}"
}
EOF

    return 0
}

__do_configure_jail() {
    local _opts _opts_args

    zparseopts -F -D -E -a _opts -A _opts_args -plain

    local _plain
    _plain=$(yes_if ${_opts[(Ie)--plain]})

    local _destdir=$1

    __link_home ${_destdir}

    mkdir -p ${_destdir}/usr/ports

    __customize_base ${_destdir}

    if [ -f /etc/hosts ] && [ ! -f ${_destdir}/etc/hosts ]; then
        install -m 0644 -o root -g wheel /etc/hosts ${_destdir}/etc/hosts
    fi

    local _shell
    _shell=$(cat ${_destdir}/etc/passwd | grep ^root | cut -d : -f 7)

    if ! is_yes ${_plain}; then
        start_jail ${_destdir}
        pw -V ${_destdir}/etc usermod root -s /bin/sh

        {
            __ansible_jail_playbook
        } always {
            pw -V ${_destdir}/etc usermod root -s ${_shell}
            stop_jail ${_destdir}
        }
    fi

    return 0
}

__make_read_only() {
    local _destdir=$1

    __valid_destdir ${_destdir}

    local _file

    for _file in /entropy /boot/entropy; do
        [ -e ${_file} ] && install -m 0600 -o root -g wheel ${_file} ${_destdir}${_file}
    done

    sed -i '' -e '/^root:/ c\
root:$1$PkLp4/DM$/3D/umXPR0XIb0HsPHByU/:0:0::0:0:System Administrator:/root:/bin/csh' \
        ${_destdir}/etc/master.passwd

    pwd_mkdb -d ${_destdir}/etc ${_destdir}/etc/master.passwd

    touch ${_destdir}/etc/fstab

    # newsyslog -v -C -f ${_destdir}/etc/newsyslog.conf -d ${_destdir}

    uuidgen > ${_destdir}/etc/hostid

    cat > ${_destdir}/etc/ttys << EOF
ttyv0 "/usr/libexec/getty al.Pc" xterm onifexists  secure
ttyv1 "/usr/libexec/getty al.Pc" xterm onifexists  secure
ttyv2 "/usr/libexec/getty al.Pc" xterm onifexists  secure
ttyv3 "/usr/libexec/getty al.Pc" xterm onifexists  secure
ttyu0 "/usr/libexec/getty al.Pc" vt100 onifconsole secure
EOF

    cat > ${_destdir}/etc/rc.conf.local << EOF
background_dhclient="YES"
background_fsck="NO"
cleanvar_enable="NO"
crashinfo_enable="NO"
cron_enable="NO"
defaultroute_delay="10"
entropy_boot_file="NO"
entropy_file="NO"
hostid_enable="NO"
hostname="bsdkit"
ifconfig_DEFAULT="DHCP"
ip6addrctl_enable="NO"
keyrate="fast"
mixer_enable="NO"
moused_nondefault_enable="NO"
newsyslog_enable="YES"
ntpd_enable="YES"
ntpd_sync_on_start="YES"
root_rw_mount="NO"
sendmail_enable="NONE"
sendmail_msp_queue_enable="NO"
sendmail_outbound_enable="NO"
sendmail_submit_enable="NO"
sshd_enable="YES"
syslogd_enable="YES"
tmpmfs="YES"
varmfs="YES"
virecover_enable="NO"
EOF

    sed -i '' -e '/^PermitRootLogin/d' ${_destdir}/etc/ssh/sshd_config
    sed -i '' -e '/^UseDNS/d' ${_destdir}/etc/ssh/sshd_config
    sed -i '' -e '/^GatewayPorts/d' ${_destdir}/etc/ssh/sshd_config
    sed -i '' -e '/^MaxAuthTries/d' ${_destdir}/etc/ssh/sshd_config
    sed -i '' -e '/^leapfile/d' ${_destdir}/etc/ntp.conf

    cat >> ${_destdir}/etc/ssh/sshd_config << EOF
UseDNS no
PermitRootLogin yes
GatewayPorts yes
MaxAuthTries 32
EOF

    cat > ${_destdir}/etc/host.conf << EOF
# Auto-generated from nsswitch.conf
hosts
dns
EOF

    return 0
}

__install_setup_runtime() {
    local _destdir=$1
    local _bsdkit=$2
    local _pkgpath=$3

    __valid_destdir ${_destdir}
    __valid_bsdkit ${_bsdkit}
    __valid_pkgpath ${_pkgpath}

    local _runtime=(
        # required
        devel/git
        lang/python
        net/py-netaddr
        ports-mgmt/pkg
        security/ca_root_nss
        shells/zsh
        sysutils/ansible
        sysutils/pv
        textproc/jq
        textproc/yq
        # optional
        archivers/zip
        comms/kermit
        devel/git
        editors/bvi
        editors/nano
        editors/vim
        ftp/curl
        ftp/lftp
        misc/gnu-watch
        misc/mc
        net/croc
        net/rclone
        net/rsync
        net/zerotier
        security/openvpn
        sysutils/clone
        sysutils/cpdup
        sysutils/ddrescue
        sysutils/filemon
        sysutils/flashrom
        sysutils/fusefs-exfat
        sysutils/fusefs-ext2
        sysutils/fusefs-ntfs
        sysutils/hextools
        sysutils/hfsutils
        sysutils/htop
        sysutils/ipmitool
        sysutils/lsblk
        sysutils/memtester
        sysutils/ncdu
        sysutils/renameutils
        sysutils/smartmontools
        sysutils/smenu
        sysutils/tmux
        textproc/fzf
        www/go-www
        www/tinyproxy
        # disabled
        # genisoimage
    )

    local _allpkg=${_pkgpath}/All

    local _pkgdir=/usr/ports/packages

    mkdir -p ${_destdir}/${_pkgdir}
    mkdir -p ${_destdir}/dev

    {
        mount -t devfs devfs ${_destdir}/dev
        mount -t nullfs ${_pkgpath} ${_destdir}/${_pkgdir}

        mkdir -p ${_destdir}/usr/local/etc/pkg/repos

        cat > ${_destdir}/usr/local/etc/pkg/repos/FreeBSD.conf << EOF
FreeBSD: {
    enabled: no
}
EOF

        cat > ${_destdir}/usr/local/etc/pkg/repos/bsdkit.conf << EOF
bsdkit: {
    url: "file://${_pkgdir}"
}
EOF

        lockf -k -t ${BSDKIT_PKG_LOCKTIME} ${BSDKIT_PKG_LOCKFILE} pkg -c ${_destdir} install -y ${_runtime}

        if [ -d ${_destdir}/var/cache/pkg ]; then
            lockf -k -t ${BSDKIT_PKG_LOCKTIME} ${BSDKIT_PKG_LOCKFILE} pkg -c ${_destdir} clean -y -a
        fi

        rm -f ${_destdir}/usr/local/etc/pkg/repos/bsdkit.conf
    } always {
        umount -f ${_destdir}/${_pkgdir}
        umount -f ${_destdir}/dev
    }

    rmdir ${_destdir}/${_pkgdir}

    local _master_passwd
    _master_passwd=$(mktemp ${_destdir}/tmp/master.passwd.XXXXXX)

    install -m 0600 ${_destdir}/etc/master.passwd ${_master_passwd}

    sed -i '' -e '/^root/s@/bin/csh@/usr/local/bin/zsh@' ${_master_passwd}

    pwd_mkdb -d ${_destdir}/etc ${_master_passwd}

    rm -f ${_master_passwd}

    install -m 0644 -o root -g wheel ${_bsdkit}/ansible/dotfiles/dot.zshrc ${_destdir}/root/.zshrc

    cat >> ${_destdir}/root/.zshrc << EOF
echo -n "Available disks: "
sysctl -n kern.disks | rs 0 1 | sort | grep -v -E "^cd|^acd" | rs 1 0 | sed -E -e "s/ +/ /g"
echo
EOF

    return 0
}

__ansible_jail_playbook() {
    __check_ansible

    local _ansible_root
    _ansible_root=$(mktemp -d /tmp/ansible_root.XXXXX)

    local _ansible_cfg=${_ansible_root}/ansible.cfg
    local _ansible_hosts=${_ansible_root}/ansible_hosts

    cat > ${_ansible_cfg} << EOF
[defaults]
inventory = ${_ansible_hosts}
host_key_checking = False

[ssh_connection]
pipelining = True
ssh_args = -o ControlMaster=no -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null
EOF

    cat > ${_ansible_hosts} << EOF
${BSDKIT_JAIL_NAME} ansible_connection=jail ansible_shell_type=sh ansible_python_interpreter=${ANSIBLE_PYTHON_INTERPRETER}
EOF

    _bsdkit_interface="$(ifconfig -l -u ether | awk '{ print $1 }')"
    _bsdkit_ifconfig="$(kenv bsdkit_ifconfig 2> /dev/null || :)"
    _bsdkit_defaultrouter="$(kenv bsdkit_defaultrouter 2> /dev/null || :)"

    eval env \
        ANSIBLE_CONFIG=${_ansible_cfg} \
        SSH_AUTH_SOCK="" \
        $(__environment) \
        BSDKIT_INTERFACE=${_bsdkit_interface} \
        BSDKIT_IFCONFIG=${_bsdkit_ifconfig} \
        BSDKIT_DEFAULTROUTER=${_bsdkit_defaultrouter} \
        ansible-playbook ${BSDKIT_SRCDIR}/playbook/playbook.yml $*

    rm -r ${_ansible_root}
}

__echo_runtime_jail_conf() {
    local _destdir=$1

    __valid_destdir ${_destdir}

    cat > ${_jail_conf} << EOF
exec.clean;

mount.devfs;
persist;

sysvsem = new;
sysvshm = new;
sysvmsg = new;

${BSDKIT_JAIL_NAME} {
        allow.raw_sockets;
        allow.sysvipc;

        osrelease = "$(osrelease ${_destdir})";
        osreldate = "$(osreldate ${_destdir})";

        path = "${_destdir%/}";
        host.hostname = "${BSDKIT_JAIL_NAME}";
        host.domainname = "local";
        ip4.addr = "$(inet_address)";
}
EOF
}

inet_interface() {
    route get default | awk '/interface:/ { print $2 }'
}

inet_address() {
    ifconfig $(inet_interface) | awk '$1 == "inet" { print $2; exit }'
}

gateway_interface() {
    netstat --libxo json -n -r | jq -r '.["statistics"]["route-information"]["route-table"]["rt-family"][] | select(.["address-family"] == "Internet") | .["rt-entry"][] | select(.["destination"] == "default") | .["interface-name"]'
}

gateway_address() {
    netstat --libxo json -n -r | jq -r '.["statistics"]["route-information"]["route-table"]["rt-family"][] | select(.["address-family"] == "Internet") | .["rt-entry"][] | select(.["destination"] == "default") | .["gateway"]'
}

start_jail() {
    local _destdir=$1
    __valid_destdir ${_destdir}

    local _jail_conf
    _jail_conf=$(mktemp /tmp/jail.conf.XXXXXX)

    __echo_runtime_jail_conf ${_destdir} > ${_jail_conf}
    jail -f ${_jail_conf} -c ${BSDKIT_JAIL_NAME}
    rm ${_jail_conf}
}

stop_jail() {
    local _destdir=$1
    __valid_destdir ${_destdir}

    local _jail_conf
    _jail_conf=$(mktemp /tmp/jail.conf.XXXXXX)

    __echo_runtime_jail_conf ${_destdir} > ${_jail_conf}
    jail -f ${_jail_conf} -r ${BSDKIT_JAIL_NAME}
    rm ${_jail_conf}
}

reset_state() {
    jail -R '*'

    mount -p |
        cut -w -f 2 |
        grep /baseroot${BSDKIT_DESTDIR} |
        sort -r |
        xargs umount -f

    swapctl -l | grep "^/" | cut -f 1 -d' ' | xargs swapoff

    # This is dangerous, and we do not do it here:
    #   zpool destroy ${BSDKIT_ZFS_POOL} || :
}

install_mbr_ufs() {
    eval $(__local_options)
    eval $(__parse_options $@)

    local _class=$1
    local _device=$2

    [ -n ${_class} ]
    [ -n ${_device} ]

    __valid_class ${_class}

    mkdir -p ${BSDKIT_DESTDIR}

    __mbr_ufs_partition_${_class} ${BSDKIT_DESTDIR} ${_device}
    __install_release ${FREEBSD_REL_URL} ${BSDKIT_DESTDIR}
    __swap_setup ${BSDKIT_DESTDIR}
    __procfs_setup ${BSDKIT_DESTDIR}
    __fdescfs_setup ${BSDKIT_DESTDIR}
    __finalize_fstab ${BSDKIT_DESTDIR}
    __customize_base ${BSDKIT_DESTDIR}

    return 0
}

install_mbr_ufs_gmirror() {
    eval $(__local_options)
    eval $(__parse_options $@)

    local _class=$1
    local _mirror=$2

    shift 2

    local _devices

    _devices=($*)

    [ -n ${_class} ]
    [ -n ${_mirror} ]
    [ ${#_devices} -gt 0 ]

    __valid_class ${_class}

    kldload -n geom_mirror

    mkdir -p ${BSDKIT_DESTDIR}

    __gmirror_configure ${_mirror} ${_devices}
    __mbr_ufs_partition_${_class} ${BSDKIT_DESTDIR} mirror/${_mirror}
    __install_release ${FREEBSD_REL_URL} ${BSDKIT_DESTDIR}
    __swap_setup ${BSDKIT_DESTDIR}
    __procfs_setup ${BSDKIT_DESTDIR}
    __fdescfs_setup ${BSDKIT_DESTDIR}
    __finalize_fstab ${BSDKIT_DESTDIR}
    __customize_base ${BSDKIT_DESTDIR}

    return 0
}

install_gpt_ufs() {
    eval $(__local_options)
    eval $(__parse_options $@)

    local _class=$1
    local _device=$2

    [ -n ${_class} ]
    [ -n ${_device} ]

    __valid_class ${_class}

    mkdir -p ${BSDKIT_DESTDIR}

    __gpt_ufs_partition_${_class} ${BSDKIT_DESTDIR} ${_device}
    __install_release ${FREEBSD_REL_URL} ${BSDKIT_DESTDIR}
    __swap_setup ${BSDKIT_DESTDIR}
    __procfs_setup ${BSDKIT_DESTDIR}
    __fdescfs_setup ${BSDKIT_DESTDIR}
    __finalize_fstab ${BSDKIT_DESTDIR}
    __customize_base ${BSDKIT_DESTDIR}

    return 0
}

install_zfs() {
    __check_bsdkit_runtime

    eval $(__local_options)
    eval $(__parse_options $@)

    local _devices

    _devices=($*)

    [ ${#_devices} -gt 0 ]

    kldload -n zfs

    mkdir -p ${BSDKIT_DESTDIR}

    __zfs_create_pool ${BSDKIT_DESTDIR} ${_devices}
    __zfs_create_fs ${BSDKIT_DESTDIR}
    __install_release ${FREEBSD_REL_URL} ${BSDKIT_DESTDIR}
    __zfs_create_zpool_cache ${BSDKIT_DESTDIR}
    __swap_setup ${BSDKIT_DESTDIR}
    __procfs_setup ${BSDKIT_DESTDIR}
    __fdescfs_setup ${BSDKIT_DESTDIR}
    __finalize_fstab ${BSDKIT_DESTDIR}
    __customize_base ${BSDKIT_DESTDIR}

    return 0
}

install_gpt_zfs() {
    __check_bsdkit_runtime

    eval $(__local_options)
    eval $(__parse_options $@)


    local _devices

    _devices=($*)

    [ ${#_devices} -gt 0 ]

    kldload -n zfs

    mkdir -p ${BSDKIT_DESTDIR}

    __zfs_create_gpt_pool ${BSDKIT_DESTDIR} ${_devices}
    __zfs_create_fs ${BSDKIT_DESTDIR}
    __install_release ${FREEBSD_REL_URL} ${BSDKIT_DESTDIR}
    __zfs_create_zpool_cache ${BSDKIT_DESTDIR}
    __swap_setup ${BSDKIT_DESTDIR}
    __procfs_setup ${BSDKIT_DESTDIR}
    __fdescfs_setup ${BSDKIT_DESTDIR}
    __finalize_fstab ${BSDKIT_DESTDIR}
    __customize_base ${BSDKIT_DESTDIR}

    return 0
}

install_mbr_zfs() {
    __check_bsdkit_runtime

    eval $(__local_options)
    eval $(__parse_options $@)

    local _devices

    _devices=($*)

    [ ${#_devices} -gt 0 ]

    kldload -n zfs

    mkdir -p ${BSDKIT_DESTDIR}

    __zfs_create_mbr_pool ${BSDKIT_DESTDIR} ${_devices}
    __zfs_create_fs ${BSDKIT_DESTDIR}
    __install_release ${FREEBSD_REL_URL} ${BSDKIT_DESTDIR}
    __zfs_create_zpool_cache ${BSDKIT_DESTDIR}
    __swap_setup ${BSDKIT_DESTDIR}
    __procfs_setup ${BSDKIT_DESTDIR}
    __fdescfs_setup ${BSDKIT_DESTDIR}
    __finalize_fstab ${BSDKIT_DESTDIR}
    __customize_base ${BSDKIT_DESTDIR}

    return 0
}

create_iocell() {
    __check_ansible

    eval $(__local_options)
    eval $(__parse_options $@)

    local _tag=$1

    shift

    command -v iocell > /dev/null 2>&1 || error "iocell not found (create_iocell)."

    local _uuid
    _uuid=$(iocell create -e tag=${_tag} host_hostname=${_tag} "$@")

    local _mountpoint
    _mountpoint=$(iocell get mountpoint ${_tag}) || error "iocell could not retrieve mountpoint."

    local _destdir=${_mountpoint}/root

    [ -d ${_destdir} ] || error "iocell root does not exist (create_iocell)."

    BSDKIT_INSTALL_KERNEL=no BSDKIT_INSTALL_SRC=no __install_release ${FREEBSD_REL_URL} ${_destdir}

    __do_configure_jail ${_destdir}
}

create_iocell_thin() {
    __check_ansible

    eval $(__local_options)
    eval $(__parse_options $@)

    local _tag=$1

    shift 1

    command -v iocell > /dev/null 2>&1 || error "iocell not found (create_iocell_thin)."

    iocell create tag=${_tag} host_hostname=${_tag} "$@" || error "iocell could not create jail."

    # local _uuid
    # _uuid=$(iocell get host_hostuuid ${_tag}) || error "iocell could not retrieve host_hostuuid."

    local _mountpoint
    _mountpoint=$(iocell get mountpoint ${_tag}) || error "iocell could not retrieve mountpoint."

    local _destdir=${_mountpoint}/root

    [ -d ${_destdir} ] || error "iocell root does not exist (create_iocell_thin)."

    __do_configure_jail ${_destdir}
}

create_iocage() {
    __check_ansible

    eval $(__local_options)
    eval $(__parse_options $@)

    local _jail_name=$1

    shift

    unset IOCAGE_COLOR

    command -v iocage > /dev/null 2>&1 || error "iocage not found (create_iocage)."
    iocage get -p > /dev/null 2>&1 || error "unable to retrieve iocage mount point (create_iocage)."

    local _iocage_root
    _iocage_root=$(iocage get -p)

    local _iocage_jails
    _iocage_jails=$(zfs get -H -p -o value mountpoint ${_iocage_root}/iocage/jails)

    iocage create -e --name ${_jail_name} "$@"
    local _destdir=${_iocage_jails}/${_jail_name}/root

    [ -d ${_destdir} ] || error "iocage root does not exist (create_iocage)."

    BSDKIT_INSTALL_KERNEL=no BSDKIT_INSTALL_SRC=no __install_release ${FREEBSD_REL_URL} ${_destdir}

    __do_configure_jail ${_destdir}
}

create_iocage_thin() {
    __check_ansible

    eval $(__local_options)
    eval $(__parse_options $@)

    local _jail_name=$1

    shift

    unset IOCAGE_COLOR

    command -v iocage > /dev/null 2>&1 || error "iocage not found (create_iocage)."
    iocage get -p > /dev/null 2>&1 || error "unable to retrieve iocage mount point (create_iocage)."

    local _iocage_root
    _iocage_root=$(iocage get -p)

    local _iocage_jails
    _iocage_jails=$(zfs get -H -p -o value mountpoint ${_iocage_root}/iocage/jails)

    iocage create --name ${_jail_name} $@
    local _destdir=${_iocage_jails}/${_jail_name}/root

    [ -d ${_destdir} ] || error "iocage root does not exist (create_iocage)."

    __do_configure_jail ${_destdir}
}

create_jail() {
    __check_ansible

    eval $(__local_options)
    eval $(__parse_options $@)

    local _opts _opts_args

    zparseopts -F -D -E -a _opts -A _opts_args -thin -plain

    local _thin
    _thin=$(yes_if ${_opts[(Ie)--thin]})

    local _plain
    _plain=$(yes_if ${_opts[(Ie)--plain]})

    local _options=()

    if is_yes ${_thin}; then
        _options+="--thin"
    fi

    local _destdir=$1

    create_jail_destdir ${_destdir}

    BSDKIT_INSTALL_KERNEL=no BSDKIT_INSTALL_SRC=no __install_release ${FREEBSD_REL_URL} ${_destdir} ${=_options[*]}

    if ! is_yes ${_plain}; then
        if is_yes ${_thin}; then
            mount -t nullfs -o ro / ${_destdir}/.base
            mount -t devfs devfs ${_destdir}/dev
        fi

        local _options=()

        if is_yes ${_plain}; then
            _options+="--plain"
        fi

        __do_configure_jail ${=_options[*]} ${_destdir}

        if is_yes ${_thin}; then
            umount ${_destdir}/.base
            umount ${_destdir}/dev
        fi
    fi
}

configure_jail() {
    __check_ansible

    eval $(__local_options)
    eval $(__parse_options $@)

    local _destdir=$1

    shift

    [ -d ${_destdir} ] || error "jail root does not exist (configure_jail)."
    [ -f ${_destdir}/bin/sh ] || error "/bin/sh does not exist in jail (configure_jail)."

    __do_configure_jail ${_destdir}
}

build_md_root_device() {
    local _option
    local _type
    local _size
    local _reboot

    _type=swap
    _size=2G
    _reboot=NO

    OPTIND=1
    while getopts "mws:r" _option; do
        case ${_option} in
            m)
                _type=malloc
                ;;
            w)
                _type=swap
                ;;
            s)
                _size=${OPTARG}
                ;;
            r)
                _reboot=YES
                ;;
            *) ;;
        esac
    done

    shift $((OPTIND - 1))

    local _md_device
    _md_device=$(mdconfig -a -o reserve -o compress -L "md_root" -t ${_type} -s ${_size})

    BSDKIT_INSTALL_SRC=no BSDKIT_INSTALL_KERNEL=no BSDKIT_PART_SIZE_SWAP=0 BSDKIT_LABEL_ROOT=md_root ${BSDKIT_SCRIPT} install_gpt_ufs $* single ${_md_device}

    rm -f ${BSDKIT_DESTDIR}/etc/rc.conf
    touch ${BSDKIT_DESTDIR}/etc/rc.conf

    sysrc -f ${BSDKIT_DESTDIR}/etc/rc.conf hostname=localhost
    sysrc -f ${BSDKIT_DESTDIR}/etc/rc.conf sshd_enable=YES

    sed -i '' -e '/^PermitRootLogin/d' ${BSDKIT_DESTDIR}/etc/ssh/sshd_config

    if [ -e ~root/.ssh/authorized_keys ]; then
        install -m 0644 ~root/.ssh/authorized_keys ${BSDKIT_DESTDIR}/root/.ssh/authorized_keys
    fi

    cat >> ${BSDKIT_DESTDIR}/etc/ssh/sshd_config << EOF
PermitRootLogin yes
EOF

    mkdir -p ${BSDKIT_DESTDIR}/root/bin/
    install -m 0755 -o root -g wheel bsdkit-rewrite-pool ${BSDKIT_DESTDIR}/root/bin/

    mkdir -p ${BSDKIT_DESTDIR}/dev

    {
        mount -t devfs devfs ${BSDKIT_DESTDIR}/dev

        lockf -k -t ${BSDKIT_PKG_LOCKTIME} ${BSDKIT_PKG_LOCKFILE} pkg -c ${BSDKIT_DESTDIR} install -y \
              net/rsync \
              ports-mgmt/pkg \
              shells/zsh

        if [ -d ${BSDKIT_DESTDIR}/var/cache/pkg ]; then
            lockf -k -t ${BSDKIT_PKG_LOCKTIME} ${BSDKIT_PKG_LOCKFILE} pkg -c ${BSDKIT_DESTDIR} clean -y -a
        fi
    } always {
        umount -f ${BSDKIT_DESTDIR}/dev
    }

    if is_yes ${_reboot}; then
        kenv vfs.root.mountfrom="ufs:/dev/${_md_device}p3"
        reboot -r
    else
        echo "Use \"reboot -r\" after:"
        echo
        echo "    kenv vfs.root.mountfrom=\"ufs:/dev/${_md_device}p3\""
    fi
}

create_jail_destdir() {
    local _destdir=$1

    if [ -d ${_destdir} ]; then
        [ "$(echo $(find ${_destdir} -type d -empty -maxdepth 0 | wc -l))" = "1" ] || error "${_destdir} already exists (create_jail_destdir)."
    fi

    local _dirname _basename _parent_fs

    _dirname="$(dirname ${_destdir})"
    _basename="$(basename ${_destdir})"
    _parent_fs=$(zfs list -H -o mounted,mountpoint,name | awk "\$1 == \"yes\" && \$2 == \"${_dirname}\" { print \$3; }")

    local _zfs="NO"

    if [ -n ${_parent_fs} ]; then
        if ! zfs get -H -o value mountpoint ${_parent_fs}/${_basename} > /dev/null 2>&1; then
            ${ZFS_CREATE_CMD} -o compression=$(__zfs_compression) ${_parent_fs}/${_basename}
            _zfs="YES"
        fi
    else
        mkdir -p ${_destdir}
    fi
}

remove_jail() {
    local _destdir=$1

    __valid_destdir ${_destdir}

    local _dirname _basename _parent_fs

    _dirname=$(dirname ${_destdir})
    _basename=$(basename ${_destdir})
    _parent_fs=$(zfs list -H -o mounted,mountpoint,name | awk "\$1 == \"yes\" && \$2 == \"${_dirname}\" { print \$3; }")

    local _zfs="NO"

    local _devfs

    mount -p -t devfs | cut -w -f 2 | while read _devfs; do
        if [ ${_devfs} = ${_destdir}/dev ]; then
            umount -f ${_destdir}/dev
        fi
    done

    if [ -n ${_parent_fs} ]; then
        if zfs get -H -o value mountpoint ${_parent_fs}/${_basename} > /dev/null 2>&1; then
            _zfs="YES"
        fi
    fi

    if is_yes ${_zfs}; then
        zfs destroy ${_parent_fs}/${_basename}
    else
        rm -r -f ${_destdir} > /dev/null 2>&1 || :
        chflags -R noschg ${_destdir} > /dev/null 2>&1 || :
        rm -r -f ${_destdir}
    fi
}

build_setup_staging() {
    local _staging=$1
    local _bsdkit=$2
    local _relpath=$3
    local _pkgpath=$4

    _bsdkit=$(realpath ${_bsdkit})
    _relpath=$(realpath ${_relpath})
    _pkgpath=$(realpath ${_pkgpath})

    __valid_bsdkit ${_bsdkit}
    __valid_relpath ${_relpath}
    __valid_pkgpath ${_pkgpath}

    mkdir -p ${_staging}

    _staging=$(realpath ${_staging})

    [ ${_staging} != ${_bsdkit} ]
    [ ${_staging} != ${_relpath} ]
    [ ${_staging} != ${_pkgpath} ]
    [ ${_staging} != "/" ] || exit 1

    local _tmp="/tmp/tmp.$$"
    mkdir -p ${_tmp}
    mount -t tmpfs tmpfs ${_tmp}

    local _destdir=${_tmp}/destdir

    mkdir -p ${_destdir}

    BSDKIT_INSTALL_SRC=no __install_release ${_relpath} ${_destdir}

    rm -f ${_destdir}/boot/kernel/*.symbols(N)

    rm -f ${_destdir}/home

    mkdir -p ${_destdir}/cdrom
    mkdir -p ${_destdir}/img

    touch ${_destdir}/root/.hushlogin

    mkdir ${_destdir}/root/.ssh

    echo_bsdkit_public_key > ${_destdir}/root/.ssh/authorized_keys

    local _mfsroot=${_tmp}/mfsroot

    mkdir -p ${_mfsroot}

    (cd ${_destdir} && pax -r -w -pe rescue ${_mfsroot})

    __make_read_only ${_destdir}

    __install_setup_runtime ${_destdir} ${_bsdkit} ${_pkgpath}

    mkdir ${_mfsroot}/dev
    mkdir ${_mfsroot}/baseroot

    rm -r -f ${_staging}

    mkdir ${_staging}

    _staging=$(realpath ${_staging})

    (cd ${_destdir} && pax -r -w -pe boot ${_staging})

    gzip ${_staging}/boot/kernel/kernel

    install -m 0644 -o root -g wheel ${_bsdkit}/ansible/loader.conf.vendor ${_staging}/boot/loader.conf

    cat > ${_staging}/boot/loader.conf.local << EOF
geom_uzip_load="YES"

nullfs_load="YES"
unionfs_load="YES"

hw.mca.enabled="0"
hint.atrtc.0.clock="0"

kern.cam.ada.legacy_aliases="0"
kern.cam.boot_delay="10000"

kern.geom.label.disk_ident.enable="0"

vfs.root_mount_always_wait="1"

mfsroot_load="YES"
mfsroot_type="md_image"
mfsroot_name="/memroot.ufs"

init_path="/rescue/init"
init_shell="/rescue/sh"
init_script="/baseroot.rc"
init_chroot="/baseroot"
EOF

    mkdir -p ${_mfsroot}/etc

    touch ${_mfsroot}/etc/fstab

    install -m 0600 -o root -g wheel ${_destdir}/etc/login.conf ${_mfsroot}/etc

    echo "#!/bin/sh" > ${_mfsroot}/baseroot.rc
    echo "IMG_PART=/dev/gpt/${BSDKIT_IMG_DATA_LABEL}" >> ${_mfsroot}/baseroot.rc

    cat >> ${_mfsroot}/baseroot.rc << "EOF"
set -e -u

trap '/rescue/sh' EXIT

export BASEROOT_IMG=/base.ufs.uzip

export BASEROOT_MP=/baseroot
export CDROM_MP=/cdrom
export IMG_MP=/img
export DEV_MP=/dev
export TMP_MP=/tmp

export ETC_MP=/etc
export ETC_RDWR_MP=/etc.rdwr
export ROOT_MP=/root
export ROOT_RDWR_MP=/root.rdwr

export PATH=/rescue

mount -u -w /

mkdir -p "${BASEROOT_MP}"
mkdir -p "${CDROM_MP}"
mkdir -p "${ETC_RDWR_MP}"
mkdir -p "${ROOT_RDWR_MP}"

if [ -e "${IMG_PART}" ]; then
    mkdir -p "${IMG_MP}"
    fsck -y -t ufs "${IMG_PART}"
    mount -r -t ufs "${IMG_PART}" "${IMG_MP}"
    ISO_MD=$(mdconfig -f "${IMG_MP}"/*.[iI][sS][oO])
    mount -t cd9660 "/dev/${ISO_MD}" "${CDROM_MP}"
else
    for _device in cd0 cd1 acd0 acd1; do
        if [ -e "/dev/${_device}" ]; then
            if mount -t cd9660 "/dev/${_device}" "${CDROM_MP}" > /dev/null 2>&1; then
                break
            fi
        fi
    done
fi

mdmfs -P -F "${CDROM_MP}${BASEROOT_IMG}" -o ro md.uzip "${BASEROOT_MP}"

mount -t devfs devfs "${BASEROOT_MP}${DEV_MP}"

mount -t nullfs -o ro "${CDROM_MP}" "${BASEROOT_MP}${CDROM_MP}"

mdmfs -s 8m  md "${ETC_RDWR_MP}"
mdmfs -s 64m md "${ROOT_RDWR_MP}"

mount -t unionfs "${ETC_RDWR_MP}"  "${BASEROOT_MP}${ETC_MP}"
mount -t unionfs "${ROOT_RDWR_MP}" "${BASEROOT_MP}${ROOT_MP}"

if [ -d "${IMG_MP}" ]; then
    mkdir -p "${BASEROOT_MP}${IMG_MP}"
    mount -t nullfs -o rw "${IMG_MP}" "${BASEROOT_MP}${IMG_MP}"
fi

kenv init_shell="/bin/sh"

if kenv bsdkit_ifconfig > /dev/null 2>&1; then
    bsdkit_ifconfig=$(kenv bsdkit_ifconfig)
    # shellcheck disable=SC2046
    set $(ifconfig -l ether)
    _interface=$1
    if [ -n "${_interface}" ]; then
        echo "ifconfig_${_interface}=\"${bsdkit_ifconfig}\"" >> /baseroot/etc/rc.conf
    fi
fi

if kenv bsdkit_defaultrouter > /dev/null 2>&1; then
    bsdkit_defaultrouter=$(kenv bsdkit_defaultrouter)
    echo "defaultrouter=\"${bsdkit_defaultrouter}\"" >> /baseroot/etc/rc.conf
fi

trap '' EXIT

exit 0
EOF

    install -m 0644 -o root -g wheel ${_bsdkit}/ansible/vendor.conf ${_destdir}/etc/rc.conf

    makefs ${_staging}/memroot.ufs ${_mfsroot}

    chmod -x ${_staging}/memroot.ufs

    rm -f ${_staging}/memroot.ufs.gz

    gzip ${_staging}/memroot.ufs

    makefs ${_staging}/base.ufs ${_destdir}

    mkuzip -o ${_staging}/base.ufs.uzip ${_staging}/base.ufs

    rm -f ${_staging}/base.ufs

    chmod -x ${_staging}/base.ufs.uzip

    while ! umount -f ${_tmp}; do
        echo "Waiting for ${_tmp} (tmp)"
        sleep 3
    done

    rmdir ${_tmp}

    return 0
}

build_setup_iso() {
    local _iso=$1
    local _staging=$2
    local _relpath=$3
    local _pkgpath=$4

    if ! command -v mkisofs > /dev/null 2>&1; then
        error "required command missing (mkisofs)."
        # EX_UNAVAILABLE
        exit 69
    fi

    __valid_staging ${_staging}

    if [ ${_relpath} != "none" ]; then
        __valid_relpath ${_relpath}
    fi

    if [ ${_pkgpath} != "none" ]; then
        __valid_pkgpath ${_pkgpath}
    fi

    local _iso_path=${_iso}.fs

    mkdir -p ${_iso_path}

    ln -s -f $(realpath ${_staging}/*) ${_iso_path}

    if [ ${_relpath} != "none" ]; then
        ln -s -f $(realpath ${_relpath}) ${_iso_path}/$(basename ${_relpath})
    fi

    if [ ${_pkgpath} != "none" ]; then
        ln -s -f $(realpath ${_pkgpath}) ${_iso_path}/$(basename ${_pkgpath})
    fi

    # From src/release/amd64/mkisoimages.sh

    dd if=/dev/zero of=${_iso_path}/efiboot.img bs=${BSDKIT_PART_SIZE_EFI} count=1
    _efiboot_md_device=$(mdconfig -f ${_iso_path}/efiboot.img)

    {
        newfs_msdos -L efi -F 16 -c 2 /dev/${_efiboot_md_device}

        _efiboot_root=$(mktemp -d /tmp/XXXXXX)

        mount -t msdosfs /dev/${_efiboot_md_device} ${_efiboot_root}
        {
            mkdir -p ${_efiboot_root}/efi/boot
            cp ${_iso_path}/boot/loader.efi ${_efiboot_root}/efi/boot/bootx64.efi
        } always {
            umount ${_efiboot_root}
        }

        rmdir ${_efiboot_root}
    } always {
        mdconfig -d -u ${_efiboot_md_device}
    }

    mkisofs \
        -rational-rock \
        -follow-links \
        -J \
        -V FreeBSD \
        -publisher olgeni.com \
        -eltorito-boot boot/cdboot \
        -no-emul-boot \
        -eltorito-platform efi \
        -eltorito-boot efiboot.img \
        -no-emul-boot \
        -o ${_iso} \
        ${_iso_path}

    for _entry in $(etdump --format shell ${_iso}); do
        eval ${_entry}
        if [ ${et_platform} = "efi" ]; then
            _esp_start=$(expr ${et_lba} \* 2048)
            _esp_size=$(expr ${et_sectors} \* 512)
            _esp_param=(-p efi::${_esp_size}:${_esp_start})
            break
        fi
    done

    _hybrid_img=$(mktemp /tmp/XXXXXX)

    mkimg \
        -s gpt \
        --capacity $(stat -f %z ${_iso}) \
        -b ${_iso_path}/boot/pmbr \
        ${_esp_param} \
        -p freebsd-boot:=${_iso_path}/boot/isoboot \
        -o ${_hybrid_img}

    dd if=${_hybrid_img} of=${_iso} bs=32k count=1 conv=notrunc

    rm -f ${_hybrid_img}

    rm -r -f ${_iso_path}

    return 0
}

build_setup_img() {
    local _iso_file=$1
    local _img_file=$2

    #
    # EFI partition
    #

    local _efi_dir
    _efi_dir=$(mktemp -d /tmp/efi.XXXXXX)

    tar -x -f ${_iso_file} -C ${_efi_dir} boot/loader.efi

    mkdir -p ${_efi_dir}/efi/boot
    mv ${_efi_dir}/boot/loader.efi ${_efi_dir}/efi/boot/bootx64.efi
    rmdir ${_efi_dir}/boot

    local _efi_img
    _efi_img=$(mktemp /tmp/ufs.XXXXXX)

    makefs -b 50% ${_efi_img} ${_efi_dir}

    rm -r -f ${_efi_dir}

    #
    # UFS partition
    #

    local _ufs_dir
    _ufs_dir=$(mktemp -d /tmp/staging.XXXXXX)

    tar -x -f ${_iso_file} -C ${_ufs_dir} boot memroot.ufs.gz

    mkdir -p ${_ufs_dir}/etc
    uuidgen > ${_ufs_dir}/etc/hostid

    cp ${_iso_file} ${_ufs_dir}

    local _ufs_img
    _ufs_img=$(mktemp /tmp/ufs.XXXXXX)

    makefs ${_ufs_img} ${_ufs_dir}

    rm -r -f ${_ufs_dir}

    #
    # Image
    #

    rm -f ${_img_file}

    mkimg -v \
        -s gpt \
        -b /boot/pmbr \
        -p efi:=${_efi_img} \
        -p freebsd-boot:=/boot/gptboot \
        -p freebsd-ufs/${BSDKIT_IMG_DATA_LABEL}:=${_ufs_img} \
        -o ${_img_file}

    rm -f ${_efi_img}
    rm -f ${_ufs_img}
}

deploy() {
    __check_ansible
    echo "Running: $*"

    ${(@s/ /)@}

    ansible_chroot_playbook
}

remote_deploy() {
    __check_ansible

    local _remote_address=""
    local _remote_port="22"
    local _option

    OPTIND=1
    while getopts "h:p:" _option; do
        case ${_option} in
            h)
                _remote_address=${OPTARG}
                ;;
            p)
                _remote_port=${OPTARG}
                ;;
            *) ;;
        esac
    done

    shift $((OPTIND - 1))

    [ -n ${_remote_address} ]
    [ -n ${_remote_port} ]

    echo "Running: $*"

    local _ansible_root
    _ansible_root=$(mktemp -d /tmp/ansible_root.XXXXX)

    local _ansible_cfg=${_ansible_root}/ansible.cfg
    local _ansible_hosts=${_ansible_root}/ansible_hosts
    local _ansible_yml=${_ansible_root}/ansible.yml
    local _ansible_key=${_ansible_root}/ansible.key

    echo_bsdkit_private_key > ${_ansible_key}
    chmod 600 ${_ansible_key}

    cat > ${_ansible_cfg} << EOF
[defaults]
inventory = ${_ansible_hosts}
host_key_checking = False

[ssh_connection]
pipelining = True
ssh_args = -o ControlMaster=no -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null
EOF

    cat > ${_ansible_hosts} << EOF
install connection=ssh ansible_shell_type=sh ansible_python_interpreter=/usr/local/bin/python ansible_ssh_host=${_remote_address} ansible_ssh_port=${_remote_port} ansible_ssh_private_key_file=${_ansible_key}
EOF

    cat > ${_ansible_yml} << EOF
---
- hosts: install
  connection: ssh
  user: root
  tasks:
    - name: Install bsdkit
      delegate_to: localhost
      shell: |
        rsync -a --exclude=.git -e "ssh -p ${_remote_port} -i ${_ansible_key}" ${BSDKIT_SRCDIR}/ root@${_remote_address}:/root/bsdkit/

    - name: Run requested bsdkit function
      shell: $(__environment) /root/bsdkit/bsdkit deploy "$@" > /tmp/bsdkit.log 2>&1

- hosts: install
  connection: ssh
  user: root
  tasks:
    - name: Remove bsdkit
      file: path=/root/bsdkit state=absent
EOF

    eval env \
        ANSIBLE_CONFIG=${_ansible_cfg} \
        SSH_AUTH_SOCK="" \
        $(__environment) \
        ansible-playbook ${_ansible_yml}

    rm -r ${_ansible_root}
}

ansible_local_playbook() {
    __check_ansible

    ansible-playbook \
        --inventory localhost, \
        --connection local \
        -e ansible_python_interpreter=${ANSIBLE_PYTHON_INTERPRETER} \
        ${BSDKIT_SRCDIR}/playbook/playbook.yml $*
}

ansible_chroot_playbook() {
    __check_ansible

    local _ansible_root
    _ansible_root=$(mktemp -d /tmp/ansible_root.XXXXX)

    local _ansible_cfg=${_ansible_root}/ansible.cfg
    local _ansible_hosts=${_ansible_root}/ansible_hosts

    cat > ${_ansible_cfg} << EOF
[defaults]
inventory = ${_ansible_hosts}
EOF

    cat > ${_ansible_hosts} << EOF
${BSDKIT_DESTDIR} ansible_connection=community.general.chroot ansible_shell_type=sh ansible_python_interpreter=/usr/local/bin/python
EOF

    _bsdkit_interface="$(ifconfig -l -u ether | awk '{ print $1 }')"
    _bsdkit_ifconfig="$(kenv bsdkit_ifconfig 2> /dev/null || :)"
    _bsdkit_defaultrouter="$(kenv bsdkit_defaultrouter 2> /dev/null || :)"

    mount -t devfs devfs ${BSDKIT_DESTDIR}/dev

    {
        eval env \
             ANSIBLE_CONFIG=${_ansible_cfg} \
             SSH_AUTH_SOCK="" \
             $(__environment) \
             BSDKIT_INTERFACE=${_bsdkit_interface} \
             BSDKIT_IFCONFIG=${_bsdkit_ifconfig} \
             BSDKIT_DEFAULTROUTER=${_bsdkit_defaultrouter} \
             BSDKIT_CHROOT=1 \
             ansible-playbook ${BSDKIT_SRCDIR}/playbook/playbook.yml $*
    } always {
        umount -f ${BSDKIT_DESTDIR}/dev
    }

    rm -r ${_ansible_root}
}

configure() {
    ansible_local_playbook -t configure
}

digitalocean() {
    ansible_local_playbook -t digitalocean
}

sysprep() {
    __check_ansible

    ansible-playbook \
        --inventory localhost, \
        --connection local \
        -e ansible_python_interpreter=${ANSIBLE_PYTHON_INTERPRETER} \
        ${BSDKIT_SRCDIR}/playbook/sysprep.yml $*
}

update() {
    [ -d ${BSDKIT_SRCDIR}/.git ] || error "local git repository not found"

    cd ${BSDKIT_SRCDIR} && git fetch
    cd ${BSDKIT_SRCDIR} && git reset --hard origin/master
}

osrelease() {
    local _destdir=$1

    ${_destdir}/bin/freebsd-version -u
}

osreldate() {
    local _destdir=$1

    if [ -f ${_destdir}/usr/include/sys/param.h ]; then
        awk '/^\#define[[:blank:]]__FreeBSD_version/ { print $3 }' ${_destdir}/usr/include/sys/param.h
    else
        ${_destdir}/usr/bin/uname -K
    fi
}

echo_jail_conf() {
    local _destdir=$1

    __valid_destdir ${_destdir}

    local _jail_name

    _jail_name=$(basename ${_destdir})
    _jail_root=$(dirname ${_destdir})

    cat << EOF
exec.start = "/bin/sh /etc/rc";
exec.stop = "/bin/sh /etc/rc.shutdown";
exec.clean;

mount.devfs;
persist;

sysvsem = new;
sysvshm = new;
sysvmsg = new;

${_jail_name} {
        allow.raw_sockets;
        allow.sysvipc;

        osrelease = "$(osrelease ${_destdir})";
        osreldate = "$(osreldate ${_destdir})";

        path = "${_destdir%/}";
        host.hostname = "\${name}";
        host.domainname = "local";
        interface = "$(inet_interface)";
        # ip4.addr = "";
        # mount.fstab = "${_jail_root%/}/\${name}.fstab";
}
EOF
}

shell() {
    local _private_key
    _private_key=$(mktemp /tmp/key.XXXXXX)

    ssh -v -i ${_private_key} "$@" || :

    rm -f ${_private_key}
}

echo_bsdkit_private_key() {
    cat << EOF
-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEA1HXtR02wnKZhLILRVCWSmJqyMSvjDAAGRK9JQmNSkWTiMRu+
eeta+/JMR6a1PdeOKzLaf9hoySY3w6CMHl4fmCp0SlY9wAz8OVh0vd3SVSubxxhr
/nxdbXV5W8jtvYEMMKq1mz5qr7IW3PRdgDj1h5ldArqmKWekpNBM7wQlZsedrmRP
TW69fXQQZPPOcVlTR+FODR7hGFIW8YHGmgrRo7Ccv/sIFKgkyaesWrwe9z39tO8i
PGZzM32o3tBDDdrw67qZ7Q6J95YLaXNlRZ7RdQ0MJ9AUhg9SFtccqJHWxCD7doQr
dN3G4txv+z5e6GlWS33LTWBO4/aKK7mRGf6LzQIDAQABAoIBAQDNT/iwgx89Anu9
a92mF3kHB9dTNToACrYEAfAlu52662a6VjlH0GzoNEoKo8tZq8izbj1Adn0shUY2
Qhul7QdTIROoEpcx1FqZgCWwpX/w1md/itYx4zTV5kQUsqMsEl0ZWp6NG1A14T++
3lbM5j4/f7EmRgD02jd9Hd56y+Lo4hGirKSI9bZrHX5EnuFnNfLbZa12Po8e/4IR
D67c73psfohTMDMXTajRHJvd7CytH2MfnoXwHbewVZiph6lVEe1DRxDzwmQXEboi
xtTzk78cu7GJVDlt4KjojuumBsy/82Fz/ptbwyr0NnddCRftUVhAPdft+4lhlRGc
yn9C+DzxAoGBAP9PR+O4o/mvc5d5bQsUeagyXskzdwpgbEnsARizfmjC7uVLe5oz
It/IsuQUXwcg5ZIPzvTiHyE3XSUxuz/+uEXYXnXlweE5YILCMR2g60XvwNDQGWXw
bY9e8oO5fs7QYGHfgaezfGMRVcOuU8gWI6pw1wQwv40vUBOm/ZEO2lf/AoGBANUI
/KsBOhK4mEJTY9Bzds42muoEuqdWa/cGkA5cZKMaDg/sb35oTON6jkCTjZrlYdBE
aeaBsw2yJlTCBPHeZ+CW4BOvx9VYwktOmgdhBB6GbzY6qtn5E9YNHoNYQibbD+bt
dsVLQeX6wCu+oSFtKetbzJBAfg+ic1MNia7KIPwzAoGBALcXjQ+jP3z1NSlA/FFA
2sojbVRPIyR+58nPhS3Is3O/sAEiM77uwyjHTntAnLGJBvnLenilnPt+L79Xvdhz
/ISiWYOlRHgXZL4BM6Xy3CbofFeDlWNEm92Aktyib20zhJtL5Th2AFMvgFj3sL/C
GMvHZntr1kMS1hNx41Be3XjTAoGAA3Vp5LzYXIVys2D3NeMqAp8QVMxO23ijuBb7
L8CAQcWihM+p37uBxA+xT4sVuXYP6Hmz3nIsngROawHbYrHhrdvFN4ybCfOu89oK
1iPVFUnJdG/vZiqND+SWojtEl6zmzTD9xKY8I6e2hv9JTmmfTJro706cvVQ92xNV
MOlHL9ECgYBw+gct9S92ZzpdWnVWkuo35sbD165OgBS/FBcZ/mBBlPewvPEl6Eib
nSxJrY3R2CaDt3O1YDRbv/ObGzQgQGnDuPoolsiBtT511tpgtm4WbXEQU/2X71p8
aHEWO0IB4Qpy47FIEiPSCd35Mc1iu6EjuRDAFTrHfVb+dDatWlzDOA==
-----END RSA PRIVATE KEY-----
EOF
}

echo_bsdkit_public_key() {
    cat << EOF
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDUde1HTbCcpmEsgtFUJZKYmrIxK+MMAAZEr0lCY1KRZOIxG75561r78kxHprU9144rMtp/2GjJJjfDoIweXh+YKnRKVj3ADPw5WHS93dJVK5vHGGv+fF1tdXlbyO29gQwwqrWbPmqvshbc9F2AOPWHmV0CuqYpZ6Sk0EzvBCVmx52uZE9Nbr19dBBk885xWVNH4U4NHuEYUhbxgcaaCtGjsJy/+wgUqCTJp6xavB73Pf207yI8ZnMzfaje0EMN2vDrupntDon3lgtpc2VFntF1DQwn0BSGD1IW1xyokdbEIPt2hCt03cbi3G/7Pl7oaVZLfctNYE7j9ooruZEZ/ovN bsdkit
EOF
}

get_boot_pool() {
    zpool get -H -o name,value bootfs | awk '$2 != "-" { print $1 }'
}

rebuild_zpool_cache() {
    zpool set cachefile=/etc/zfs/zpool.cache $(get_boot_pool)
}

purge_libdir() {
    local _directory=$1

    for _item in ${_directory}/*(/N); do
        case $(basename ${_item}) in
            site_*) ;;

            vendor_*) ;;

            *)
                if [ $(find ${_item} -type f | wc -l) -eq 1 ]; then
                    case $(find ${_item} -type f) in
                        */mandoc.db)
                            echo "removing ${_item} (mandoc)"
                            rm -r -f ${_item}
                            ;;
                        *) ;;
                    esac
                elif [ $(find ${_item} -type f | wc -l) -eq 0 ]; then
                    echo "removing ${_item} (empty)"
                    rm -r -f ${_item}
                fi
                ;;
        esac
    done
}

purge_local_libdirs() {
    purge_libdir /usr/local/lib/ruby
    purge_libdir /usr/local/lib/ruby/site_ruby
    purge_libdir /usr/local/lib/ruby/vendor_ruby
    purge_libdir /usr/local/lib/perl5
}

purge_pkg_tempfiles() {
    local _path=$1

    find ${_path} -print0 \( -type f -o -type l \) \
        | awk 'BEGIN { RS="\\0" } $0 ~ /\.[a-zA-Z0-9]{12}$/ { print $0 }' \
        | fzf -e -m --print0 | xargs -0 rm -v
}

zfs_create_postgresql() {
    local _pool
    _pool=$(get_boot_pool)

    local _exists="NO"

    zfs get -H -o value name ${_pool}/var/db/postgres > /dev/null 2>&1 && _exists="YES"

    if ! is_yes ${_exists}; then
        if [ -d /var/db/postgres.orig ]; then
            return 1
        fi

        mkdir /var/db/postgres.orig

        cd /var/db/postgres
        find . | cpio -p -d -u -v /var/db/postgres.orig

        zfs create \
            -o compression=$(__zfs_compression) \
            -o atime=off \
            -o redundant_metadata=most \
            ${_pool}/var/db/postgres

        install -o postgres -g postgres -m 755 -d /var/db/postgres

        cd /var/db/postgres.orig

        find . | cpio -p -d -u -v /var/db/postgres

        cd /var/db

        rm -r -f /var/db/postgres.orig
    fi
}

rc_set() {
    local _file=$1
    local _key=$2
    local _value=$3

    if grep -E "^[[:space:]]*${_key}|#[[:space:]]*${_key}" ${_file} > /dev/null 2>&1; then
        sed -E -i '' -e "/^[[:space:]]*${_key}[[:space:]]*=[[:space:]]*/ c\\
${_key}=\"${_value}\"
/^[[:space:]]*#[[:space:]]*${_key}/ c\\
${_key}=\"${_value}\"
" ${_file}
    else
        echo "${_key}=\"${_value}\"" >> ${_file}
    fi
}

rc_delete() {
    local _file=$1
    local _key=$2

    [ -e ${_file} ] || return 0

    sed -E -i '' -e "/^[[:space:]]*${_key}[[:space:]]*=/d" ${_file}
}

rc_get() {
    local _file=$1
    local _key=$2

    local _buffer
    _buffer="$(grep -E "^[[:space:]]*${_key}[[:space:]]*=" ${_file})"

    local _value1
    _value1=$(echo ${_buffer} | sed -E -e "s/[^=]*[[:space:]]*=//")

    local _value2
    _value2=$(expr ${_value1} : "\"\(.*\)\"")

    if [ -n ${_value2} ]; then
        echo ${_value2}
    else
        echo ${_value1}
    fi
}

if [ $# -gt 0 ]; then
    ${(@s/ /)@}
fi

# References:
#   https://wiki.freebsd.org/AvgLiveCD
#   https://wiki.freebsd.org/RootOnZFS/ZFSBootPartition

# Local Variables:
# mode: sh
# sh-indentation: 4
# sh-basic-offset: 4
# End:
