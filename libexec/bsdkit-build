#!/usr/bin/env zsh

setopt errreturn nounset pipefail

SCRIPT_PATH="$(dirname $(realpath $0))"
SCRIPT_NAME="$(basename $0)"

source ${SCRIPT_PATH}/../lib/system.inc.sh
source ${SCRIPT_PATH}/../lib/colors.inc.sh
source ${SCRIPT_PATH}/../lib/hr-to-bytes.inc.sh
source ${SCRIPT_PATH}/../lib/is-yes.inc.sh
source ${SCRIPT_PATH}/../lib/yaml.inc.sh

if [ "$(uname -s)" != "FreeBSD" ]; then
    error "Must be executed on FreeBSD."
    exit 1
fi

BSDKIT_PATH="$(realpath ${SCRIPT_PATH}/../)"

if [ -x /usr/local/bin/vim ]; then
    export EDITOR=/usr/local/bin/vim
fi

# ===========================================================================

DEFAULT_VERSION=14
DEFAULT_ARCH=amd64

unset POSIXLY_CORRECT

if [ $(whoami) != "root" ]; then
    error "Must be executed as root."
    exit 1
fi

show_help() {
    cat << EOF

${SCRIPT_NAME} - Build FreeBSD releases, ISOs, USB images, and VM images

USAGE:
    ${SCRIPT_NAME} [OPTIONS]

OPTIONS:
    -h                  Show this help message

  Build Targets:
    -R                  Build release (world, kernel, packages, OCI, VM images)
    -S                  Build staging area
    -I                  Build ISO image
    -U                  Build USB image
    -V                  Build VM images (qcow2, raw, vmdk, vhd)
    -C                  Build cloud-init enabled VM images
    -A                  Build all: release/staging/ISO/USB

  Build Configuration:
    -v VERSION          FreeBSD version (default: ${DEFAULT_VERSION})
    -a ARCH             Target architecture (default: ${DEFAULT_ARCH})
    -j JOBS             Number of parallel jobs for make
    -E                  Use existing build (skip buildworld/buildkernel)
    -P                  Include packages in ISO/USB images

  VM Image Options:
    -F FILESYSTEMS      VM filesystems, space-separated (default: ufs zfs)
                        Available: ufs, zfs
    -M FORMATS          VM image formats, space-separated (default: qcow2)
                        Available: qcow2, raw, vmdk, vhd
    -Q SIZE             VM disk size (default: 10g)
    -W SIZE             VM swap size (default: 2g)

EXAMPLES:
    # Build complete release with all components
    ${SCRIPT_NAME} -v 14 -a amd64 -j 16 -A

    # Build just a cloud-init VM image
    ${SCRIPT_NAME} -v 14 -a amd64 -C

    # Build VM images in multiple formats with custom size
    ${SCRIPT_NAME} -v 14 -a amd64 -V -M "qcow2 raw vmdk" -Q 20g -W 4g

    # Build VM images for ZFS only
    ${SCRIPT_NAME} -v 14 -a amd64 -V -F zfs

    # Build release and cloud-init images
    ${SCRIPT_NAME} -v 14 -a amd64 -j 16 -R -S -C

    # Build ISO with packages included
    ${SCRIPT_NAME} -v 14 -a amd64 -P -I

VM IMAGE TYPES:
    Regular (-V):       Basic VM images without cloud-init
                        Output: bsdkit-\${version}-\${arch}.\${fs}.\${format}
                        (where \${fs} is ufs or zfs, \${format} is from -M)

    Cloud-init (-C):    VM images with cloud-init support
                        Includes: config-drive, growfs, DHCP, serial console
                        Output: bsdkit-\${version}-\${arch}-cloudinit.\${fs}.\${format}

DIRECTORIES:
    Source:             \$BSDKIT_DATA/src/\${version}/src
    Release:            \$BSDKIT_DATA/src/\${version}/release-\${arch}
    Staging:            \$BSDKIT_DATA/staging-\${version}-\${arch}
    ISO/USB:            \$BSDKIT_DATA/iso/
    VM images:          \$BSDKIT_DATA/vmimages-\${version}-\${arch}

EOF
}

# Allow -h to work without root
for arg in "$@"; do
    if [ "$arg" = "-h" ]; then
        show_help
        exit 0
    fi
done

if [ $# -eq 0 ]; then
    show_help
    exit 0
fi

_version=${DEFAULT_VERSION}
_arch=${DEFAULT_ARCH}
_jobs_option=""
_use_existing=""
_with_packages=""

_build_release=""
_build_staging=""
_build_iso=""
_build_usb=""
_build_vmimage=""

_with_cloudinit=""
_vm_filesystems="ufs zfs"
_vm_formats="qcow2"
_vm_size="10g"
_vm_swapsize="2g"

OPTIND=1
while getopts "hv:a:j:F:M:Q:W:EPRSIUCVA" OPT; do
    case ${OPT} in
        h)
            show_help
            exit 0
            ;;
        v)
            _version="${OPTARG}"
            ;;
        a)
            _arch="${OPTARG}"
            ;;
        j)
            _jobs_option="-j${OPTARG}"
            ;;
        F)
            _vm_filesystems="${OPTARG}"
            ;;
        M)
            _vm_formats="${OPTARG}"
            ;;
        Q)
            _vm_size="${OPTARG}"
            ;;
        W)
            _vm_swapsize="${OPTARG}"
            ;;
        E)
            _use_existing="YES"
            ;;
        P)
            _with_packages="YES"
            ;;
        R)
            _build_release="YES"
            ;;
        S)
            _build_staging="YES"
            ;;
        I)
            _build_iso="YES"
            ;;
        U)
            _build_usb="YES"
            ;;
        V)
            _build_vmimage="YES"
            ;;
        C)
            _with_cloudinit="YES"
            _build_vmimage="YES"
            ;;
        A)
            _build_release="YES"
            _build_staging="YES"
            _build_iso="YES"
            _build_usb="YES"
            ;;
        *)
            show_help
            exit 1
            ;;
    esac
done

shift $((OPTIND - 1))

# ===

OS_SRCDIR=${BSDKIT_DATA}/src/${_version}/src

if [ ! -d "${OS_SRCDIR}" ]; then
    error "Source directory not found: ${OS_SRCDIR}"
    exit 1
fi

OS_RELDIR=${BSDKIT_DATA}/src/${_version}/release-${_arch}
OS_REPODIR=${BSDKIT_DATA}/pkgbase

OS_MAJOR=$(get-src-major-version ${OS_SRCDIR})
OS_MINOR=$(get-src-minor-version ${OS_SRCDIR})
OS_PATCH=$(get-src-patch-version ${OS_SRCDIR})

# ===

build-release() {
    local _make_conf=${BSDKIT_PATH}/etc/make.conf
    local _src_conf=${BSDKIT_PATH}/etc/src.conf

    install -o root -g wheel -m 644 ansible/BSDKIT-${_version}-${_arch} ${OS_SRCDIR}/sys/${_arch}/conf/BSDKIT

    KERNCONF="BSDKIT"

    message ">>> Start of build: $(date "+%Y-%m-%d %H:%M:%S")"

    if [ -z "${_use_existing}" ]; then
        env -i make -s -C ${OS_SRCDIR} \
            __MAKE_CONF=${_make_conf} SRCCONF=${_src_conf} TARGET=${_arch} TARGET_ARCH=${_arch} KERNCONF="${KERNCONF}" \
            ${_jobs_option} buildworld buildkernel

        env -i make -s -C ${OS_SRCDIR}/release \
            __MAKE_CONF=${_make_conf} SRCCONF=${_src_conf} TARGET=${_arch} TARGET_ARCH=${_arch} KERNCONF="${KERNCONF}" \
            release NOPORTS="YES"
    fi

    rm -r -f ${OS_RELDIR}
    mkdir -p ${OS_RELDIR}

    if [ -z "${BSDKIT_SKIP_PACKAGES}" ]; then
        env -i make -s -C ${OS_SRCDIR} \
            __MAKE_CONF=${_make_conf} SRCCONF=${_src_conf} TARGET=${_arch} TARGET_ARCH=${_arch} KERNCONF="${KERNCONF}" \
            ${_jobs_option} packages REPODIR=${OS_REPODIR}
    fi

    if [ -z "${BSDKIT_SKIP_OCI}" ]; then
        env -i PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin make -s -C ${OS_SRCDIR}/release \
            __MAKE_CONF=${_make_conf} SRCCONF=${_src_conf} TARGET=${_arch} TARGET_ARCH=${_arch} KERNCONF="${KERNCONF}" \
            WITH_OCIIMAGES=yes oci-release
    fi

    if [ -z "${_use_existing}" ]; then
        env -i make -s -C ${OS_SRCDIR}/release \
            __MAKE_CONF=${_make_conf} SRCCONF=${_src_conf} TARGET=${_arch} TARGET_ARCH=${_arch} \
            ${_jobs_option} clean
    fi

    env -i make -s -C ${OS_SRCDIR}/release \
        __MAKE_CONF=${_make_conf} SRCCONF=${_src_conf} TARGET=${_arch} TARGET_ARCH=${_arch} KERNCONF="${KERNCONF}" \
        install DESTDIR=${OS_RELDIR}

    get-src-osrelease ${OS_SRCDIR} > ${OS_RELDIR}/ftp/RELEASE

    etcupdate build -s ${OS_SRCDIR} ${OS_RELDIR}/ftp/etcupdate.tar.bz2

    echo -n > ${OS_RELDIR}/ftp/OLDFILES

    env -i make -s -C ${OS_SRCDIR} list-old-files | sed 's/^/old-files: /' >> ${OS_RELDIR}/ftp/OLDFILES
    env -i make -s -C ${OS_SRCDIR} list-old-dirs | sed 's/^/old-dirs: /' >> ${OS_RELDIR}/ftp/OLDFILES
    env -i make -s -C ${OS_SRCDIR} list-old-libs | sed 's/^/old-libs: /' >> ${OS_RELDIR}/ftp/OLDFILES

    env -i make -s -C ${OS_SRCDIR}/release \
        __MAKE_CONF=${_make_conf} SRCCONF=${_src_conf} TARGET=${_arch} TARGET_ARCH=${_arch} KERNCONF="${KERNCONF}" \
        clean

    message ">>> End of build: $(date "+%Y-%m-%d %H:%M:%S")"

    rm -f ${OS_SRCDIR}/sys/${_arch}/conf/BSDKIT
}

build-staging() {
    local _target=${BSDKIT_DATA}/release-${_version}-${_arch}

    if [ -d "${OS_RELDIR}/ftp" ]; then
        if [ -d "${_target}" ]; then
            rm -r -f ${_target}
        fi

        mkdir -p ${_target}
        cp ${OS_RELDIR}/ftp/* ${_target}
    fi

    ${BSDKIT_PATH}/bsdkit build-setup-staging \
        ${BSDKIT_DATA}/staging-${_version}-${_arch} \
        . \
        ${BSDKIT_DATA}/release-${_version}-${_arch} \
        ${BSDKIT_DATA}/packages-FreeBSD:${OS_MAJOR}:${_arch}-default-nox11
}

build-iso() {
    local _iso=${BSDKIT_DATA}/iso/release-${_version}-${_arch}.iso
    local _release="none"
    local _packages="none"

    if [ -n "${_with_packages}" ]; then
        _iso=${BSDKIT_DATA}/iso/release-${_version}-${_arch}.full.iso
        _release=${BSDKIT_DATA}/release-${_version}-${_arch}
        _packages=${BSDKIT_DATA}/packages-FreeBSD:${OS_MAJOR}:${_arch}-default-nox11
    fi

    ${BSDKIT_PATH}/bsdkit build-setup-iso \
        ${_iso} \
        ${BSDKIT_DATA}/staging-${_version}-${_arch} \
        ${_release} \
        ${_packages}
}

build-usb() {
    local _iso=${BSDKIT_DATA}/iso/release-${_version}-${_arch}.iso
    local _usb=${BSDKIT_DATA}/iso/release-${_version}-${_arch}.img

    if [ -n "${_with_packages}" ]; then
        _iso=${BSDKIT_DATA}/iso/release-${_version}-${_arch}.full.iso
        _usb=${BSDKIT_DATA}/iso/release-${_version}-${_arch}.full.img
    fi

    ${BSDKIT_PATH}/bsdkit build-setup-img ${_iso} ${_usb}
}

build-vmimage() {
    local _make_conf=${BSDKIT_PATH}/etc/make.conf
    local _src_conf=${BSDKIT_PATH}/etc/src.conf
    local _vmimage_dir=${BSDKIT_DATA}/vmimages-${_version}-${_arch}
    local _objdir=/usr/obj${OS_SRCDIR}/${_arch}.${_arch}/release

    mkdir -p ${_vmimage_dir}

    if [ -n "${_with_cloudinit}" ]; then
        # Build cloud-init enabled images using cloudware system
        message ">>> Building CLOUDINIT VM images: ${_vm_filesystems} / ${_vm_formats} (size: ${_vm_size}, swap: ${_vm_swapsize})"

        # Clean only cloudware VM artifacts to force rebuild
        message ">>> Cleaning existing cloudware artifacts"
        chflags -R noschg ${_objdir}/cw-basic-cloudinit-*(N) ${_objdir}/basic-cloudinit.*(N) 2>/dev/null || true
        rm -rf ${_objdir}/cw-basic-cloudinit-*(N)
        rm -f ${_objdir}/basic-cloudinit.*.(img|qcow2|raw|vmdk|vhd)(N)

        env -i PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin make -s -C ${OS_SRCDIR}/release \
            __MAKE_CONF=${_make_conf} SRCCONF=${_src_conf} \
            TARGET=${_arch} TARGET_ARCH=${_arch} \
            KERNCONF="BSDKIT" \
            WITH_CLOUDWARE=YES \
            CLOUDWARE="BASIC-CLOUDINIT" \
            VMFSLIST="${_vm_filesystems}" \
            VMSIZE="${_vm_size}" \
            SWAPSIZE="${_vm_swapsize}" \
            WORLDDIR=${OS_SRCDIR} \
            cloudware-release

        # Copy cloud-init images
        message ">>> Installing CLOUDINIT VM images to ${_vmimage_dir}"
        for img in ${_objdir}/basic-cloudinit.*.(qcow2|raw|vmdk|vhd)(N); do
            if [ -f "${img}" ]; then
                local basename=$(basename ${img})
                local newname=$(echo ${basename} | sed "s/^basic-cloudinit\./bsdkit-${_version}-${_arch}-cloudinit./")
                cp -v ${img} ${_vmimage_dir}/${newname}
            fi
        done

        # Clean up cloudware build artifacts
        message ">>> Cleaning up CLOUDINIT build artifacts"
        chflags -R noschg ${_objdir}/cw-basic-cloudinit-*(N) 2>/dev/null || true
        rm -rf ${_objdir}/cw-basic-cloudinit-*(N)
        rm -f ${_objdir}/basic-cloudinit.*.img(N)
    else
        # Build regular VM images
        message ">>> Building VM images: ${_vm_filesystems} / ${_vm_formats} (size: ${_vm_size}, swap: ${_vm_swapsize})"

        # Clean only VM artifacts to force rebuild
        message ">>> Cleaning existing VM artifacts"
        chflags -R noschg ${_objdir}/vm-image-*(N) ${_objdir}/vm.*(N) 2>/dev/null || true
        rm -rf ${_objdir}/vm-image-*(N)
        rm -f ${_objdir}/vm.*.(img|qcow2|raw|vmdk|vhd)(N) ${_objdir}/*.(ufs|zfs).img(N) ${_objdir}/vm-image(N)

        env -i PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin make -s -C ${OS_SRCDIR}/release \
            __MAKE_CONF=${_make_conf} SRCCONF=${_src_conf} \
            TARGET=${_arch} TARGET_ARCH=${_arch} \
            KERNCONF="BSDKIT" \
            WITH_VMIMAGES=YES \
            VMFSLIST="${_vm_filesystems}" \
            VMFORMATS="${_vm_formats}" \
            VMSIZE="${_vm_size}" \
            SWAPSIZE="${_vm_swapsize}" \
            WORLDDIR=${OS_SRCDIR} \
            vm-release

        # Copy VM images
        message ">>> Installing VM images to ${_vmimage_dir}"
        for img in ${_objdir}/vm.*.(qcow2|raw|vmdk|vhd)(N); do
            if [ -f "${img}" ]; then
                local basename=$(basename ${img})
                local newname=$(echo ${basename} | sed "s/^vm\./bsdkit-${_version}-${_arch}./")
                cp -v ${img} ${_vmimage_dir}/${newname}
            fi
        done

        # Clean up regular VM build artifacts
        message ">>> Cleaning up VM build artifacts"
        chflags -R noschg ${_objdir}/vm-image-*(N) 2>/dev/null || true
        rm -rf ${_objdir}/vm-image-*(N)
        rm -f ${_objdir}/vm.*.img(N) ${_objdir}/*.img(N) ${_objdir}/vm-image(N)
    fi

    message ">>> VM images created in: ${_vmimage_dir}"
    ls -lh ${_vmimage_dir}
}

if [ -n "${_build_release}" ]; then
    build-release
fi

if [ -n "${_build_staging}" ]; then
    build-staging
fi

if [ -n "${_build_iso}" ]; then
    build-iso
fi

if [ -n "${_build_usb}" ]; then
    build-usb
fi

if [ -n "${_build_vmimage}" ]; then
    if [ -z "${BSDKIT_SKIP_VM}" ]; then
        build-vmimage
    fi
fi
