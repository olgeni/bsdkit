#!/usr/bin/env zsh

set -o errexit -o nounset -o pipefail  # Exit on error, undefined vars, pipe failures

# Default values
DEFAULT_REGION="fra1"
DEFAULT_VERSION="14.3-RELEASE"
DEFAULT_ARCH="amd64"

# Parse command line arguments using zparseopts
# zparseopts flags:
# -D: Remove recognized options from positional parameters
# -E: Stop at first unrecognized option (don't error on unknown options)
# -F: Fail if unrecognized options are found
zparseopts -D -E -F -- \
    r:=region_arg -region:=region_arg \
    v:=version_arg -version:=version_arg \
    a:=arch_arg -arch:=arch_arg \
    k:=token_arg -token:=token_arg \
    n=dry_run_arg -dry-run=dry_run_arg \
    h=help_arg -help=help_arg || exit 1

# Show help if requested
if [[ -n "${help_arg}" ]]; then
    cat >&2 <<EOF
Usage: ${0:t} [options]

Options:
    -r, --region REGION     DigitalOcean region (default: ${DEFAULT_REGION})
    -v, --version VERSION   FreeBSD version (default: ${DEFAULT_VERSION})
    -a, --arch ARCH         Architecture (default: ${DEFAULT_ARCH})
    -k, --token TOKEN       DigitalOcean API token (overrides DIGITALOCEAN_ACCESS_TOKEN)
    -n, --dry-run           Show operations without executing them
    -h, --help              Show this help message

Environment variables required:
    DIGITALOCEAN_ACCESS_TOKEN   DigitalOcean API token (or use -k/--token)
    STORAGE_BUCKET              Google Cloud Storage bucket (e.g., gs:bucket/path)
    STORAGE_URL                 Public URL for storage (e.g., https://storage.googleapis.com/bucket/path)

Examples:
    # Release build
    DIGITALOCEAN_ACCESS_TOKEN=token \\
    STORAGE_BUCKET=gs:mybucket/FreeBSD/image \\
    STORAGE_URL=https://mybucket.storage.googleapis.com/FreeBSD/image \\
    ${0:t} --region nyc3 --version 14.3-RELEASE

    # Snapshot builds (automatically detected from version suffix)
    DIGITALOCEAN_ACCESS_TOKEN=token \\
    STORAGE_BUCKET=gs:mybucket/FreeBSD/image \\
    STORAGE_URL=https://mybucket.storage.googleapis.com/FreeBSD/image \\
    ${0:t} --region nyc3 --version 15.0-CURRENT    # Current development

    DIGITALOCEAN_ACCESS_TOKEN=token \\
    STORAGE_BUCKET=gs:mybucket/FreeBSD/image \\
    STORAGE_URL=https://mybucket.storage.googleapis.com/FreeBSD/image \\
    ${0:t} --region nyc3 --version 14.3-STABLE     # Stable branch

    DIGITALOCEAN_ACCESS_TOKEN=token \\
    STORAGE_BUCKET=gs:mybucket/FreeBSD/image \\
    STORAGE_URL=https://mybucket.storage.googleapis.com/FreeBSD/image \\
    ${0:t} --region nyc3 --version 15.0-ALPHA5     # Alpha release

    DIGITALOCEAN_ACCESS_TOKEN=token \\
    STORAGE_BUCKET=gs:mybucket/FreeBSD/image \\
    STORAGE_URL=https://mybucket.storage.googleapis.com/FreeBSD/image \\
    ${0:t} --region nyc3 --version 15.0-BETA1      # Beta release

    DIGITALOCEAN_ACCESS_TOKEN=token \\
    STORAGE_BUCKET=gs:mybucket/FreeBSD/image \\
    STORAGE_URL=https://mybucket.storage.googleapis.com/FreeBSD/image \\
    ${0:t} --region nyc3 --version 15.0-RC1        # Release candidate
EOF
    exit 0
fi

# Define common variables with defaults
REGION="${region_arg[2]:-${DEFAULT_REGION}}"
DISTRIBUTION="Unknown"
VERSION="${version_arg[2]:-${DEFAULT_VERSION}}"
ARCH="${arch_arg[2]:-${DEFAULT_ARCH}}"
DRY_RUN="${dry_run_arg[1]:+true}"
WORK_DIR="/tmp/freebsd-images"

# Automatically detect snapshot based on version suffix
# Only CURRENT and STABLE are in snapshots; ALPHA, BETA, RC are in releases
if [[ "${VERSION}" == *"-CURRENT" || "${VERSION}" == *"-STABLE" ]]; then
    SNAPSHOT="true"
else
    SNAPSHOT=""
fi

# Set DigitalOcean token from command line or environment
if [[ -n "${token_arg[2]:-}" ]]; then
    DIGITALOCEAN_ACCESS_TOKEN="${token_arg[2]}"
fi

# Check for required environment variables
if [[ -z "${DIGITALOCEAN_ACCESS_TOKEN:-}" ]]; then
    echo "Error: DIGITALOCEAN_ACCESS_TOKEN environment variable is not set (use -k/--token or set the environment variable)" >&2
    exit 1
fi

if [[ -z "${STORAGE_BUCKET:-}" ]]; then
    echo "Error: STORAGE_BUCKET environment variable is not set" >&2
    exit 1
fi

if [[ -z "${STORAGE_URL:-}" ]]; then
    echo "Error: STORAGE_URL environment variable is not set" >&2
    exit 1
fi

# Define image types
image_types=("ufs" "zfs")

# Function to process and upload image
process_image() {
    local image_type="$1"

    # Determine base URL based on snapshot flag
    local base_url
    if [[ "${SNAPSHOT}" == "true" ]]; then
        base_url="https://download.freebsd.org/ftp/snapshots/VM-IMAGES/${VERSION}/${ARCH}/Latest"
    else
        base_url="https://download.freebsd.org/ftp/releases/VM-IMAGES/${VERSION}/${ARCH}/Latest"
    fi

    local filename="FreeBSD-${VERSION}-${ARCH}-${image_type}.qcow2"
    local compressed_filename="${filename}.xz"
    local bz2_filename="${filename}.bz2"

    echo "Processing ${image_type} image..." >&2

    # Create work directory
    if [[ "${DRY_RUN}" == "true" ]]; then
        echo "[DRY-RUN] Would create work directory: ${WORK_DIR}" >&2
    else
        mkdir -p "${WORK_DIR}"
        cd "${WORK_DIR}"
    fi

    # Download image if not exists - try both filename patterns
    if [[ ! -f "${compressed_filename}" ]]; then
        # Try dot pattern first: FreeBSD-VERSION-ARCH-BASIC-CLOUDINIT.TYPE.qcow2.xz
        local remote_filename_dot="FreeBSD-${VERSION}-${ARCH}-BASIC-CLOUDINIT.${image_type}.qcow2"
        local compressed_remote_filename_dot="${remote_filename_dot}.xz"
        local decompressed_filename="${filename}"

        if [[ "${DRY_RUN}" == "true" ]]; then
            echo "[DRY-RUN] Would download: ${base_url}/${compressed_remote_filename_dot}" >&2
            echo "[DRY-RUN] Would save to: ${compressed_filename}" >&2
        elif curl -L -f -o "${compressed_filename}" "${base_url}/${compressed_remote_filename_dot}" 2>/dev/null; then
            echo "Downloaded using dot pattern." >&2
        else
            # Fallback to hyphen pattern: FreeBSD-VERSION-ARCH-BASIC-CLOUDINIT-TYPE.qcow2.xz
            local remote_filename_hyphen="FreeBSD-${VERSION}-${ARCH}-BASIC-CLOUDINIT-${image_type}.qcow2"
            local compressed_remote_filename_hyphen="${remote_filename_hyphen}.xz"

            echo "Dot pattern failed, trying hyphen pattern: ${compressed_remote_filename_hyphen}..." >&2
            if [[ "${DRY_RUN}" == "true" ]]; then
                echo "[DRY-RUN] Would download: ${base_url}/${compressed_remote_filename_hyphen}" >&2
                echo "[DRY-RUN] Would save to: ${compressed_filename}" >&2
            elif ! curl -L -o "${compressed_filename}" "${base_url}/${compressed_remote_filename_hyphen}"; then
                rm -f "${compressed_filename}"
                echo "Download failed, partial file removed" >&2
                exit 1
            fi
        fi
    fi

    # Decompress if needed
    if [[ ! -f "${decompressed_filename}" ]]; then
        if [[ "${DRY_RUN}" == "true" ]]; then
            echo "[DRY-RUN] Would decompress: ${compressed_filename}" >&2
        else
            echo "Decompressing ${compressed_filename}..." >&2
            if ! xz -d -k "${compressed_filename}"; then
            echo "Decompression failed. Examining file..." >&2
            echo "File type: $(file "${compressed_filename}")" >&2
            echo "File size: $(ls -lh "${compressed_filename}" | awk '{print $5}')" >&2
            echo "First 100 bytes:" >&2
            head -c 100 "${compressed_filename}" | xxd >&2
                rm -f "${compressed_filename}" "${decompressed_filename}"
                echo "Decompression failed, corrupted file removed. Please run again to re-download." >&2
                exit 1
            fi
        fi
    fi

    # Rename to desired filename if different
    if [[ "${decompressed_filename}" != "${filename}" && ! -f "${filename}" ]]; then
        if [[ "${DRY_RUN}" == "true" ]]; then
            echo "[DRY-RUN] Would rename: ${decompressed_filename} to ${filename}" >&2
        else
            mv "${decompressed_filename}" "${filename}"
        fi
    fi

    # Recompress with bzip2 if needed
    if [[ ! -f "${bz2_filename}" ]]; then
        if [[ "${DRY_RUN}" == "true" ]]; then
            echo "[DRY-RUN] Would compress with bzip2: ${filename} -> ${bz2_filename}" >&2
        else
            echo "Compressing with bzip2..." >&2
            bzip2 -1 -k -v "${filename}" >&2
        fi
    fi

    # Upload to Google Cloud Storage
    if [[ "${DRY_RUN}" == "true" ]]; then
        echo "[DRY-RUN] Would upload to GCS: ${bz2_filename} -> ${STORAGE_BUCKET}/${bz2_filename}" >&2
    else
        echo "Uploading to GCS as ${bz2_filename}..." >&2
        rclone --progress copyto "${bz2_filename}" "${STORAGE_BUCKET}/${bz2_filename}" >&2 2>&1
    fi

    # Return the GCS URL
    echo "${STORAGE_URL}/${bz2_filename}"
}

# Function to create Digital Ocean image
create_do_image() {
    local image_type="$1"
    local gcs_url="$2"

    local image_name="FreeBSD-${VERSION}-${ARCH}-${image_type}"
    local description="FreeBSD ${VERSION} ${image_type:u}"

    echo "Creating image (${image_type})..."

    if [[ "${DRY_RUN}" == "true" ]]; then
        echo "[DRY-RUN] Would create DigitalOcean image:"
        echo "  Name: ${image_name}"
        echo "  Region: ${REGION}"
        echo "  Distribution: ${DISTRIBUTION}"
        echo "  Tags: FreeBSD"
        echo "  Description: ${description}"
        echo "  URL: ${gcs_url}"
    else
        doctl compute image create "${image_name}" \
            --region "${REGION}" \
            --image-distribution "${DISTRIBUTION}" \
            --tag-names "FreeBSD" \
            --image-description "${description}" \
            --image-url "${gcs_url}"
    fi
}

# Function to cleanup work directory
cleanup() {
    if [[ "${DRY_RUN}" == "true" ]]; then
        echo "[DRY-RUN] Would clean up temporary files in: ${WORK_DIR}"
    else
        echo "Cleaning up temporary files..."
        if [[ -d "${WORK_DIR}" ]]; then
            rm -rf "${WORK_DIR}"
            echo "Cleanup complete."
        fi
    fi
}

# Main execution
main() {
    # Set trap to cleanup on exit
    trap cleanup EXIT

    # Process each image type
    for image_type in "${image_types[@]}"; do
        gcs_url=$(process_image "${image_type}")

        # Create image in Digital Ocean
        create_do_image "${image_type}" "${gcs_url}"
    done

    echo "All images processed and uploaded!"
}

# Run main function
main
